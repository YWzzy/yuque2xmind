{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"html":"浏览器","type":"mindmap","border":{"fill":"#EFF0F0","shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"x":575,"y":2383.5,"id":"b68e48c7-53c9-4e95-a813-8cfc1c752be7","children":[{"treeEdge":{"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"2494a9f4-1b2e-4556-9db5-716de7796641","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8c4f9e01-06cf-42e7-af68-af2e614199b9","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ea9f6cbd-9251-4542-96e3-d1c041444102","children":[],"html":"首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。","zIndex":69},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9e02d22c-13a9-423a-8415-a8358d2d8800","children":[],"html":"然后对 CSS 进行解析，生成 CSSOM 规则树。","zIndex":70},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e0d918e8-aaa9-479b-8c5c-263a766a590e","children":[],"html":"根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。","zIndex":71},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7e8034e0-78a1-40b0-a91b-d36dc18166d1","children":[],"html":"当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。","zIndex":72},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1d91be2e-c03b-4e11-aa52-af0cb3e4c5db","children":[],"html":"布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。","zIndex":73},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7a241f86-504f-4c0a-91db-df0734b0dbfe","children":[],"zIndex":74,"html":"注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。"},{"start":0,"end":4,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\"><span style></span></div>","defaultContentStyle":{"color":"#262626"},"id":"d618d380-d87a-4055-b98e-e69f1416fa0d","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1712656917316-0b8547ea-21df-40a7-add2-2dd4a726d869.png","naturalWidth":1272,"naturalHeight":600,"uploadInfo":{"hash":"9b965273e70bdc5143becd45d1558af054f6cbfe55cedf9d6ff3e994b372bd25","fileName":"yuque_diagram (5).png","fileType":"image/png","fileSize":357401,"localTempSrc":"blob:https://www.yuque.com/ce66e3b4-0fe4-4c61-b5cc-556a2199655a","state":-2},"width":480,"height":226.41509433962264},"zIndex":75}],"html":"渲染过程","collapsed":true,"zIndex":25},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"fe964f51-5058-471a-a71e-55001d9c55b5","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"863e4d16-d823-4aa5-b342-bbf198a0a88e","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"983e5caa-90f5-4407-8c72-d28bee93fdd4","children":[],"html":"资源合并和压缩，减少HTTP请求次数和文件大小","zIndex":32},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"60eaebea-c045-4892-994a-1a631094d33f","children":[],"html":"利用浏览器缓存，包括HTTP缓存、资源预加载等","zIndex":33},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"22ef30f1-e007-4b28-adce-639a2bd3b7f5","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"75554931-9361-4642-a8e9-efd951d77bc2","children":[],"html":"CDN 可以通过地理位置优化、负载均衡、缓存优化、连接复用以及抗攻击能力等多种方式，加速静态资源的加载，提升网站的性能和用户体验","zIndex":30}],"html":"使用CDN加速资源加载","zIndex":31}],"html":"网络加载优化","zIndex":34},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e9a94a16-dbad-4269-b3bb-e5271b56a937","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f66cb87d-e5ac-4318-ac4a-18e5d9ba7bdb","children":[],"html":"减少DOM元素数量，避免嵌套过审的结构","zIndex":38},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"35cbe0d1-9f32-4ebb-b849-fd76f1e411b6","children":[],"html":"使用语义化标签，帮助浏览器更快理解文档结构","zIndex":39},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"bd6cea41-cadb-4a80-8ab9-daa8f7ff8361","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f23bb52f-ae5c-420f-b999-b5fa4028882a","children":[],"html":"async：下载JS是异步，下载完成会立即执行，会阻塞渲染","layout":{"quadrant":1},"zIndex":36},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a821af08-d675-48dc-9abd-a20dc0b79582","children":[],"html":"defer：下载是异步的，会等DOM树构建完毕，并且在DOMContentLoaded 事件触发之前执行","layout":{"quadrant":1},"zIndex":35}],"html":"尽量将script标签放在body最后，或者用async或者defer的方式引入script","zIndex":37}],"html":"HTML解析优化","layout":{"quadrant":1},"zIndex":40},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"fd5d4625-e421-4d4c-bbfc-8f96478ccccf","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c5c784c1-112c-490f-b06b-24bcc36a8dad","children":[],"html":"避免使用过多的样式规则和选择器，减少CSS文件大小","zIndex":49},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"92b4e8a3-fed1-466c-828b-2c629a11df7f","children":[],"html":"使用简单的 CSS 动画而不是使用 JavaScript 实现动画，以利用浏览器的硬件加速功能","zIndex":48}],"html":"CSS渲染优化","zIndex":50},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d91f3440-d85e-4fd4-9eab-69f2d3c3615b","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"546b9945-bf8e-4f79-99e6-fe622c40c617","children":[],"html":"避免频繁操作样式，最好一次性修改多个样式","zIndex":45},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b98a2473-955c-435d-bf13-fd1087c2bdbe","children":[],"html":"尽量减少不必要的元素重绘，例如使用transform属性而不是修改top和left属性来移动元素","zIndex":46},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1bfdd672-6a20-4834-8ee0-2ce9a88e964d","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d6d5c7c5-15ad-44fe-a878-b8a9a46059b7","children":[],"html":"<span style=\"font-weight:bold;\">GPU加速</span>：大部分浏览器使用GPU加速CSS3动画。GPU 通常能够处理图形任务更快，因此将动画委托给 GPU 处理可以提高动画的性能，减少 CPU 的负载。相比之下，JavaScript 动画通常由 CPU 处理，性能可能不如 GPU 加速的 CSS3 动画。","zIndex":43},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8a062daa-73a6-4a0b-8cc6-80b5498e0086","children":[],"html":"<span style=\"font-weight:bold;\">硬件加速的转换和动画</span>：CSS3 动画可以应用于 CSS 属性，如 transform 和 opacity，这些属性可以通过硬件加速进行处理，而不需要触发重绘或回流。例如，使用 transform 属性进行动画时，浏览器可以在 GPU 上执行动画转换，而不会影响文档流，从而减少了重绘和回流。","zIndex":42},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ba4781a1-777e-4618-8feb-031db201bc27","children":[],"html":"<span style=\"font-weight:bold;\">优化的动画循环</span>：浏览器能够优化 CSS3 动画的执行方式。例如，浏览器可以根据屏幕刷新率进行动画绘制，以确保动画流畅且不会引起撕裂或闪烁。","zIndex":41}],"html":"使用CSS3动画或变换来减少重绘和回流","zIndex":44}],"html":"布局(回流/重排)、绘制(重绘)优化","zIndex":47},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ff6956ce-c6c7-4c10-827c-1aca95403176","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"17ec8640-9a4f-4323-b584-0f910c18f645","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"023e9400-c500-45a9-9b8a-6d994f658fa9","children":[],"html":"怎么实现：利用 CSS3 属性、3D 变换、will-change 属性以及避免触发重绘和回流等方法，可以有效地利用 GPU 加速，将合成和绘制操作委托给 GPU，从而提高页面的性能和流畅度","zIndex":27}],"html":"利用 GPU 加速，将合成和绘制操作委托给 GPU","zIndex":28},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5aef5d75-f8e8-460b-945f-fcd30ce7efe2","children":[],"html":"使用 CSS 属性 will-change 来提示浏览器元素将要被修改，以便浏览器在后台优化渲染。","zIndex":26}],"html":"合成优化","zIndex":29}],"html":"渲染优化","zIndex":51},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"19652e9e-3bee-4924-9389-89f47715a720","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3d31d8fd-c9a4-4bed-95ac-7c2549a67540","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"89042865-aab1-4a50-b833-054b83a0f071","children":[],"html":"渲染树中部分或全部元素的尺寸、结构或者属性发生变化时，浏览器全部或部分重新渲染文档的过程，就是回流","zIndex":11},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"fedaad2e-f842-47b2-88d4-b820ffb03b27","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b509f871-e03e-431e-9a21-7ba4f6b2596a","children":[],"html":"页面首次渲染","zIndex":6},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"61bafef4-7083-4090-96b9-3406e22b1461","children":[],"html":"浏览器窗口大小变化","zIndex":8},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"42b97b69-abce-4035-acb4-0c4d1db841d4","children":[],"html":"页面内容、字体大小、激活伪类","zIndex":9},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"63eb12ca-e660-4826-9f85-4c673ba99591","children":[],"html":"查询元素的宽高","zIndex":7},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f3723bcf-728a-4ada-b33e-2b67212d32ee","children":[],"html":"添加或删除可见DOM元素","zIndex":5}],"html":"导致回流的操作","zIndex":10}],"html":"回流","zIndex":12},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"db658ab3-708e-4ee3-93fb-4c6e7e39d5a9","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"21859c25-d1f9-4c2f-9fc8-5cf054d38bda","children":[],"html":"样式变化，但是不影响元素在文档流中的位置时，浏览器就会对元素进行重绘","zIndex":14},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"074a18a7-9b16-4506-bb11-76c129df0bae","children":[],"html":"color、background、border-radius、visibility、opaticy","zIndex":13}],"html":"重绘","zIndex":15},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"16b471ca-dbec-4887-bf48-79c52caa24db","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a81170cc-a8b7-4d3d-bd5e-ad589a0d1e20","children":[],"html":"操作DOM时，尽量在低层级的DOM节点进行操作","zIndex":17},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8f93bb99-366d-45ea-8075-435370ab544c","children":[],"html":"不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。","zIndex":19},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e9b86a62-2f01-4948-ad0f-1ee405b437aa","children":[],"html":"不要使用table布局， 一个小的改动可能会使整个table进行重新布局","zIndex":20},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"aaaab691-0dad-48e7-a051-4a1edad59d8e","children":[],"html":"使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素","zIndex":22},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4846e4fa-091c-46b3-a1a9-925a090fe0e8","children":[],"html":"避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中","zIndex":21},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e0b824e8-cb3b-4859-83e5-d68af2bb1da6","children":[],"html":"Dom离线化：将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。","zIndex":18},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f3855320-1255-48b8-90ce-aa34e641d859","children":[],"html":"将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<span style=\"font-weight:bold;\">浏览器的渲染队列机制</span>。","zIndex":16}],"html":"如何避免","zIndex":23},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"41754dff-f98b-4b9e-a042-c6ef9448e6ff","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ceff10a3-3e69-415f-8791-0d85192527f7","children":[],"html":"浏览器针对页面的回流与重绘，进行了自身的优化，就是渲染队列。","zIndex":2},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"ab6119b2-1b1d-4754-9d2b-53a11fc43069","children":[],"html":"浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。","zIndex":3},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a924a5fc-7104-48fa-a16f-229cb2f847d1","children":[],"html":"上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。","zIndex":1}],"html":"渲染Flush队列","zIndex":4}],"html":"回流和重绘","zIndex":24}],"html":"浏览器渲染原理","layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"zIndex":52},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1],"quadrant":1},"treeEdge":{"stroke":"#6EC4C4"},"defaultContentStyle":{"color":"#262626"},"id":"b199af2b-c70a-4c79-9898-0e6e90f1599e","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"bbaab57d-b3d7-431c-93d1-691f7af90a90","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4780d43f-6e91-40b9-acdc-50497e250d7b","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a6d37351-b4da-48bc-8df9-4be360f649b3","children":[],"html":"当用户在浏览器中输入网址或点击链接访问一个网页时，浏览器首先会检查该网页的缓存情况。它会根据请求的资源的 URL，查找是否存在对应的缓存。","zIndex":77}],"html":"检查缓存","zIndex":76},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c5e75f54-6fd1-4e8a-9770-9e52e7253d1f","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8a3c9c2d-138e-4c1b-aba0-7a21ef4d8ad9","children":[],"html":"如果检查到请求的资源已经存在于缓存中，并且缓存有效（未过期），则浏览器会直接从缓存中加载资源，而不发送请求到服务器。","zIndex":79}],"html":"缓存命中","zIndex":78},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2d982bcb-4648-4bb3-80e1-688ac0a16f42","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"16e8ad82-92c5-48da-9c0a-98bf03a6a54e","children":[],"html":"如果请求的资源不在缓存中，或者缓存已经失效，浏览器会发送请求到服务器请求资源。同时，请求中会包含一些头部信息，如 If-Modified-Since、If-None-Match等，用于与服务器进行缓存验证。","zIndex":81}],"html":"缓存未命中","zIndex":80},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2c6f66e0-63b8-4b1a-92a6-ba0323d4490e","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f47e6a08-1174-4a36-b0f9-519d0eeaab39","children":[],"html":"服务器收到浏览器发送的请求后，会根据请求头部中的信息判断资源是否发生了变化。如果资源未发生变化，服务器会返回 304 Not Modified 状态码，并且响应中不包含实际的资源内容，浏览器将继续使用缓存中的资源。如果资源已经发生变化，服务器会返回新的资源内容和相应的缓存控制头部信息。","zIndex":83}],"html":"服务器响应","zIndex":82},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"eb062ef2-177d-4bf6-95bc-9a3f1e39c137","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c3c9381e-e22d-4e69-8f3c-017c758c06db","children":[],"html":"如果服务器返回的资源是新的或已经修改过的，浏览器会根据服务器返回的缓存控制信息更新缓存。这可能包括更新缓存的有效期，或者根据新的内容生成新的缓存标识符（如 ETag）。","zIndex":85}],"html":"更新缓存","zIndex":84},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c863f314-d69f-49dd-9432-b530e853a0ea","children":[],"html":"资源加载","zIndex":86}],"html":"缓存过程","collapsed":true,"zIndex":64},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f0fbec21-806f-4e67-9489-177441dc8a09","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cec02d44-c721-4ab2-8f18-bce466ecfa9c","children":[],"html":"资源缓存的位置一共有 3 种，按优先级从高到低分别是","zIndex":87},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"11489ce8-bb2e-44fa-aa13-8d95ee7202ff","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"11a685b2-c254-4cb2-9fb2-cf782d1e27fe","children":[],"html":"Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。","zIndex":89}],"html":"1. Service Worker","zIndex":88},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2fa12232-9033-40d5-a602-55306127fc6e","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"06b69032-c2dd-4e13-be9b-1933711242c8","children":[],"html":"Memory Cache 就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。","zIndex":91}],"html":"2. Memory Cache","zIndex":90},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ffd2226d-9463-475e-adb3-829369205087","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"35b68692-21ba-4b17-9fb5-6d8cef46a659","children":[],"html":"Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。","zIndex":93}],"html":"3. Disk Cache","zIndex":92}],"html":"缓存位置","collapsed":true,"zIndex":66},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d7bf016f-1a12-41f2-8bf6-b9388c1ad95b","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"11c84e10-c870-4931-900d-6e1f56c7cd54","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"d9570e41-a35b-44de-b5c8-5706680d2924","children":[],"html":"强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。","zIndex":95},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9b93147e-b917-477b-814e-8b99205e39ef","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3c479a93-21c1-4c01-9457-07c819735a47","children":[],"html":"服务器通过在<span style=\"font-weight:bold;\">响应头</span>中添加 Expires 属性，来指定资源的过期时间。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。","zIndex":97}],"html":"Expires (http1.0)","zIndex":96},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6d0e3875-a2ed-4709-8f98-db0c1778addb","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f884f540-8475-419d-a999-e91220512e0d","children":[],"html":"可以通过max-age设置一个相对的过期时间","zIndex":99}],"html":"Cache-Control (http1.1)","zIndex":98}],"html":"强缓存","zIndex":94},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f324a984-7a67-4f54-8024-98a25d56852e","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e73e8bea-ec1d-4e8c-8c90-d42b11da7a5d","children":[],"html":"使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。","zIndex":101},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ec687266-7227-41be-9cd8-f19af64d6d86","children":[],"html":"协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。","zIndex":102},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6f833d4d-72e1-45f7-9646-fbf11fbe6c83","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cbc35754-1ed0-4979-ac81-965ff1dd8d87","children":[],"html":"cache-control的max-age过期了，没有设置no-store","zIndex":104}],"layout":{"quadrant":1},"html":"命中协商缓存的条件","zIndex":103},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d56a9264-a8a0-4147-8f76-98b87e405e35","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"be30cee7-805e-4fc6-a9f3-a97d761f7cf2","children":[],"html":"服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。","zIndex":106},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"aa2a064f-7693-4e02-a3d6-a7187051d8da","children":[],"html":"缺点：Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。","zIndex":107}],"html":"Last-Modified ","zIndex":105},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"aa216c59-78aa-4310-bfb4-478462a9788b","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0527ed05-e23f-4fb4-a6b3-953061ae01f9","children":[],"html":"服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。","zIndex":109},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ac0cf835-775b-4943-bb68-1da4137df64a","children":[],"html":"Etag优先级更高","zIndex":110},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ab6becf3-7973-4422-a187-a90ed8480d82","children":[],"html":"使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。","zIndex":111}],"html":"Etag","zIndex":108}],"html":"协商缓存","zIndex":100}],"html":"缓存类型","collapsed":true,"zIndex":65},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a4cc393c-4da4-4a8d-bc05-b1c01b63cc02","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"83701088-e8c3-4b76-94c1-8517bca18e57","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3629af73-e023-4cb6-8fd3-fb196fd85a18","children":[],"html":"浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。","zIndex":113}],"html":"点击刷新按钮或者按 F5","zIndex":112},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8a144056-1f03-4f14-b611-bbf03e6c02fd","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"192048af-38e9-4d45-abf3-c0bd3c2debaa","children":[],"html":"浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。","zIndex":115}],"html":"用户按 Ctrl+F5（强制刷新）","zIndex":114},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"44ac571a-95e3-4d6c-927d-af80a29d1739","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9a754879-ebf2-4c70-bcce-2e8b20022cbc","children":[],"html":"浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。","zIndex":117}],"html":"地址栏回车","zIndex":116}],"html":"浏览器刷新","collapsed":true,"zIndex":63}],"html":"浏览器缓存","zIndex":67},{"treeEdge":{"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"6a8bad09-2cee-41d1-ad06-e2012af3cc5f","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e10915cb-a903-4409-a93a-2f81a756cc3f","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"154c8129-3a31-477b-bf1e-083eb8bf5372","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a7ec5a88-7d91-4fe9-8cd9-9189c4d658f5","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4be1bfa3-37c8-4b9c-b2ec-68b5d4edd94d","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f0ba2713-53e9-4660-b6ff-8e09ea20d468","children":[],"html":"1. 使用Nginx反向代理","zIndex":122},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c40f7706-875c-4578-98ff-fa1b21dcdad5","children":[],"html":"2. 在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId","zIndex":123}],"html":"如何实现跨域名共享","zIndex":121}],"html":"无法跨域","zIndex":120},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ee6978d5-78fe-49d6-94d6-24537091d7a4","children":[],"html":"每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb","zIndex":124},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e64d13be-f26c-429d-b98e-45c50d1de487","children":[],"html":"有安全问题，如果Cookie被拦截了，那就可获得session的所有信息","zIndex":125},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1e5320b4-228b-4c71-88e4-19d9091cc6ee","children":[],"html":"cookie会随HTTP请求一起发送","zIndex":126},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d3bf99a0-c4ed-4d89-b894-d992946b6b5b","children":[],"html":"一般由服务端设置，客户端存储","zIndex":127}],"html":"特点","zIndex":119},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a5722e70-4ed5-43d2-85ba-71b2164a838c","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"93d79843-a948-4882-99d0-0794152e7740","children":[],"html":"最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。","zIndex":129},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b07d9e7c-d441-41a3-b564-09df11fbefa9","children":[],"html":"可以用来统计页面的点击次数","zIndex":130}],"html":"使用场景","zIndex":128},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4266a6b4-2a3d-4c52-b9df-596464f934dc","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"489cacfe-325e-428f-9b56-29d6b7ee7481","children":[],"html":"服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。","zIndex":132},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"eb08a6fc-f36c-4530-93ec-a87d0af590b5","children":[],"html":"其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。","zIndex":133},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c5ab0e40-8644-4358-91e1-ee9656a024ae","children":[],"html":"secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。","zIndex":134}],"html":"字段","zIndex":131}],"html":"cookie","zIndex":118},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f68345b2-d3c3-4be8-add8-314037e6ce3c","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6295d672-6b88-478d-aa33-95b7c1c58358","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7985a1d7-d8bb-4103-82cd-3678e8f336cc","children":[],"html":"存储大小为5MB","zIndex":137},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"bd9a7537-ee06-4ae1-a710-968fd246e510","children":[],"html":"LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在","zIndex":138},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f7b12017-920e-4c9c-b9d1-b512f74c9f3f","children":[],"html":"仅储存在本地，不像Cookie那样每次HTTP请求都会被携带","zIndex":139},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7f0bc5c9-6aa3-4043-9da5-e055e890d6f8","children":[],"html":"如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage","zIndex":140},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7f7a6b40-9f31-479d-92bf-1b8a958f1996","children":[],"html":"受同源策略的限制","zIndex":141}],"html":"特点","zIndex":136},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d33ee3f7-a31d-4550-984f-7b5be1f876d5","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ed9f8e74-e4bc-4999-abf4-9cc16c34459b","children":[],"html":"换肤","zIndex":143},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ce8f381a-2b97-40f5-a86e-db802d74dc0e","children":[],"html":"登录 token","zIndex":144}],"html":"使用场景","zIndex":142}],"html":"localstorage","collapsed":true,"zIndex":135},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"aefbf21c-08a7-473a-88e9-f5345dc8b0e8","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b0c095ef-d9f3-4897-a259-e08fc939844c","children":[],"html":"SessionStorage代表一次会话中保存的数据。只有在同一浏览器的同一窗口下才能够共享，关闭窗口则数据清空","zIndex":146}],"html":"sessionstorage","collapsed":true,"zIndex":145},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5b301484-db1d-486d-8603-2cab0f408aac","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"22d879b4-32ff-459d-96cb-1fb4478e3240","children":[],"html":"是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，适合web场景","zIndex":148},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"49607064-e5d8-4313-be3a-e2ed60188079","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a2477035-5df4-4303-8261-5eeeec0098eb","children":[],"html":"键值对储存","zIndex":150},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"724ed1d3-49ae-4419-bfc4-ec045dce61d0","children":[],"html":"异步","zIndex":151},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7cc426b3-4581-4395-b98c-08088b79fec1","children":[],"html":"支持事务","zIndex":152},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1881f057-2bc7-4ce2-808a-f3787d28429d","children":[],"html":"同源限制","zIndex":153},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a7b52e29-000a-413a-a64d-48bdfa3c6143","children":[],"html":"储存空间大：不少于250MB，甚至没有上限","zIndex":154},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4551cdb0-9b3c-49c5-af6e-b62bf73b1852","children":[],"html":"支持二进制储存","zIndex":155}],"html":"特点","zIndex":149}],"html":"indexDB","collapsed":true,"zIndex":147}],"layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"html":"浏览器存储","collapsed":true,"zIndex":62},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#DFB85D"},"defaultContentStyle":{"color":"#262626"},"id":"4d96c0b5-7c97-40b6-8d1f-d1c7360e18f0","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1871e366-a356-4fd7-b962-8a3ed550f72a","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"804bca6f-4ae3-4660-9ff0-ca13edcaaea3","children":[],"html":"浏览器的安全机制，限制协议、端口号、域名需要一致","zIndex":156},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"47969d9e-635b-46f7-9800-c1d2a706b35c","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"569e7931-745a-40b1-9955-6e80a077d4ef","children":[],"html":"当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB","zIndex":158},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c6992163-73cd-4722-924e-820abdbf04fc","children":[],"html":"当前域下的 js 脚本不能够操作访问操作其他域下的 DOM","zIndex":159},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d936c12c-0cf7-4cdd-836a-2bb5c5d9fe4c","children":[],"html":"当前域下 ajax 无法发送跨域请求","zIndex":160}],"html":"限制了三个方面","zIndex":157},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9fd548d9-4225-4997-853c-34224cd7f22e","children":[],"html":"img和script标签不受同源策略的限制，可以实现跨域","zIndex":161}],"html":"同源策略","collapsed":true,"zIndex":59},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"99c11b42-c336-469d-8f89-17d3d434ae8e","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1acaf7d0-a14a-4471-9ae6-7d4a05be288f","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"d86004e1-ffb7-4914-8fd6-f7520eda5861","children":[],"html":"CORS是通过额外的HTTP请求头告诉浏览器是否允许web应用访问不通源服务器上的资源：Access-Control-Allow-Origin","zIndex":163},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"10981f9d-028a-4c5f-ab54-38a4a066a54a","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b2a725b6-39f7-4ace-ab0b-7d7c001c1761","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"abfbc0f4-5238-4679-8f36-508af62388aa","children":[],"html":"非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为预检请求。","zIndex":166}],"html":"概念","zIndex":165},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"a1154051-51aa-4f23-944c-5fdb961b1db3","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"daf5139f-ab9b-4a7a-b9a1-9a77f1529300","children":[],"html":"浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。","zIndex":168}],"html":"作用","zIndex":167},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"86f6960f-ca1b-489d-a24d-265b519fc799","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c324da03-b3b3-417d-9ee6-85449e910f28","children":[],"html":"请求方法：HEAD、GET、POST 三者之一","zIndex":170},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8f62be6e-2c5f-4347-84d6-04cab42c1f66","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"045a9240-b0e8-4f52-8aa7-8e0b2c003951","children":[],"html":"Accept","zIndex":172},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e032d954-850e-444d-be6e-8ceb627db65f","children":[],"html":"Accept-Language","zIndex":173},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e6e09ba7-4bae-456a-90e6-04457423b391","children":[],"html":"Content-Language","zIndex":174},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"94f4a1df-48ba-436f-a7e0-2dda1e05fa16","children":[],"html":"Last-Event-ID","zIndex":175},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e8343b9c-dee7-4798-80f8-a043a2e50405","children":[],"html":"Content-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain","zIndex":176}],"html":"HTTP的头信息不超出以下几种字段","zIndex":171}],"html":"简单请求","zIndex":169},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a0912828-e929-4af5-b8b5-b8d21628b7be","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"50b6dd3b-30d1-4cb9-9cc9-d843a4ef86b3","children":[],"html":"方法：OPTIONS","zIndex":178},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"de98504a-9b3e-457c-bd54-4109c200435d","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f2c7d295-8238-41ea-974c-298728eb8ce6","children":[],"html":"Access-Control-Allow-Origin","zIndex":180},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"8db3725d-b146-4525-828d-ba84bc837676","children":[],"html":"Access-Control-Request-Method","zIndex":181},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"7e65789d-aa00-40ab-ab90-5980702959d1","children":[],"html":"Access-Control-Request-Headers","zIndex":182}],"html":"头信息必须设置字段","zIndex":179}],"html":"预检请求","zIndex":177},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"33ea8290-9292-49bf-b6ff-cd7223e5365b","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"99a223f6-9808-401f-8e93-9f589f5cd1ed","children":[],"html":"可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。","zIndex":184},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"09740326-4c60-4755-a9dc-49f5d0f7b64d","children":[],"html":"该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。","zIndex":185}],"html":"减少OPTIONS请求次数","zIndex":183}],"html":"预检请求","zIndex":164},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"66ea2bc5-849d-48e5-820e-2fc7f08db81b","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"72a095ce-e674-42fc-91e1-c0ce1b57abd0","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2cbe8273-215d-4720-afea-a2f781862ff7","children":[],"html":"1. 客户端在请求中设置 withCredentials 为true","zIndex":188},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"99232f7d-6437-421f-a58f-bc86e4b5daee","children":[],"html":"2. 服务端设置<span style=\"font-weight:bold;\">响应头</span>：Access-Control-Allow-Credentials 设置为 true","zIndex":189},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9fb898af-dd3b-4c3c-9e25-09b623934f21","children":[],"html":"3. Access-Control-Allow-Origin 设置为非 *","zIndex":190}],"html":"满足三个条件","zIndex":187}],"html":"CORS如何传递cookie","zIndex":186}],"html":"跨域资源共享CORS","zIndex":162},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"388613a9-b0f8-424a-bdc9-cb3b40c912e3","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f526e11d-6923-487f-9c8c-2d76c36cbaad","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cd803f64-104f-4b47-8e54-457ea2da785d","children":[],"html":"利用&lt;script&gt;标签没有跨域限制，通过&lt;script&gt;标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。","zIndex":193}],"html":"原理","zIndex":192},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"605a3698-c95f-468d-948b-fb97e90d8bc6","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4c06cc45-58f3-4f9e-8221-9e1dc9096fe4","children":[],"html":"具有局限性， 仅支持get方法","zIndex":195},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"afcf53e7-a693-458e-b098-6f045192116e","children":[],"html":"不安全，可能遭受XSS攻击","zIndex":196}],"html":"缺点","zIndex":194}],"html":"JSONP","collapsed":true,"zIndex":191},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1c93f51c-3a34-40f9-8c9a-7f308376a730","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"2fc6b393-4fbe-4496-98a4-30bbe37252bb","children":[],"html":"HTML5提供的一个API，可以跨域操作window","zIndex":198},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"27aba7b7-e660-4a21-b784-4d1e74295d55","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1972f026-9c40-4a83-867b-4174c907c51f","children":[],"html":"页面和其打开的新窗口的数据传递","zIndex":200},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b1dded08-60dc-4105-80d4-8249c6b1a192","children":[],"html":"多窗口之间消息传递","zIndex":201},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ebadc51b-1363-4670-abaa-d901f55720f3","children":[],"html":"页面与嵌套的iframe消息传递","zIndex":202},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3a2fc4dc-1649-4dd2-b0e7-ee5a66f0868e","children":[],"html":"上面三个场景的跨域数据传递","zIndex":203}],"html":"解决问题","zIndex":199},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ba4af37a-3902-4d37-adf0-682dd559b698","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e1bf820e-8339-416c-99d7-ca50fccc2ef7","children":[],"html":"postMessage(data,origin)","zIndex":205},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4c37fc50-2061-48c5-97a8-036ac925ad2e","children":[],"html":"origin：协议+主机+端口号，也可以设置为\"*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。","zIndex":206}],"html":"用法","zIndex":204}],"html":"postMessage","collapsed":true,"zIndex":197},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2a4ad11e-bca2-4200-ad75-24d0de3f00de","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"89de25c1-9426-49bb-9eae-513fe98b166c","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4a667f04-7483-4c6f-89b2-c7e64fb65f83","children":[],"html":"location / {<div>&nbsp; add_header Access-Control-Allow-Origin *;</div><div>}</div>","zIndex":209}],"html":"nginx配置解决iconfont跨域","zIndex":208},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"14a267fd-c6ff-4c6d-9478-167eb71a6a12","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"70c818d0-6858-4363-9611-d5d5797e5949","children":[],"html":"实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。","zIndex":211},{"border":{"shape":"rect","stroke":"#dfb85d","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"44398824-b6ed-48fa-bb33-b648514f87ab","children":[],"html":"#proxy服务器<div>server {</div><div>&nbsp; &nbsp; listen       81;</div><div>&nbsp; &nbsp; server_name  www.domain1.com;</div><div>&nbsp; &nbsp; location / {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; proxy_pass   http://www.domain2.com:8080;  #反向代理</div><div>&nbsp; &nbsp; &nbsp; &nbsp; proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; index  index.html index.htm;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</div><div>&nbsp; &nbsp; &nbsp; &nbsp; add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</div><div>&nbsp; &nbsp; &nbsp; &nbsp; add_header Access-Control-Allow-Credentials true;</div><div>&nbsp; &nbsp; }</div><div>}</div>","height":343.3151817184221,"width":843.5351451957695,"zIndex":212}],"html":"nginx反向代理接口跨域","zIndex":210}],"html":"Nginx 代理","collapsed":true,"zIndex":207},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9780ddb1-4074-4571-b45c-d6282f122eb8","children":[],"html":"node 中间件代理","zIndex":213},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f320492a-5408-4b6a-a5fd-5dbe5c274ca2","children":[],"html":"Websocket协议跨域","zIndex":214}],"html":"跨域方式","collapsed":true,"zIndex":60},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6a8e327d-d2b3-4e8f-a523-f8d6317fe7cd","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6e3891d4-bbe4-4b3e-a5f5-ecb27989a072","children":[],"html":"正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。","zIndex":215},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"65d80fb5-5192-4ff5-95bf-75ae4a0dfed0","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"08a4e84a-84d1-4972-95a5-a6f74f01ea21","children":[],"html":"翻墙软件","zIndex":217},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e2d395b6-dba9-49bf-8009-27049f6a088e","children":[],"html":"匿名访问","zIndex":218}],"html":"在正向代理中，proxy 是 client 设置的，用来隐藏 client","zIndex":216},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"f1f24105-1c21-4ade-8756-2f5af17422b8","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"aee8fdec-a802-4cf8-96df-98e1185d1f46","children":[],"html":"CDN","zIndex":220},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a5fdd016-ab18-4afb-8472-10ef718aa07d","children":[],"html":"负载均衡集群","zIndex":221}],"html":"而在反向代理中，proxy 是 server 设置的，用来隐藏 server","zIndex":219}],"html":"正向代理和反向代理的区别","collapsed":true,"zIndex":58}],"html":"同源与跨域","layout":{"quadrant":1},"zIndex":61},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"868c0c70-f90d-4d5a-bbe0-0a97682afebd","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"aeb4c0a6-ac71-41c4-abb4-32c51c9f13ba","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b96b376f-13f5-40ae-80b0-0745de77890a","children":[],"html":"跨站点脚本攻击，攻击者注入恶意脚本，并且在用户的浏览器上运行，从而窃取用户信息","zIndex":223},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"981a2ab5-4a0c-4044-990c-2ffc87f05ed0","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e6742463-42ed-492a-a8fb-b376cdf9d91c","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"78d7bf5a-022e-4ed9-93d3-7d66e7ad7256","children":[],"html":"攻击者通过表单或者评论将恶意脚本提交给服务器，存储到数据库中，用户访问页面时，脚本从服务器传回并执行","zIndex":226},{"start":0,"end":0,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"恶意代码存储在数据库里","defaultContentStyle":{"color":"#262626"},"id":"d4b1253b-5611-4b0a-ba12-fb6f13274694","children":[],"zIndex":227}],"html":"存储型","zIndex":225},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"cc538e07-5140-4097-a477-7edbb9f04eac","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"3b41e3c4-69e1-4705-9915-d7da542d7c4b","children":[],"html":"1. 攻击者构造出特殊的URL，包含恶意代码","zIndex":229},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0d5d5f9c-2001-4743-9036-b64c58e15d65","children":[],"html":"2. 用户打开这个URL，服务端将恶意代码从URL中取出，返回给浏览器","zIndex":230},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"ed607393-bc29-49f3-833b-42e856db346f","children":[],"html":"3. 用户浏览器接受响应并执行了混入其中的恶意代码","zIndex":231},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c5d114fd-a3c3-45e1-a765-733cfcb261a9","children":[],"html":"4. 攻击者通过恶意代码实现窃取用户数据，或者冒充用户执行攻击操作","zIndex":232},{"start":1,"end":3,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"恶意代码存储在URL里","defaultContentStyle":{"color":"#262626"},"id":"0b4494af-3c4c-4b18-a0fb-f0f7e8b913a7","children":[],"zIndex":233}],"html":"反射性","zIndex":228},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a840c86a-92bc-487b-a320-e4448a9a4636","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b74ae8ca-85af-4738-922b-ff0a5ebcff96","children":[],"html":"用户打开攻击者构造的包含恶意代码的URL，直接在浏览器端执行","zIndex":235}],"html":"DOM型","zIndex":234}],"html":"分类","zIndex":224},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c848abf1-2128-422c-9f2e-1eb7a5e40c79","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"6d9ecefa-a047-4c1b-b7b5-beddff835063","children":[],"html":"转义：对于需要插入到HTML中的代码，或者需要提交到服务端的用户输入内容做好转义","zIndex":237},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"de6ec580-0b8d-4a98-b3e3-f7b5922bd6db","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"2092c034-b1a4-48eb-af32-8e46bffa9a27","children":[],"html":"CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。","zIndex":239},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0c40f19a-ab34-4994-888a-8674157d67bf","children":[],"html":"通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 &lt;meta http-equiv=\"Content-Security-Policy\"&gt;","zIndex":240}],"html":"CSP：内容安全策略","zIndex":238},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9ccbd843-e927-47f8-82a0-1e452d405c93","children":[],"html":"对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。","zIndex":241}],"html":"防御","zIndex":236}],"html":"XSS","zIndex":222},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"531d8d95-c996-4835-8fac-13b42550ad0a","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e9c461a4-f8d0-487e-bd68-222a54fe3474","children":[],"html":"跨站点请求伪造，本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充","zIndex":243},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e7d6166d-98ee-4f6d-bf54-ffbc3f60625f","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"72e14a19-9a14-4347-8e6e-e1695220f545","children":[],"html":"GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。","zIndex":245},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"1e770bb5-8b69-4696-bf50-46322c21cdc3","children":[],"html":"POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。","zIndex":246},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0113f242-25ce-49d4-ae13-9c4dffb957dd","children":[],"html":"链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。","zIndex":247}],"html":"攻击方式","zIndex":244},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"a50b80d2-6fab-47b5-8aa8-978675bb4d59","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"675c75b2-ba36-48e4-86db-69def9e8b8cf","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"b1184204-9305-402a-9a89-38b862fd311a","children":[],"html":"服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。","zIndex":250},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"0ff00618-d350-45ad-8a38-22b747f13fb2","children":[],"html":"这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。","zIndex":251}],"html":"同源检测","zIndex":249},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5bc88342-297a-45fa-9e35-69ce4714a58b","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"4c1da801-cdaa-4be9-b59d-f9683cc9b030","children":[],"html":"服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。","zIndex":253},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"c429630f-36a1-4ddd-8174-87ef48ca8546","children":[],"html":"缺点就是，我们需要给网站中的所有请求都添加上这个 token","zIndex":254}],"html":"CSRF Token 进行验证","zIndex":252},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"17f030ef-5f63-4a8f-8115-6b216c39c0fa","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"5e2769f9-6401-4cff-91cb-bd4a5885d206","children":[],"html":"服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。","zIndex":256},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"9a0b3443-1a3f-4daa-afa1-563e44f84434","children":[],"html":"这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。","zIndex":257}],"html":"对 Cookie 进行双重验证","zIndex":255},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"36585e11-f472-4658-816c-8e145a7ed2b3","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"defaultContentStyle":{"color":"#262626"},"id":"e5254a0f-fff9-4953-87b3-afab25044f64","children":[],"html":"Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。","zIndex":259}],"html":"cookie 属性设置为 Samesite","zIndex":258}],"html":"防御","zIndex":248}],"html":"CSRF","zIndex":242}],"layout":{"quadrant":1},"html":"XSS和CSRF","collapsed":true,"zIndex":57},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"6165642e-b616-4fb8-a057-2231152fcaa8","children":[],"html":"requestAnimation 和 requestIdleCallback","layout":{"quadrant":1},"zIndex":56},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"52aa64fe-6600-4565-951c-e740aa6c17b4","children":[],"html":"垃圾回收机制","zIndex":55},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#E48484"},"defaultContentStyle":{"color":"#262626"},"id":"aa8361cf-80c8-4a32-9c77-ef9b5f77716f","children":[],"html":"事件机制","layout":{"quadrant":1},"zIndex":54},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#77C386"},"defaultContentStyle":{"color":"#262626"},"id":"595336cb-a383-411f-8155-5257738b91d9","children":[],"html":"浏览器组成","layout":{"quadrant":1},"zIndex":53},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke":"#69B1E4"},"defaultContentStyle":{"color":"#262626"},"id":"f9931cde-351e-4bd3-8e36-f2bb161d3d4e","children":[],"html":"进程和线程","zIndex":0}],"layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"zIndex":68}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[7.5,2219.5,1],"width":1601,"height":949},"viewportOption":"adapt","text":"浏览器浏览器渲染原理渲染过程首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。然后对 CSS 进行解析，生成 CSSOM 规则树。根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。注意：这个过程是逐步完成的，为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。渲染优化网络加载优化资源合并和压缩，减少HTTP请求次数和文件大小利用浏览器缓存，包括HTTP缓存、资源预加载等使用CDN加速资源加载CDN 可以通过地理位置优化、负载均衡、缓存优化、连接复用以及抗攻击能力等多种方式，加速静态资源的加载，提升网站的性能和用户体验HTML解析优化减少DOM元素数量，避免嵌套过审的结构使用语义化标签，帮助浏览器更快理解文档结构尽量将script标签放在body最后，或者用async或者defer的方式引入scriptasync：下载JS是异步，下载完成会立即执行，会阻塞渲染defer：下载是异步的，会等DOM树构建完毕，并且在DOMContentLoaded 事件触发之前执行CSS渲染优化避免使用过多的样式规则和选择器，减少CSS文件大小使用简单的 CSS 动画而不是使用 JavaScript 实现动画，以利用浏览器的硬件加速功能布局(回流/重排)、绘制(重绘)优化避免频繁操作样式，最好一次性修改多个样式尽量减少不必要的元素重绘，例如使用transform属性而不是修改top和left属性来移动元素使用CSS3动画或变换来减少重绘和回流GPU加速：大部分浏览器使用GPU加速CSS3动画。GPU 通常能够处理图形任务更快，因此将动画委托给 GPU 处理可以提高动画的性能，减少 CPU 的负载。相比之下，JavaScript 动画通常由 CPU 处理，性能可能不如 GPU 加速的 CSS3 动画。硬件加速的转换和动画：CSS3 动画可以应用于 CSS 属性，如 transform 和 opacity，这些属性可以通过硬件加速进行处理，而不需要触发重绘或回流。例如，使用 transform 属性进行动画时，浏览器可以在 GPU 上执行动画转换，而不会影响文档流，从而减少了重绘和回流。优化的动画循环：浏览器能够优化 CSS3 动画的执行方式。例如，浏览器可以根据屏幕刷新率进行动画绘制，以确保动画流畅且不会引起撕裂或闪烁。合成优化利用 GPU 加速，将合成和绘制操作委托给 GPU怎么实现：利用 CSS3 属性、3D 变换、will-change 属性以及避免触发重绘和回流等方法，可以有效地利用 GPU 加速，将合成和绘制操作委托给 GPU，从而提高页面的性能和流畅度使用 CSS 属性 will-change 来提示浏览器元素将要被修改，以便浏览器在后台优化渲染。回流和重绘回流渲染树中部分或全部元素的尺寸、结构或者属性发生变化时，浏览器全部或部分重新渲染文档的过程，就是回流导致回流的操作页面首次渲染浏览器窗口大小变化页面内容、字体大小、激活伪类查询元素的宽高添加或删除可见DOM元素重绘样式变化，但是不影响元素在文档流中的位置时，浏览器就会对元素进行重绘color、background、border-radius、visibility、opaticy如何避免操作DOM时，尽量在低层级的DOM节点进行操作不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。不要使用table布局， 一个小的改动可能会使整个table进行重新布局使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素避免频繁操作DOM，可以创建一个文档片段documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中Dom离线化：将元素先设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于浏览器的渲染队列机制。渲染Flush队列浏览器针对页面的回流与重绘，进行了自身的优化，就是渲染队列。浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。浏览器缓存缓存过程检查缓存当用户在浏览器中输入网址或点击链接访问一个网页时，浏览器首先会检查该网页的缓存情况。它会根据请求的资源的 URL，查找是否存在对应的缓存。缓存命中如果检查到请求的资源已经存在于缓存中，并且缓存有效（未过期），则浏览器会直接从缓存中加载资源，而不发送请求到服务器。缓存未命中如果请求的资源不在缓存中，或者缓存已经失效，浏览器会发送请求到服务器请求资源。同时，请求中会包含一些头部信息，如 If-Modified-Since、If-None-Match等，用于与服务器进行缓存验证。服务器响应服务器收到浏览器发送的请求后，会根据请求头部中的信息判断资源是否发生了变化。如果资源未发生变化，服务器会返回 304 Not Modified 状态码，并且响应中不包含实际的资源内容，浏览器将继续使用缓存中的资源。如果资源已经发生变化，服务器会返回新的资源内容和相应的缓存控制头部信息。更新缓存如果服务器返回的资源是新的或已经修改过的，浏览器会根据服务器返回的缓存控制信息更新缓存。这可能包括更新缓存的有效期，或者根据新的内容生成新的缓存标识符（如 ETag）。资源加载缓存位置资源缓存的位置一共有 3 种，按优先级从高到低分别是1. Service WorkerService Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。2. Memory CacheMemory Cache 就是内存缓存，它的效率最快，但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。3. Disk CacheDisk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。缓存类型强缓存强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。Expires (http1.0)服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。Cache-Control (http1.1)可以通过max-age设置一个相对的过期时间协商缓存使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 Etag 和 Last-Modified 属性。命中协商缓存的条件cache-control的max-age过期了，没有设置no-storeLast-Modified 服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。缺点：Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。Etag服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。Etag优先级更高使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。浏览器刷新点击刷新按钮或者按 F5浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。用户按 Ctrl+F5（强制刷新）浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。地址栏回车浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。浏览器存储cookie特点无法跨域如何实现跨域名共享1. 使用Nginx反向代理2. 在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb有安全问题，如果Cookie被拦截了，那就可获得session的所有信息cookie会随HTTP请求一起发送一般由服务端设置，客户端存储使用场景最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。可以用来统计页面的点击次数字段服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。localstorage特点存储大小为5MBLocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在仅储存在本地，不像Cookie那样每次HTTP请求都会被携带如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage受同源策略的限制使用场景换肤登录 tokensessionstorageSessionStorage代表一次会话中保存的数据。只有在同一浏览器的同一窗口下才能够共享，关闭窗口则数据清空indexDB是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，适合web场景特点键值对储存异步支持事务同源限制储存空间大：不少于250MB，甚至没有上限支持二进制储存同源与跨域同源策略浏览器的安全机制，限制协议、端口号、域名需要一致限制了三个方面当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB当前域下的 js 脚本不能够操作访问操作其他域下的 DOM当前域下 ajax 无法发送跨域请求img和script标签不受同源策略的限制，可以实现跨域跨域方式跨域资源共享CORSCORS是通过额外的HTTP请求头告诉浏览器是否允许web应用访问不通源服务器上的资源：Access-Control-Allow-Origin预检请求概念非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，称为预检请求。作用浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。简单请求请求方法：HEAD、GET、POST 三者之一HTTP的头信息不超出以下几种字段AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain预检请求方法：OPTIONS头信息必须设置字段Access-Control-Allow-OriginAccess-Control-Request-MethodAccess-Control-Request-Headers减少OPTIONS请求次数可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。CORS如何传递cookie满足三个条件1. 客户端在请求中设置 withCredentials 为true2. 服务端设置响应头：Access-Control-Allow-Credentials 设置为 true3. Access-Control-Allow-Origin 设置为非 *JSONP原理利用<script>标签没有跨域限制，通过<script>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。缺点具有局限性， 仅支持get方法不安全，可能遭受XSS攻击postMessageHTML5提供的一个API，可以跨域操作window解决问题页面和其打开的新窗口的数据传递多窗口之间消息传递页面与嵌套的iframe消息传递上面三个场景的跨域数据传递用法postMessage(data,origin)origin：协议+主机+端口号，也可以设置为\"*\"，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为\"/\"。Nginx 代理nginx配置解决iconfont跨域location / {  add_header Access-Control-Allow-Origin *;}nginx反向代理接口跨域实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。#proxy服务器server {    listen       81;    server_name  www.domain1.com;    location / {        proxy_pass   http://www.domain2.com:8080;  #反向代理        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名        index  index.html index.htm;        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*        add_header Access-Control-Allow-Credentials true;    }}node 中间件代理Websocket协议跨域正向代理和反向代理的区别正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client翻墙软件匿名访问而在反向代理中，proxy 是 server 设置的，用来隐藏 serverCDN负载均衡集群XSS和CSRFXSS跨站点脚本攻击，攻击者注入恶意脚本，并且在用户的浏览器上运行，从而窃取用户信息分类存储型攻击者通过表单或者评论将恶意脚本提交给服务器，存储到数据库中，用户访问页面时，脚本从服务器传回并执行恶意代码存储在数据库里反射性1. 攻击者构造出特殊的URL，包含恶意代码2. 用户打开这个URL，服务端将恶意代码从URL中取出，返回给浏览器3. 用户浏览器接受响应并执行了混入其中的恶意代码4. 攻击者通过恶意代码实现窃取用户数据，或者冒充用户执行攻击操作恶意代码存储在URL里DOM型用户打开攻击者构造的包含恶意代码的URL，直接在浏览器端执行防御转义：对于需要插入到HTML中的代码，或者需要提交到服务端的用户输入内容做好转义CSP：内容安全策略CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <meta http-equiv=\"Content-Security-Policy\">对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。CSRF跨站点请求伪造，本质是利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充攻击方式GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。防御同源检测服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。CSRF Token 进行验证服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。缺点就是，我们需要给网站中的所有请求都添加上这个 token对 Cookie 进行双重验证服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。cookie 属性设置为 SamesiteSamesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。requestAnimation 和 requestIdleCallback垃圾回收机制事件机制浏览器组成进程和线程","graphicsBBox":{"x":575,"y":350,"width":1628,"height":3213}}