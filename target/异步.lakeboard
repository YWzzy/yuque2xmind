{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"id":"4c6a2dd1-fbaa-4a87-aa7d-bb62b9785b6e","x":633,"y":1765.875,"html":"异步","type":"mindmap","defaultContentStyle":{"color":"rgb(38, 38, 38)"},"border":{"fill":"#F5F5F5","shape":"rect","stroke":"transparent","stroke-width":2},"children":[{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#FCF6E1","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"id":"76d52afa-a197-474a-921f-3d9dbaa211c1","children":[{"border":{"shape":"rect","fill":"#f9f1df","stroke-width":2,"stroke":"rgba(0, 0, 0, 0)"},"id":"6b6723d8-72bc-4e75-93e2-9761b4db7224","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)","fill":"#f9f1df","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ef072834-7e41-4a52-ac7f-304f939ac177","children":[],"html":"JS是单线程语言，同步会阻塞代码执行，异步不会","zIndex":21}],"html":"同步和异步","zIndex":22},{"border":{"shape":"rect","fill":"#f9f1df","stroke-width":2,"stroke":"rgba(0, 0, 0, 0)"},"id":"be9167a2-e433-4924-a5c4-15dd6e891530","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)","fill":"#f9f1df","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"480f9ea2-bd82-40e9-839d-cf8450c024e4","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)","fill":"#f9f1df","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8a63439d-42c8-4c94-a459-f9fdcc874419","children":[],"html":"JavaScript 的单线程设计简化了其在浏览器环境中的执行模型，并通过异步操作和事件循环来处理需要等待的任务。虽然这种设计在某些场景下可能会成为性能瓶颈（例如大量计算任务），但通过合理使用异步编程和 Web Workers 等技术，可以有效地提高 JavaScript 应用的性能和响应能力。","zIndex":26}],"html":"如何理解JS是单线程语言","zIndex":27}],"html":"进程和线程","zIndex":28},{"html":"前端使用异步的场景","id":"ac9aa6cd-634e-4990-bfef-a1704b16e316","children":[{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)","fill":"#f9f1df"},"defaultContentStyle":{"color":"#262626"},"id":"d4f0f423-9d16-4e6a-be89-3785884aadd5","children":[],"html":"网络请求，如ajax请求、图片加载","zIndex":24},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)","fill":"#f9f1df"},"defaultContentStyle":{"color":"#262626"},"id":"e6515883-4e99-467a-9976-f4879758378d","children":[],"html":"定时任务，setTimeout","zIndex":23}],"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)","fill":"#f9f1df"},"zIndex":25},{"border":{"shape":"rect","stroke":"rgba(0, 0, 0, 0)","fill":"#f9f1df","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b80cbb53-2f12-4317-829f-abe901bfd334","children":[],"html":"手写用Promise加载一张图片","zIndex":20}],"html":"异步和单线程","zIndex":29},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#E8EEFC","stroke":"transparent"},"id":"ec63bfba-c7dd-42a7-a53c-3bf79268050c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E8EEFC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8250c3eb-78a1-4644-a111-179b942a02e2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E8EEFC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8ce1bb31-1ffa-4e1c-92bd-b608f79d6104","children":[],"html":"管理任务队列","zIndex":31},{"border":{"shape":"rect","stroke":"transparent","fill":"#E8EEFC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b967e1fd-efd1-401d-b148-17785348ea13","children":[],"html":"调度异步任务的执行顺序","zIndex":32},{"border":{"shape":"rect","stroke":"transparent","fill":"#E8EEFC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"aa3b6d72-e32c-4601-ac71-1fd617451be8","children":[],"html":"通过宏任务和微任务的区分来优化异步处理流程","zIndex":30}],"html":"<span style=\"font-weight:bold;\">事件循环</span>机制是JavaScript异步操作中的核心机制，它负责：","zIndex":33}],"html":"事件循环与异步","treeEdge":{"stroke":"#6F81DB","stroke-width":2},"zIndex":34},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#FAEDF6","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"id":"10b75ee6-94c7-4d14-97ad-1468853ca75f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9d189f45-9043-4ea6-b68d-e0b00fa1868c","children":[],"html":"层层嵌套，会产生回调地狱","zIndex":36},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2f2f4519-6608-49b0-bd2d-1d7912c2a378","children":[],"html":"不利于代码复用、理解和维护","zIndex":35}],"html":"回调函数","zIndex":37},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#EFE8FA","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"id":"2e93824c-688d-4767-9bd7-9e47bb6c040d","children":[{"id":"b43a23f7-5e4e-42b7-9edf-17b5c7d4a707","html":"基础","treeEdge":{"stroke":"#A287E1"},"children":[{"defaultContentStyle":{"color":"#262626"},"id":"7e21f901-b4ea-4b48-86f6-d89fe0cc5f2e","children":[{"defaultContentStyle":{"color":"#262626"},"id":"e27568e4-5768-490c-b1ed-75e15ab8450b","children":[],"html":"Promise是一个对象，通过它可以获取异步操作的消息。异步编程的解决方案。","width":518,"zIndex":46}],"html":"含义","zIndex":47},{"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"d2641122-f899-4e8f-a87c-8a398fe94cf9","children":[{"defaultContentStyle":{"color":"#262626"},"id":"9b3b16d1-b5a5-4c6e-a939-03547a4f6aed","children":[],"html":"1. 对象状态不受外界影响。只有异步操作的结果可以决定状态。","zIndex":49},{"defaultContentStyle":{"color":"#262626"},"id":"5f0b51b5-f23a-4781-8bd3-1265160d0e9f","children":[],"html":"2. 一旦状态改变，就会凝固，不会再变。","zIndex":48}],"html":"特点","zIndex":50},{"defaultContentStyle":{"color":"#262626"},"id":"0a6bfa9f-7194-4e45-bcd0-f8b7c9d21b4f","children":[{"defaultContentStyle":{"color":"#262626"},"id":"a84e42c7-3093-4319-b9f3-773257fbbae2","children":[],"html":"1. 无法取消","zIndex":52},{"defaultContentStyle":{"color":"#262626"},"id":"0cd7e5db-04c6-4441-8586-458ba42d9621","children":[],"html":"2. 如果不设置回调函数，Promise内部会抛出错误，不会反应到外部","zIndex":53},{"defaultContentStyle":{"color":"#262626"},"id":"5ab795fb-c698-49be-a592-d7262a8b2f5f","children":[],"html":"3. 处于pending状态时，无法得知目前进展到哪一阶段，是刚开始还是即将完成","height":49.75,"width":515,"zIndex":51}],"layout":{"quadrant":1},"html":"缺点","zIndex":54},{"defaultContentStyle":{"color":"#262626"},"id":"54ee3882-cb76-4272-9280-dbed85582de1","children":[{"defaultContentStyle":{"color":"#262626"},"id":"a73d1ab5-f4d6-4562-b16d-dc18adba09fe","children":[],"html":"Promise是一个构造函数，接受一个函数作为参数，函数的两个参数分别是resolve和reject。它们是由JS引擎提供的两个函数，不用自己部署。","zIndex":42},{"defaultContentStyle":{"color":"#262626"},"id":"24f6c61f-a3ea-40a3-8b77-5473a89e13a3","children":[],"html":"resolve：将Promise对象的状态从pending变为resolved，在异步操作成功时调用，并将异步操作的结果作为参数传递出去","zIndex":44},{"defaultContentStyle":{"color":"#262626"},"id":"335e49b3-375c-4fda-a1f7-be032edb8c54","children":[],"html":"reject：将Promise对象的状态从pending变为rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去","zIndex":43},{"defaultContentStyle":{"color":"#262626"},"id":"07b132e0-3a86-4003-80dc-42f62924c1de","children":[],"html":"resolve和reject回调是在本轮事件循环的末尾执行，晚于本轮循环的同步任务","zIndex":41}],"html":"基本用法","zIndex":45}],"defaultContentStyle":{"color":"#262626"},"layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":55},{"id":"5bdc79cb-4fe0-4385-a453-f94f2520321d","html":"Promise.prototype.then","treeEdge":{"stroke":"#6F81DB"},"children":[{"defaultContentStyle":{"color":"#262626"},"id":"7b660395-8850-41e5-b3b4-5da535bdb30d","children":[],"html":"Promise实例生成后，用then指定resolved和rejected状态的回调函数，并返回一个新的Promise实例，因此可以实现链式调用。","zIndex":70},{"defaultContentStyle":{"color":"#262626"},"id":"a78e61db-541b-4316-91aa-31fb3abe5760","children":[],"html":"采用链式的then，可以指定一组按照次序调用的回调函数。如果前一个then存在异步操作，如返回一个promise，后面的then会等待前一个then的promise状态变化后才会执行","zIndex":71},{"defaultContentStyle":{"color":"#262626"},"id":"24f9657e-6b0e-4319-877c-3fc662dc8ea8","children":[],"html":"then 和 catch的参数期望是函数，传入非函数会发生值穿透：原理是如果传入的不是函数，这个then是无效的，则then返回的promise的data，将会保存上一个promise的data","zIndex":69}],"defaultContentStyle":{"color":"#262626"},"layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":72},{"id":"2d6c1bd3-0487-48a6-9e3c-2e0cbbbfd91d","html":"Promise.prototype.catch","treeEdge":{"stroke":"#6EC4C4"},"children":[{"defaultContentStyle":{"color":"#262626"},"id":"830adf13-2c91-42af-b99a-8ad4569c1976","children":[],"html":"用于指定发生错误时的回调函数，返回一个新的Promise","zIndex":79},{"defaultContentStyle":{"color":"#262626"},"id":"61e62204-5d65-43e9-99d6-3985d88c5795","children":[],"html":"异步操作中抛出错误 -&gt; 状态变为rejected -&gt; 调用catch方法指定的回调函数","height":52.125,"width":512,"zIndex":81},{"defaultContentStyle":{"color":"#262626"},"id":"975916ba-a775-451f-95e3-5a3daae63e69","children":[],"html":"then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获","zIndex":82},{"defaultContentStyle":{"color":"#262626"},"id":"316a1158-c594-49c3-90d7-e732ffa171a6","children":[],"html":"一般不要在then方法里定义reject状态的回调函数，使用catch方法捕获前面的所有错误","zIndex":80},{"defaultContentStyle":{"color":"#262626"},"id":"2b7cf377-e270-4005-b901-9100da98ab81","children":[],"html":"如果不用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，也就是promise会吃掉错误","zIndex":78}],"defaultContentStyle":{"color":"#262626"},"layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":83},{"treeEdge":{"stroke":"#DFB85D"},"defaultContentStyle":{"color":"#262626"},"id":"58cb0adc-613d-4f83-864b-310708d38981","children":[{"defaultContentStyle":{"color":"#262626"},"id":"770e927f-f910-45bb-9a12-e898ec3299d2","children":[],"html":"不管promise对象最后状态如何，都会执行的操作","zIndex":88}],"html":"Promise.prototype.finally","layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":89},{"treeEdge":{"stroke":"#77C386"},"defaultContentStyle":{"color":"#262626"},"id":"6455b48a-565b-4c6e-85dd-af84122c916e","children":[{"defaultContentStyle":{"color":"#262626"},"id":"8687b00f-1e8c-4638-b767-70dae3edbef7","children":[],"html":"一组promise实例，全都是resolve状态，或者至少有一个是reject状态，才会执行all的回调，会将这些promise的返回值组成一个数组返回","zIndex":86}],"html":"Promise.all","layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":87},{"treeEdge":{"stroke":"#E48484"},"defaultContentStyle":{"color":"#262626"},"id":"06d57a03-bfde-4460-a74f-2255486bd39e","children":[{"defaultContentStyle":{"color":"#262626"},"id":"db8caec2-4b9e-4e2b-bba3-16188f11654d","children":[],"html":"一组promise实例，有一个是resolve状态，或者reject状态，就会返回","zIndex":84}],"html":"Promise.race","layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":85},{"treeEdge":{"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"dab2ac5b-91af-4c03-9103-106289360023","children":[{"defaultContentStyle":{"color":"#262626"},"id":"59aa96ae-fd15-4a1c-b471-3c5b22df8b9c","children":[],"html":"ES2020引入。一组promise实例，无论成功失败，只要执行完了就会返回，返回结果是个包含promise执行结果的数组","zIndex":76}],"html":"Promise.allSettled","layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":77},{"treeEdge":{"stroke":"#69B1E4"},"defaultContentStyle":{"color":"#262626"},"id":"119555ae-413c-4840-a3ef-34bf7f2eef09","children":[{"defaultContentStyle":{"color":"#262626"},"id":"036fe59e-ce42-41fa-b5e5-2a6135e7505b","children":[],"html":"ES2021引入。接收一组promise实例作为参数，包装成一个新的promise实例返回。","zIndex":74},{"defaultContentStyle":{"color":"#262626"},"id":"a3f1ef8d-58ec-496c-b698-f314798b246e","children":[],"html":"只要参数实例中有一个变成fullfilled状态，包装实例就会变成fullfilled状态；所有实例都变成rejected状态，包装实例就会变成rejected状态。","zIndex":73}],"html":"Promise.any","layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":75},{"treeEdge":{"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"d8f6477b-5715-4d3a-8c00-19944b7a8b8e","children":[{"defaultContentStyle":{"color":"#262626"},"id":"120cfad2-86ab-48f2-9b14-27b74fe5f4fc","children":[],"html":"将现有对象转为promise对象","zIndex":66},{"defaultContentStyle":{"color":"#262626"},"id":"8486261d-a526-458d-880b-3021c136ca19","children":[],"html":"Promise.resolve('foo')<div>// 等价于</div><div>new Promise(resolve =&gt; resolve('foo'))</div>","zIndex":67},{"defaultContentStyle":{"color":"#262626"},"id":"6689ba6b-b1a2-4e10-8a95-36d6679e54c5","children":[],"html":"Promise.resolve()在本轮事件循环结束时执行<div>setTimeout(fn, 0)在下一轮事件循环开始时执行</div>","zIndex":65}],"html":"Promise.resolve","layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":68},{"treeEdge":{"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"71f1f722-daff-4228-8a11-0133640ffee5","children":[{"defaultContentStyle":{"color":"#262626"},"id":"9b03b004-2362-47a4-95e5-770c46928105","children":[],"html":"返回一个promise实例，该实例的状态为rejected","zIndex":63}],"html":"Promise.reject","layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":64},{"treeEdge":{"stroke":"#6EC4C4"},"defaultContentStyle":{"color":"#262626"},"id":"0216c240-269b-474e-a918-e888f0c6416a","children":[{"defaultContentStyle":{"color":"#262626"},"id":"a400273c-1777-480d-ad2b-a9aea1497633","children":[],"html":"可以包装同步或者异步方法，统一使用promise的api，并且让同步函数同步执行，异步函数异步执行","zIndex":61}],"html":"Promise.try","layout":{"quadrant":1},"border":{"fill":"#EFF0F0"},"zIndex":62},{"border":{"fill":"#EFF0F0"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"67277a84-9ee0-43b0-ab2d-cc7c02bbebd7","children":[{"border":{"fill":"#EFF0F0"},"defaultContentStyle":{"color":"#262626"},"id":"2bb0899e-100b-4e4e-8aff-9ac69dee0f92","children":[],"html":"都是Promise的静态方法，用于处理多个 Promise 实例。两者区别如下：","zIndex":59},{"border":{"fill":"#EFF0F0"},"defaultContentStyle":{"color":"#262626"},"id":"7e7e01ff-ccc4-4db2-ab7b-96fceeb54b37","children":[{"border":{"fill":"#EFF0F0"},"defaultContentStyle":{"color":"#262626"},"id":"eadacc90-8876-4e03-934d-f7eaba6be053","children":[],"html":"返回值","zIndex":57},{"border":{"fill":"#EFF0F0"},"defaultContentStyle":{"color":"#262626"},"id":"a9d85a15-a52f-457d-ba9c-a053f3687042","children":[],"html":"处理方式","zIndex":56}],"html":"区别","zIndex":58}],"html":".all 和 .allSettled 的区别","zIndex":60},{"border":{"fill":"#EFF0F0"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"bcd85e51-ea92-42de-8c69-7a8c3fac3748","children":[{"border":{"fill":"#EFF0F0"},"defaultContentStyle":{"color":"#262626"},"id":"dc3c7e7b-e215-4820-b82d-d695bb803174","children":[],"html":"同时发起多个请求：Promise.all","zIndex":39},{"border":{"fill":"#EFF0F0"},"defaultContentStyle":{"color":"#262626"},"id":"fc71af7f-251b-4857-949c-c89663f37454","children":[],"html":"超时处理：Promise.race","zIndex":38}],"html":"应用","zIndex":40}],"html":"Promise&nbsp;","zIndex":90},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E6F4FC","stroke":"transparent"},"id":"3c0e7fcf-92c9-47fa-ba16-0df0a07680d6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"da86c308-51d8-461e-b5ea-492ae70843e2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b519f62e-da3c-4d40-933c-f88041adb70b","children":[],"html":"同步语法编写异步代码，优化then链的代码编写方式","zIndex":6},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"78793f6b-d2c9-48c9-87bb-5c785a96dd02","children":[],"html":"Generator 的语法糖","zIndex":5}],"html":"概念","zIndex":7},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7e0adbb0-cad7-489e-8974-d3e9a6f60496","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"101a7cb9-6433-4f35-ba47-cdd1316a63f9","children":[],"html":"await等待的是async函数的返回值，await后面可以接Promise、普通函数和直接量","zIndex":9},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"613441b9-8c91-4ab4-96e6-40098ff285a9","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8383fdfe-32d1-4de1-bb98-d73f82494900","children":[],"html":"如果它等到的是一个 Promise 对象，await 会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。","zIndex":10}],"html":"await跟Promise，相当于Promise.then","zIndex":11},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2775c499-c0ab-4617-8426-4aaa508db40f","children":[],"html":"await跟值，Promise.resolve(400)，直接返回值","zIndex":8}],"html":"await","zIndex":12},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"62816760-1702-43e0-be75-296d70f3c18f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"991eaa47-d43c-4dc5-a0da-77eb3155949c","children":[],"html":"try catch","zIndex":17}],"html":"错误捕获","zIndex":18},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f1ee2eda-15f5-4212-ac01-765a1d03e4d3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"af60c6b2-2e83-4e7f-9f86-92c02eb8111c","children":[],"html":"执行 async函数，返回的是Promise对象","zIndex":14},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8177745b-65fc-4f3f-b8c0-fa6dddd5ee08","children":[],"html":"await 相当于Promise的then","zIndex":15},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7f18fecf-05ec-4700-8ba2-aaad7921e1b0","children":[],"html":"try catch可捕获异常，代替了Promise的catch","zIndex":13}],"html":"async/await 和 Promise 的关系","zIndex":16},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4b1fc26b-124c-4c5e-bfc9-7c61a21fe25e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4a176377-005d-4e96-9e98-eb0f164fcc78","children":[],"html":"对于promise多个then链式调用的场景，同步的写法更加清晰","zIndex":1},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"18c1d468-4ac5-43a9-ad5e-dd8509a57ac8","children":[],"html":"Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅","zIndex":2},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ac89ecf3-b229-4028-9692-55e30d77ff04","children":[],"html":"错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余","zIndex":3},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f9ecadbc-d0e5-44e3-bf6b-5d844deda59d","children":[],"zIndex":0,"html":"调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。"}],"html":"优势","zIndex":4}],"html":"async/await","treeEdge":{"stroke":"#69B1E4","stroke-width":2},"zIndex":19}],"layout":{"type":"standard","direction":[1,0]},"zIndex":91}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[8,20,1],"width":1601,"height":949},"viewportOption":"adapt","text":"异步异步和单线程同步和异步JS是单线程语言，同步会阻塞代码执行，异步不会进程和线程如何理解JS是单线程语言JavaScript 的单线程设计简化了其在浏览器环境中的执行模型，并通过异步操作和事件循环来处理需要等待的任务。虽然这种设计在某些场景下可能会成为性能瓶颈（例如大量计算任务），但通过合理使用异步编程和 Web Workers 等技术，可以有效地提高 JavaScript 应用的性能和响应能力。前端使用异步的场景网络请求，如ajax请求、图片加载定时任务，setTimeout手写用Promise加载一张图片事件循环与异步事件循环机制是JavaScript异步操作中的核心机制，它负责：管理任务队列调度异步任务的执行顺序通过宏任务和微任务的区分来优化异步处理流程回调函数层层嵌套，会产生回调地狱不利于代码复用、理解和维护Promise 基础含义Promise是一个对象，通过它可以获取异步操作的消息。异步编程的解决方案。特点1. 对象状态不受外界影响。只有异步操作的结果可以决定状态。2. 一旦状态改变，就会凝固，不会再变。缺点1. 无法取消2. 如果不设置回调函数，Promise内部会抛出错误，不会反应到外部3. 处于pending状态时，无法得知目前进展到哪一阶段，是刚开始还是即将完成基本用法Promise是一个构造函数，接受一个函数作为参数，函数的两个参数分别是resolve和reject。它们是由JS引擎提供的两个函数，不用自己部署。resolve：将Promise对象的状态从pending变为resolved，在异步操作成功时调用，并将异步操作的结果作为参数传递出去reject：将Promise对象的状态从pending变为rejected，在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去resolve和reject回调是在本轮事件循环的末尾执行，晚于本轮循环的同步任务Promise.prototype.thenPromise实例生成后，用then指定resolved和rejected状态的回调函数，并返回一个新的Promise实例，因此可以实现链式调用。采用链式的then，可以指定一组按照次序调用的回调函数。如果前一个then存在异步操作，如返回一个promise，后面的then会等待前一个then的promise状态变化后才会执行then 和 catch的参数期望是函数，传入非函数会发生值穿透：原理是如果传入的不是函数，这个then是无效的，则then返回的promise的data，将会保存上一个promise的dataPromise.prototype.catch用于指定发生错误时的回调函数，返回一个新的Promise异步操作中抛出错误 -> 状态变为rejected -> 调用catch方法指定的回调函数then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获一般不要在then方法里定义reject状态的回调函数，使用catch方法捕获前面的所有错误如果不用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，也就是promise会吃掉错误Promise.prototype.finally不管promise对象最后状态如何，都会执行的操作Promise.all一组promise实例，全都是resolve状态，或者至少有一个是reject状态，才会执行all的回调，会将这些promise的返回值组成一个数组返回Promise.race一组promise实例，有一个是resolve状态，或者reject状态，就会返回Promise.allSettledES2020引入。一组promise实例，无论成功失败，只要执行完了就会返回，返回结果是个包含promise执行结果的数组Promise.anyES2021引入。接收一组promise实例作为参数，包装成一个新的promise实例返回。只要参数实例中有一个变成fullfilled状态，包装实例就会变成fullfilled状态；所有实例都变成rejected状态，包装实例就会变成rejected状态。Promise.resolve将现有对象转为promise对象Promise.resolve('foo')// 等价于new Promise(resolve => resolve('foo'))Promise.resolve()在本轮事件循环结束时执行setTimeout(fn, 0)在下一轮事件循环开始时执行Promise.reject返回一个promise实例，该实例的状态为rejectedPromise.try可以包装同步或者异步方法，统一使用promise的api，并且让同步函数同步执行，异步函数异步执行.all 和 .allSettled 的区别都是Promise的静态方法，用于处理多个 Promise 实例。两者区别如下：区别返回值处理方式应用同时发起多个请求：Promise.all超时处理：Promise.raceasync/await概念同步语法编写异步代码，优化then链的代码编写方式Generator 的语法糖awaitawait等待的是async函数的返回值，await后面可以接Promise、普通函数和直接量await跟Promise，相当于Promise.then如果它等到的是一个 Promise 对象，await 会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。await跟值，Promise.resolve(400)，直接返回值错误捕获try catchasync/await 和 Promise 的关系执行 async函数，返回的是Promise对象await 相当于Promise的thentry catch可捕获异常，代替了Promise的catch优势对于promise多个then链式调用的场景，同步的写法更加清晰Promise传递中间值⾮常麻烦，⽽async/await⼏乎是同步的写法，⾮常优雅错误处理友好，async/await可以⽤成熟的try/catch，Promise的错误捕获⾮常冗余调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。","graphicsBBox":{"x":633,"y":313.5,"width":1194,"height":3260.5}}