{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"id":"cbed35ae-b714-4cac-9a62-3dc607391d4e","x":890.3662298828126,"y":350.6250018554688,"html":"性能优化","type":"mindmap","defaultContentStyle":{"color":"rgb(38, 38, 38)"},"border":{"fill":"#F5F5F5","shape":"capsule","stroke":"transparent","stroke-width":2},"children":[{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#FAEDF6","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"id":"3a227fe9-ad19-4bc7-b832-172898eca653","children":[{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"0c320527-9d23-404d-9cd5-24fb19fc3720","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a7845911-bda0-45c9-a05d-87f4441d9c6a","children":[],"html":"当用户请求一个网站时，如果在 1 秒内看不到关键内容，用户会产生任务被中断的感觉。","zIndex":9}],"html":"页面加载时长","zIndex":10},{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"2d1fa939-2ea2-42b5-b95d-bf9856d89d12","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7f23604e-c16e-431b-a97e-719d956123d6","children":[],"html":"当用户点击某些按钮时，如果 100ms 内无法响应，用户会感受到延迟。","zIndex":11}],"html":"用户交互反馈时长","zIndex":12},{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"002082d6-488f-4c1b-9069-31f4f080ceb6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"0d99d391-a439-424a-847d-6c6452bb51eb","children":[],"html":"如果 Web 中的动画没有达到 60fps，用户会感受到动画的卡顿。","zIndex":7}],"html":"Web 动画中的帧数","zIndex":8}],"html":"用户体验衡量指标","collapsed":true,"zIndex":1},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E6F4FC","stroke":"transparent"},"id":"2f23c63a-9cfc-42bb-80a1-9ee10bca02ec","children":[{"border":{"shape":"rect","stroke-width":1,"stroke":"transparent","fill":"#FFFFFF"},"id":"86801d01-3c88-4432-99c7-b94427bef2c3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"70d1a212-36df-4802-bff1-caf411cb17f2","children":[],"html":"DNS prefetch 是一种浏览器机制，可以在浏览器空闲时预先解析网页中的域名，以提前获取域名对应的 IP 地址，从而加速后续的页面加载过程。通常情况下，<span style=\"font-weight:bold;\">浏览器会自动执行 DNS prefetch</span>，但也可以通过 HTML 的 &lt;link&gt; 元素手动指定需要预取的域名。","zIndex":46}],"html":"DNS prefetch","collapsed":true,"zIndex":45},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"aeb5700c-8a48-429d-9e9e-4e282cd851a6","children":[{"border":{"shape":"rect","stroke-width":1,"stroke":"transparent","fill":"#FFFFFF"},"id":"bbc45f65-d018-47c3-891c-256c0d56b36e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"12f3476a-3f81-43d2-9284-20ad716343c4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d2a0f51c-1cae-4412-864d-131af8915eb8","children":[],"html":"压缩CSS、JS、图片","zIndex":48},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"46c7d0d3-306f-4417-9c86-91fc9d0be82b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"85c6bc58-1bb7-4793-8999-e4b897e457a2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"11931127-786d-48c5-b242-0d7569401fa8","children":[],"html":"是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小","zIndex":51}],"html":"原理","layout":{"quadrant":1},"zIndex":50},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"83e27a29-e6de-4fbf-b43a-6916b63689a6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"022b1004-e266-4501-b59b-c9ff37e05317","children":[],"html":"Webpack的 Gzip 是为了在构建过程中去做一部分服务器的工作，为服务器分压","zIndex":53}],"html":"Webpack的Gzip","zIndex":52},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7c700f1c-22d0-440a-a878-a7ea86b220b8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"96e187c3-35eb-405b-9982-935a3e01a780","children":[],"html":"服务器会启用自己的CPU去完成Gzip，以服务器压缩的时间开销和 CPU 开销（以及浏览器解析压缩文件的开销）为代价，省下了一些传输过程中的时间开销","zIndex":55}],"html":"服务端的Gzip","zIndex":54},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5ffa4e1b-8d2a-4493-857a-1f54dab25a62","children":[],"html":"Gzip的压缩级别可以调整，压缩率越高，压缩速度越慢。对于静态资源文件，通常可以使用较高的压缩级别，而对于动态生成的内容，可能需要权衡压缩率和服务器性能。","zIndex":56}],"html":"Gzip","zIndex":49}],"html":"资源压缩","zIndex":47},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6805fdb7-2eb7-4206-83c6-6839345b18d7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8614083f-a581-4390-bbbf-dfcf70bc6664","children":[],"html":"入口点分割，配置多个entry","zIndex":58},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"05080647-1b4f-4f43-b599-8ef62b55dcac","children":[],"html":"分包配置","zIndex":59},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"36449d6a-769f-44a8-8756-da7175975af7","children":[],"html":"提取公共第三方库","zIndex":60}],"html":"资源拆分","zIndex":57},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a8d26f4f-bded-4ed8-8502-a16b2456689c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"752418e2-4ef3-4382-90e9-b45659f5fac4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4c76a0bc-4f22-45ba-aa74-812a2498d77b","children":[],"html":"purgecss-webpack-plugin","zIndex":63}],"html":"清除无用的CSS","zIndex":62},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ffa3ec78-22c8-43be-9d9b-d1bd1892e2e5","children":[],"html":"Tree Shaking","zIndex":64},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f7347147-b2da-463d-b0a0-1539a94d71b6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8223989a-8cb2-472f-b2e7-7f0c78313b81","children":[],"html":"@babel/plugin-transform-runtime","zIndex":66}],"html":"避免babel辅助代码重复引入","zIndex":65}],"html":"删除冗余代码","zIndex":61},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8c71cc7b-bba7-4820-80fb-3a77f8bfbf8e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"0c4fc1ed-b0a7-4c45-a396-5503e4651d8b","children":[],"html":"Suspence + React.lazy","zIndex":68}],"html":"按需加载","zIndex":67},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9bb241ec-83ca-4bd1-a8d2-2c68c30b2ad5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"97ad16ac-5b2d-4372-846f-79711e9e7e56","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1c3cc297-a7a7-4890-99cb-13a8903eac1a","children":[],"html":"CDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。","layout":{"quadrant":1},"zIndex":71},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d21dd28c-238f-4a88-8fcd-1e395c58d4e8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8790cfb4-5a6a-498b-ac9a-5c0b59a914e5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"77ba2b87-1103-45c8-b4e4-783c9fed0eba","children":[],"html":"我们把资源 copy 一份到 CDN 服务器上这个过程","zIndex":74}],"html":"缓存","zIndex":73},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a7e3d9ee-bde2-4d1e-bdd1-ceeee3e2fbad","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"eb1be9f2-ac14-4fef-b1d1-055389265400","children":[],"html":"CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程","zIndex":76}],"html":"回源","zIndex":75}],"html":"核心点","zIndex":72},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fa8e960c-8f7d-4224-b077-f851f2715939","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"de99b791-f60b-4a85-9591-ad67ef3994df","children":[],"html":"CDN 往往被用来存放静态资源，是加载静态资源提速的重要手段","zIndex":78},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"07212592-6352-4e8f-94dd-3698d94b68ff","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b77c2fc1-f134-4492-a233-72913d6e6478","children":[],"html":"就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。","zIndex":80}],"html":"静态资源","zIndex":79},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"25bed79b-21d4-4e93-bb0e-5aefdd5dafb5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"407a5fb0-b674-434b-98fe-ad13e6249ab9","children":[],"html":"它是指需要服务器在页面之外作额外计算的 HTML 页面。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它和业务服务器的操作耦合，我们把它丢到CDN 上显然是不合适的。","zIndex":82}],"html":"非纯静态资源","zIndex":81}],"html":"如何使用CDN优化","zIndex":77}],"html":"CDN","collapsed":true,"zIndex":70}],"html":"静态资源存放CDN","layout":{"quadrant":1},"zIndex":69}],"html":"减少请求花费的时间","layout":{"quadrant":1},"collapsed":true,"zIndex":42},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"dcd8cc2a-a52a-4306-8119-c1fb0188c3d1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"21278e61-5db5-466e-b8b1-5b5e370950df","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"55488d71-9f6f-4846-b1d7-bd6e2ceb70ca","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4e1a7648-6743-4649-a0ed-a837213c2507","children":[],"html":"Expires","zIndex":16},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"93c46894-f52d-4cce-83be-7c892e8ea256","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8cfb887d-9e78-4d67-87fe-8fa30d3f2d56","children":[],"html":"通过max-age控制资源有效期","zIndex":18},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"47e4511e-d211-45b0-bb25-542e8b2ae6c5","children":[],"html":"public 与 private：针对资源是否能够被代理服务缓存而存在的一组对立概念","zIndex":20},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"dae6fcf9-898f-41ca-8e66-2a6da2a41cda","children":[],"html":"no-cache 绕开了浏览器，进入协商缓存流程","zIndex":19},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a17ceaf8-6c2c-41e0-936d-bc2d131c08d1","children":[],"html":"no-store 不使用缓存","zIndex":17}],"html":"Cache-Control","zIndex":21},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"1b2d69da-e834-4990-aae9-d5f72a05fdac","children":[],"html":"优先级更高，浏览器再次请求资源时，会根据expires和cache-control判断目标资源是否命中强缓存，命中就直接从缓存中获取，不再请求服务端，HTTP状态码为200","zIndex":15}],"html":"强缓存","zIndex":22},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8dd9cb8e-1674-487e-a091-4455ccd72a15","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d16ce67b-744b-4bb1-acb4-c45318110da5","children":[],"html":"协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源","zIndex":30},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"02ff8371-2d69-4544-a62c-70556645767c","children":[],"html":"如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304","zIndex":31},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"37ada456-4c8f-46ec-902f-a67b1f4ce0ca","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"2f3dd402-babd-4e44-b89d-454eac3c13a2","children":[],"html":"Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT","zIndex":35},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"11e5eecc-2b3d-40c0-b809-ce37671e1459","children":[],"html":"随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT","zIndex":37},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"17c097d3-6cf3-4518-83ab-22c9e3f8bb8d","children":[],"html":"服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。","zIndex":36},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"487e35e6-8a96-4be8-83d2-5c25ea40b2d8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ef11bc79-622e-4c63-b892-0c496d2c9226","children":[],"html":"我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。","zIndex":33},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"06de1123-7c53-47e2-a13b-0e24d2acc993","children":[],"html":"当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。","zIndex":32}],"html":"缺点","zIndex":34}],"html":"Last-Modified&nbsp;","zIndex":38},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d81c1543-a6b2-49a3-862e-0e7d3e555f7e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b34a1aa9-af92-4331-b7fe-f81e3114a5bc","children":[],"html":"Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的","zIndex":26},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3ac439dd-97b6-4db7-9336-3e2857e0a5ae","children":[],"html":"当首次请求时，我们会在响应头里获取到一个最初的标识符字符串 ETag: W/\"2a3b-1602480f459\"","zIndex":27},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3fb2571c-fcbd-45d7-a768-e188525735d5","children":[],"html":"那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：If-None-Match: W/\"2a3b-1602480f459\"","zIndex":28},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e094f448-b94f-47f6-b913-7954c5ca85e7","children":[],"html":"Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。","zIndex":25}],"html":"Etag","zIndex":29}],"html":"协商缓存","zIndex":39},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"527a5344-d38d-4d8a-87f7-3274a7be04f5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"87f25139-1a7d-4b8e-bcde-cde0171db38d","children":[],"html":"当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store","zIndex":83},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8741cf0c-a223-4bb1-b37e-8110c3887082","children":[],"html":"否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache","zIndex":84},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e53bbe4d-8eb0-4ce1-a91f-47ccfabcf42c","children":[],"html":"否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；","zIndex":85},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3f2523ce-b01e-4942-8f0b-abf5d434fcd5","children":[],"html":"然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；","zIndex":86},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"53e0734a-8cb7-46a4-bd12-da4720a61eef","children":[],"zIndex":87,"html":"最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。"}],"html":"缓存决策","collapsed":true,"zIndex":24},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e4ce6df0-2cc1-480d-bfa7-252e00834a16","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"94cbc364-07b5-4dbc-b944-e429af5971ab","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"59eca849-3be9-445e-a134-6fa118756c2b","children":[],"html":"内存中的缓存，优先级最高，响应最快，有效期最短","zIndex":89}],"html":"MemoryCache","zIndex":88},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f2e1d0eb-0c22-4e41-9185-cf4cc44f77f3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7f5051a8-2246-4b97-8a56-62ce997db8dc","children":[],"html":"Service Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。可以帮我们实现离线缓存、消息推送和网络代理等功能。","zIndex":91},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1c4d3cc1-ef30-4c82-a37b-b25c40bdc1e0","children":[],"html":"Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。","zIndex":92},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"16b1b039-b24b-471d-a902-0c734e2fccd1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"cc2ae513-80e4-4fc5-8d81-b37c09d1c02f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"eb1114ca-32c2-4dc7-a63e-6a6e63c94958","children":[],"html":"window.navigator.serviceWorker.register('/test.js').then(<div>&nbsp; &nbsp;function () {</div><div>&nbsp; &nbsp; &nbsp; console.log('注册成功')</div><div>&nbsp; &nbsp; }).catch(err =&gt; {</div><div>&nbsp; &nbsp; &nbsp; console.error(\"注册失败\")</div><div>&nbsp; &nbsp; })</div>","zIndex":95}],"html":"serviceWorker注册一段js代码","zIndex":94},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a5f02471-b812-4e56-976a-318a791b3839","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"81602b24-8eaf-4f66-85e3-2e04cb923179","children":[],"html":"Service Worker会监听 install事件，我们在其对应的回调里可以实现初始化的逻辑&nbsp;&nbsp;","zIndex":97},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"522a6209-777b-4477-a7c0-942e6185ed6a","children":[],"html":"Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以在其对应的监听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，实现从Service Worker中取到缓存的目的","zIndex":98}],"html":"在js中实现缓存逻辑","zIndex":96}],"html":"如何实现离线缓存","zIndex":93},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f0f2f94f-9ea1-4ba5-a058-9be30532c9f3","children":[],"html":"Server Worker 对协议是有要求的，必须以 https 协议为前提","zIndex":99}],"html":"Service Worker Cache","zIndex":90},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"93387920-5dec-4578-a69d-113192e320b5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1fb0881f-ea27-48c7-bada-5f7a28ae8607","children":[],"html":"Push Cache 是指 HTTP2 在 server push 阶段存在的缓存","zIndex":101},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"29dbfe03-2f06-4abb-85f0-6b9afcc06d95","children":[],"html":"Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。","zIndex":102},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"cae30b8f-5e40-43c2-8fb0-7e6756a49bf3","children":[],"html":"Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。","zIndex":103},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5e6a9797-3de0-4cbd-8143-ef06cd3c1649","children":[],"html":"不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。","zIndex":104}],"html":"Push Cache","zIndex":100}],"html":"缓存位置","collapsed":true,"zIndex":14},{"start":2,"end":2,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\"><span style></span></div>","defaultContentStyle":{"color":"#262626"},"id":"78737242-8e22-4a00-9938-6bec2d07ba30","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1715242310744-3a846b72-9662-45f1-8668-9dbd981c9b60.png","naturalWidth":606,"naturalHeight":585,"uploadInfo":{"hash":"bd5f0a8fbea0f2fde8837867e7707c550a7fa2506e2940d52f5847eb1ea2eccd","fileName":"image.png","fileType":"image/png","fileSize":111563,"localTempSrc":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1715242310744-3a846b72-9662-45f1-8668-9dbd981c9b60.png","state":-2},"firstInsertRatio":0.5,"width":303,"height":292.5},"zIndex":23}],"html":"HTTP缓存","zIndex":40},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e865ba8c-b68d-48d0-8de6-b79cca04ea88","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"973324fa-1ec7-431f-bdb2-00802a557bfb","children":[],"html":"cookie","zIndex":105},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"daf56436-9a48-4878-9609-bb0e121935a5","children":[],"html":"Web Storage","zIndex":106},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5df4e068-56f0-4595-a8fe-05430506ebdc","children":[],"html":"indexedDB","zIndex":107}],"html":"本地存储","collapsed":true,"zIndex":13}],"html":"减少网络请求次数","zIndex":41},{"start":0,"end":1,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"资源的压缩与合并-&gt;通过构建工具Webpack来实现","defaultContentStyle":{"color":"#262626"},"id":"3e32e452-bcc4-4e81-8f0b-a578e4d12262","children":[],"zIndex":43}],"html":"HTTP优化方向","zIndex":44}],"html":"网络","treeEdge":{"stroke":"#69B1E4","stroke-width":2},"collapsed":true,"zIndex":3},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#FCF6E1","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"id":"d468d3b2-c5f4-4d02-96c5-64281dc9ce6f","children":[{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"60d735ee-1ebd-471a-a3f2-27dc31899e50","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"df0a8995-d7f2-4d3f-a9de-e81dc066f5be","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c883753a-abf2-4835-95f4-c3fb55048de7","children":[],"html":"在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。","zIndex":138}],"html":"解析HTML","zIndex":137},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cbd56b31-6433-4777-a78a-7240b74c82f4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"095d759a-3531-47a5-8db6-1b07d0d379fd","children":[],"html":"浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。","zIndex":140}],"html":"计算样式","zIndex":139},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"51cae357-265c-4606-b910-77fff83d289b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"87b5c83a-3cb4-4fae-87af-4488694c7522","children":[],"html":"页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。","zIndex":142}],"html":"计算图层布局","zIndex":141},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"210d4cb6-8aec-4881-92c5-2e8f21eab96c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2125efba-76fc-41b9-979f-4a5b54e77712","children":[],"html":"在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。","zIndex":144}],"html":"绘制图层","zIndex":143},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"05aba4aa-b4aa-4bb9-92c7-0a0bcb23ef64","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"46961a38-8eb2-45d2-a8ca-0d8d09f45dc7","children":[],"html":"最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（<span style=\"font-weight:bold;\">复杂的视图层会给这个阶段的 GPU 计算带来一些压力</span>，在实际应用中为了优化动画性能，我们有时会<span style=\"font-weight:bold;\">手动区分不同的图层</span>）。","zIndex":146}],"html":"整合图层，得到页面","zIndex":145}],"html":"浏览器渲染过程","collapsed":true,"zIndex":119},{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"498fadee-17d1-4bdb-9dd8-ac23d114478d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"26d15fb2-4ccc-4927-b306-5b23ce6d480c","children":[],"html":"每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它","zIndex":147},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6df07a8d-f718-4fe7-b73f-166711c3a58b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e91cb173-225a-48f9-861c-34d0a0501e0c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a6c5cd74-cecf-49e7-8948-cd79e5b463ef","children":[],"html":"CSS选择符是从右到左进行匹配的","layout":{"quadrant":1},"zIndex":150},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cecca5ce-ec0b-4136-9ae1-ba90ada9d989","children":[],"html":"避免使用通配符，只对需要用到的元素进行选择。","layout":{"quadrant":1},"zIndex":151},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d2abb3bb-dbb0-4614-a4a5-042e429f3439","children":[],"html":"关注可以通过继承实现的属性，避免重复匹配重复定义。","layout":{"quadrant":1},"zIndex":152},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"b988973f-5c15-419f-af7e-3101415bad32","children":[],"html":"少用标签选择器。如果可以，用类选择器替代","zIndex":153},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"13138e7f-1179-4157-9ea3-c43676687a9c","children":[],"html":"不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。.myList#title -&gt; #title","zIndex":154},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"7d44ced2-67a2-454d-8dfa-cb4cdba16c5d","children":[],"html":"减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。","zIndex":155}],"html":"CSS选择器使用","zIndex":149},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c415061a-af64-4827-83bd-bc99bcf69da1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c6df479d-b35b-487f-b339-0c025afcb307","children":[],"html":"CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。","zIndex":157},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"235c7fc6-bb39-44fc-8c8c-bec666ba960c","children":[],"html":"尽早：将 CSS 放在 head 标签里","zIndex":158},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ac0df763-14fe-44cf-be58-e32fd4941495","children":[],"html":"尽快：启用 CDN 实现静态资源加载速度的优化","zIndex":159}],"html":"CSS加载","zIndex":156}],"html":"性能提升方案","zIndex":148}],"html":"CSS优化","collapsed":true,"zIndex":120},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"63886a56-b73c-47a9-a8dc-d24e09be514d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"480257c8-c365-45c9-9309-5f9093909ff4","children":[],"html":"使用async或defer的方式，让JS的下载变成异步的。","layout":{"quadrant":1},"zIndex":122},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ca45ed68-aea5-4e0c-927b-2984cce20a0f","children":[],"html":"当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。","zIndex":121}],"html":"JS优化","zIndex":123},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7731f6b2-3235-404e-8c74-f59645fe1b25","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"90f941c0-211d-4758-ac0b-713b27e91a46","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"44d95a0e-e35d-4775-827c-9093964d0e04","children":[],"html":"操作DOM实际上是JS引擎和渲染引擎通过桥接接口(Web API)通信，过桥要收费，无论是修改DOM还是仅仅访问DOM值，都存在性能损耗。","zIndex":127},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7af578a0-3b99-4cc3-b7e7-24b8f72fcf24","children":[],"html":"会触发渲染树变化，导致回流和重绘","zIndex":126}],"html":"为什么DOM操作慢","zIndex":128},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c40663ef-1201-46bf-9a4f-2d677f5ab3ec","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2dada76a-104f-47ee-b5a3-661a286bd3d1","children":[],"html":"使用DOM Fragment作为容器完成内容处理，再一次性进行内容更新","zIndex":124}],"html":"如何减少DOM操作","zIndex":125}],"html":"Dom 优化","zIndex":129},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cf81fe20-92b4-4e28-89ec-a8b390604acb","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3b45caa6-0cb2-4b01-bf33-1b085800531d","children":[],"html":"在异步任务里进行DOM更新，需要包装成微任务，可以减少一次不必要的渲染，也不需要等到下一轮事件循环再生效","width":398.43240009781994,"zIndex":135},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0fa8a9b1-4add-459d-abca-e0b7334dd60d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"484687e9-1084-493b-a407-038c588abc1f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ba52a51f-e331-43b7-a6fa-678c890ff056","children":[],"html":"多次 setState，在JS层面会先执行完毕，而真正渲染的时候，只会做一次DOM操作","layout":{"quadrant":1},"zIndex":132}],"html":"Vue 和 React 的批量异步更新策略","zIndex":133},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"128b44dc-3fa9-4283-9c12-0428fa24e7ba","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2d6549c8-4415-4085-9b3b-8471e8301913","children":[],"html":"Vue 中每产生一个状态更新任务，它就会被塞进一个叫 callbacks 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 micro 或 macro 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 pending 锁是开着的（false），就把它设置为锁上（true），然后对当前 callbacks 数组的任务进行派发（丢进 micro 或 macro 队列）和执行。设置 pending 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。","zIndex":130}],"html":"nextTick","zIndex":131}],"html":"生产实践","zIndex":134}],"html":"基于事件循环的异步更新优化","zIndex":136},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4da7f9e9-2c8e-4fc7-b134-fc54c001875e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9b793c39-143e-4e79-9d70-100067273cfb","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ef3e7e19-c110-4844-8a19-d4e81f00b8c1","children":[],"html":"修改DOM的样式，不影响几何属性","zIndex":114}],"html":"重绘","zIndex":115},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"195e544e-3c18-4717-977a-cce7c02981ca","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c2b6ff10-44c3-45f1-a555-032926914171","children":[],"html":"改变DOM几何属性、改变DOM树结构、访问宽高距离等需要即时计算得到的属性值","zIndex":116}],"html":"回流","zIndex":117},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bad4fa6a-b6ce-4e7a-a9a5-c641481ce057","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5de1bba3-9377-4df1-986b-0d65a097b272","children":[],"html":"避免频繁操作样式，通过类名替换一次性修改多个样式","zIndex":109},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b8dfa3a9-6619-4c1d-a3c3-ed01a3807bf5","children":[],"html":"使用CSS3动画或者变换，利用GPU加速，减少重绘和回来","zIndex":111},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0c0777d0-db6f-44e7-9242-cee1715d4461","children":[],"html":"DOM离线化","zIndex":112},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ef15a11c-5489-4d2f-a23f-413b52e3f32f","children":[],"html":"利用浏览器渲染队列机制","zIndex":110},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c76ae435-366d-4f2f-8a35-b75fba8d4f1f","children":[],"html":"利用渲染分层实现合成优化","zIndex":108}],"html":"如何避免","zIndex":113}],"html":"重绘和回流优化","zIndex":118}],"html":"渲染","collapsed":true,"zIndex":5},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#EFE8FA","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"id":"d2d80b9e-0350-4f42-aa07-112794754373","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"9f42c23d-055e-4a7a-acd6-085a96624d2e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"6e9aa78e-1e70-485d-8164-2c3b5f886104","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a1330eb9-eb63-471a-b01d-110e1aaf19e6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"823d8164-7960-4af7-93b3-e4d822bbf5f3","children":[],"html":"首次绘制内容的耗时。首屏统计的方式一直在变，起初是通过记录 window.performance.timing 中的 domComplete 与 domLoading 的时间差来完成，但这并不具备交互意义，现在通常是记录初次加载并绘制内容的时间。","zIndex":163}],"layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"html":"FCP","zIndex":162},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9fc28231-2a73-480c-bcbb-16e0be373155","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1e4b0ad4-71b2-4648-bf7a-9ea7b7d98efd","children":[],"html":"是页面可交互的时间。通常通过记录 window.performance.timing 中的 domInteractive 与 fetchStart 的时间差来完成。","zIndex":165}],"html":"TTI","zIndex":164},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f9a205cc-3a40-44e9-8991-dff35125ad72","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9c32852d-6490-4f57-8c12-0ac7c0ef54ed","children":[],"html":"页面完全加载时间。通常通过记录 window.performance.timing 中的 loadEventStart 与 fetchStart 的时间差来完成。","zIndex":167}],"html":"Page Load","zIndex":166},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4252513d-838e-43fe-9499-23716e4286a0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"529c42c4-02b0-4b03-bb62-790fe756ed60","children":[],"html":"前端页面帧率，1秒内画面更新的次数。通常是在主线程打点完成记录。其原理是 requestAnimationFrame 会在页面重绘前被调用，而 FPS 就是计算两次之间的时间差。","zIndex":169}],"html":"FPS","zIndex":168},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"67322539-9af2-4fae-8ab0-2f0c0b789402","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a2b395ad-6717-495a-9cd0-b853d5d52288","children":[],"html":"通常是通过 window.performance.getEntries( ) 来获取相关信息","zIndex":171}],"html":"静态资源及API 请求成功率","zIndex":170}],"html":"指标","zIndex":161},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"3ed14eb4-a6b1-4a4c-90d9-47a52991fa1a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"620e2956-8040-494c-ab51-1023afaeb3f3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8f88b827-edc6-42d8-b86b-b61803d3a688","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"31c75b46-f034-4e91-bedb-9f5b4ebc2fcf","children":[],"html":"Performance 工具最重要的是分析主线程的 Event Loop，分析每个 Task 的耗时、调用栈等信息","zIndex":175},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"59514358-17ad-4443-b21c-6d551f30bab9","children":[],"html":"当你点击某个宏任务的时候，在下面的面板会显示调用栈的详情（选择 bottom-up 是列表展示， call tree 是树形展示）","zIndex":176},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"87593892-9068-4af9-a5ef-1361cde63e88","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"0fd43292-d6fa-4065-8151-9cfa24641aed","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"076421f9-52fa-4956-ab08-b1493d530fff","children":[],"html":"fiber架构：拆分task","layout":{"quadrant":1},"zIndex":179},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"77dbce01-1222-44a9-a48e-36179d7f10f9","children":[],"html":"开启web worker，把复杂计算放在worker里","zIndex":180}],"html":"解决long task","zIndex":178}],"html":"有耗时较长的任务在summary面板会有long-task的警告","zIndex":177},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"21ac8b80-fcfd-449b-ae2c-788d69045829","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ae429901-95a3-4e64-9e98-5e06b4c0fa74","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"cd23f6b2-d3b3-4550-9066-a01fde79d301","children":[],"html":"定时器用完没有清除","zIndex":183},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6a192e9c-2fa8-4763-9c9e-1bfd9436cc99","children":[],"html":"元素从dom删除了，但是还有变量引用它","zIndex":184},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"124e233a-11d9-42f9-92d0-e0e003f588d9","children":[],"html":"闭包引用的变量不会被回收，如果引用大对象的闭包很多，也会导致内存泄漏","zIndex":185},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"878bd2d7-d770-4af0-bc7c-1fbabe753e77","children":[],"html":"全局变量","zIndex":186},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"2a590f04-f4c4-48e2-a3a1-4a8f95145294","children":[],"html":"console.log打印的变量，如果数据量大，也可能造成内心泄漏","zIndex":187}],"html":"导致内存泄漏的情况","zIndex":182},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d67693aa-d864-4a4d-8dc6-a3465ee8289e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4da68790-fce5-48e7-9a5d-b75d72feb158","children":[],"html":"在页面上做某个操作时，查看performance面板，如果内存占用HEAP值不断增长，并且手动GC也没有回落，说明发生了内存泄漏","layout":{"quadrant":1},"zIndex":189}],"html":"通过performance","zIndex":188},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ae407091-00ce-4dd9-8ee9-fc73ca980f41","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e390c313-17f1-4f73-acda-367ccb7680ab","children":[],"html":"先 GC，录制一次内存快照，再操作几次页面，然后 GC，再录制一次内存快照，拿到两次内存快照也是可以分析出有内存泄漏的","zIndex":191},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b7a101ee-86dd-40e8-b842-bba40afa6774","children":[],"html":"如果GC 后内存占用依然增长，说明存在内存泄漏","zIndex":192},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"86034ac2-5d64-4f3c-953b-9cc7358381b7","children":[],"html":"可以根据快照，找到变化的部分，定位到相关的代码","zIndex":193}],"html":"通过memory","zIndex":190}],"html":"如何排查内存泄漏","zIndex":181}],"html":"performance","zIndex":174},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a1147059-5d33-4125-91b0-d437ab55ba57","children":[],"html":"lighthouse","zIndex":194}],"html":"自己","zIndex":173},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"46e1aedf-ee66-425f-8ba8-97d169378a0e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9b82b9cd-5697-40f8-bd4a-6e54f9cca29d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"04deaeb2-43e7-4e5f-a4fa-be014620ce4e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4f3b6e7b-790b-499c-8149-5c11a50c098a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6aedcab9-1bac-4a3d-876c-dbda8443bc7c","children":[],"html":"国际上比较老牌的就是 New Relic","zIndex":199},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"45b8ecff-9545-460e-a816-d5433fd81b9b","children":[],"html":"国内的话可以直接考虑使用阿里云的 ARMS","zIndex":200}],"html":" Application Performance Monitoring（应用程序性能监控）","zIndex":198}],"html":"APM工具","zIndex":197},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"23ae5c0a-030b-422d-b1f7-50f2fdb625e7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f5530631-26e2-498c-afc5-d19e3f99fa69","children":[],"html":"<a href=\"https://github.com/wangweianger/zanePerfor\" target=\"_blank\">https://github.com/wangweianger/zanePerfor</a>","zIndex":202},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"2de99e2b-af1b-475b-9099-a27ee3f279b5","children":[],"html":"<a href=\"https://github.com/rrweb-io/rrweb\" target=\"_blank\">https://github.com/rrweb-io/rrweb</a>","zIndex":203},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6b6dc604-e06d-406f-a92f-41632ab36740","children":[],"html":"不太推荐使用开源项目自行搭建，因为数据的采集和处理都会消耗相当多的服务器资源，与成熟的产品服务相比，不管是投入的人力还是服务器运维成本都会更高","zIndex":204}],"html":"开源前端性能监控系统","zIndex":201}],"html":"工具","zIndex":196},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3518182b-9a1b-4471-a74e-cf3532c0d4ed","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"68813541-f97e-48ec-b54f-d56c1fb12e40","children":[],"html":"JavaScript SDK","zIndex":206},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"538febc1-7fe1-421e-bbdd-9582e3a55f9b","children":[],"html":"window.performance.timing","zIndex":207}],"html":"AMP工具原理","zIndex":205}],"html":"用户群","zIndex":195}],"html":"采集","zIndex":172}],"html":"建立衡量标准","collapsed":true,"zIndex":160},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"07c0e42c-1027-4d1b-a043-8f216538b9ac","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"id":"3bd2ee79-fdbf-4061-a59c-384848961026","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"adb26651-2069-4081-9295-2a15e5065cee","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"aa16950a-c47d-49ed-939e-35b1d2737903","children":[],"html":" FCP、TTI、FPS、Page Load、静态资源及 API 请求成功率等几个指标都很重要，会直接影响关键业务的转化率","zIndex":211}],"html":"toC","layout":{"quadrant":1},"zIndex":210},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b13dce83-3539-4f5a-999e-d5d6d6367d18","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"403491ff-0c1b-4e42-8011-3fab037ad350","children":[],"html":"更关注的是使用起来功能是否完整，运行是否流畅，对加载速度并没有很高的要求，所以通常只对 FPS 、静态资源及 API 请求成功率这三个指标更为关注。","zIndex":213}],"html":"管理后台","layout":{"quadrant":1},"zIndex":212}],"html":"以业务场景划分","layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"zIndex":209},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"id":"bd6d59f9-ecf2-41ff-a834-c788d5e98eb4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"5434cd82-293d-4d14-8ec9-e89cde88dcbf","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ba552ca3-3738-4719-968b-9f8526175116","children":[],"html":"比如 TP50、TP90、TP99 和 TP999 等指标，指高于 50%、90%、99% 等百分线的情况。如 TP50 就意味着，50% 的用户打开页面绘制内容的时间不超过 6 秒，90%的用户不超过 8 秒。如果要提升 FCP，那么就需要提升 TP 50、TP90、TP999 下的数据，这才是有正确方向的目标。","zIndex":216}],"html":"TP（Top Percentile）","zIndex":215},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ef066fe2-0c74-41cb-aa30-c453ba64498f","children":[],"html":"TP50","zIndex":217},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"291c00d8-8014-49a1-8ad2-388614d84e98","children":[],"html":"TP99","zIndex":218}],"html":"以用户比例划分","layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"zIndex":214}],"html":"确认优化原因","collapsed":true,"zIndex":208},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"1764bfd4-adad-4791-857e-a6931126b94a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ce47f972-a9ab-4ab3-8d5d-e6fb541c2495","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"52a9ee20-9b52-48c7-8344-6c45cf1ab4df","children":[],"html":"loading","layout":{"quadrant":1},"zIndex":221},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"eee2cf72-0bc5-4021-918f-de5d59628497","children":[],"html":"骨架屏","layout":{"quadrant":1},"zIndex":222},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"6ae6ff56-0c7b-4ba5-af5b-be198447bfc0","children":[],"html":"SSR","zIndex":223}],"html":"FCP","zIndex":220},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"41ac75b5-9c5e-4522-aa76-017c4cf11719","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"852cde01-e178-431b-94a4-82a8dafa62e0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"036797cc-7819-46ad-8668-8b1bec2e8026","children":[],"html":"优先加载让用户关注的内容，将异步加载与懒加载相结合","layout":{"quadrant":1},"zIndex":226}],"html":"优化策略","layout":{"quadrant":1},"zIndex":225},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"84f7da5b-0d36-4351-826e-bb5888df7177","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7e8721a4-a364-4cfc-ae78-793ca6279c5f","children":[],"html":"核心内容同步加载","zIndex":228},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"2d66ac3a-37b5-454d-acd9-c78e982cd2cd","children":[],"html":"非核心内容采取异步加载的方式延迟加载","zIndex":229},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3a9473bf-920b-4949-9744-1f14d48786eb","children":[],"html":"内容中的图片采用懒加载的方式避免占用网络资源。","zIndex":230}],"html":"优化方案","zIndex":227}],"html":"TTI","zIndex":224},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c0bb3a72-cf63-425e-a124-d8041685c528","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7a619635-f64e-440a-954f-00786b5d28fa","children":[],"html":"Webpack打包commonChunk与异步组件","zIndex":232}],"html":"Page Load","zIndex":231},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4d964058-fe90-4674-8731-25bf8913d82c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f21d8da7-f295-4f04-bdab-3899d821df9e","children":[],"html":"FPS 主要代表了卡顿的情况，在 React 中引起卡顿的主要原因有长列表与重渲染","layout":{"quadrant":1},"zIndex":234},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"2a5d0547-195a-4274-8a30-f88390316651","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7d4f5fac-cc52-4fe4-8fa4-5e7acc8ac1a5","children":[],"html":"react-virtualized 或者 react-window&nbsp;","zIndex":236},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"da440e74-a75e-4f99-b934-92c699da8e4a","children":[],"html":"避免react组件频繁重渲染","zIndex":237}],"html":"优化方案","zIndex":235}],"html":"FPS","zIndex":233},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f6335463-75da-4572-ad70-d7ef1948768a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a21f4fa1-2279-4ff3-b177-65e99e71c56c","children":[],"html":"对于静态资源而言，尽量用CDN，可以大幅提升静态资源的成功率","layout":{"quadrant":1},"zIndex":239},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b5be99d2-bed0-420d-af13-aba73321b9bf","children":[],"html":"如果域名解析失败，就可以采取静态资源域名自动切换的方案；还有一个简单的方案是直接寻求 SRE 的协助。","zIndex":240},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d5354905-a72d-4411-b0e6-8a6dff1d90f8","children":[],"html":"如果有运营商对内容做了篡改，我推荐使用 HTTPS","zIndex":241}],"html":"静态资源及API 请求成功率","zIndex":238}],"html":"实施方案过程","collapsed":true,"zIndex":219},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"1f9ca317-c0bd-44a7-a075-72c5c855e4a5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a5565edb-2bfc-45a3-9a82-abf4131139e3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ee4ac27d-aed3-4a29-a71d-0eaaa55edc76","children":[],"html":"技术服务于业务","zIndex":244},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e17fe7dd-320c-4349-a0a9-baf5261f3d46","children":[],"html":"业务目标指导优化","zIndex":245}],"html":"数据","zIndex":243},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"cece2cd2-8e26-458c-9b68-b67f3c837c7e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"356d056d-fd70-4159-8b5d-fe8722034b38","children":[],"html":"TP50","zIndex":247},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"042d9173-e454-4da6-b6a4-7baa6fc2d2f9","children":[],"html":"TP99","zIndex":248}],"html":"效果","zIndex":246}],"html":"计算收益结果","collapsed":true,"zIndex":242},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"e6b962dc-c587-42ff-9767-a8ca56b0ce32","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1ff8a59c-ad92-4de3-8dae-ed6fbcfabb67","children":[],"html":"我负责的业务是 CRM 管理后台，用户付费进入操作使用，有一套非常标准的业务流程。在我做完性能优化后，整个<span style=\"font-weight:bold;\">付费率一下提升了 17%</span>，效果还可以。<div>前期管理后台的基础性能数据是没有的，我接手后接入了一套<span style=\"font-weight:bold;\"> APM 工具</span>，才有了基础的性能数据。然后我对指标观察了一周多，思考了业务形态，发现其实用户对后台系统的加载速度要求并不高，但对<span style=\"font-weight:bold;\">系统的稳定性</span>要求比较高。我也发现<span style=\"font-weight:bold;\">静态资源的加载成功率并不高，TP99 的成功率大约在 91%</span>，这是因为静态资源直接从服务器拉取，<span style=\"font-weight:bold;\">服务器带宽形成了瓶颈，导致加载失败</span>。我对 <span style=\"font-weight:bold;\">Webpack 的构建工作流做了改造，支持发布到 CDN</span>，改造后 TP99 提升到了 99.9%。</div>","zIndex":250}],"html":"面试回答模板","zIndex":249}],"html":"调优","collapsed":true,"zIndex":4},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E9F7E9","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#77C386"},"id":"565e4090-507c-4c1d-8fbe-748927b60ddd","children":[{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"27d95040-2575-4b88-b3b2-f2d8457c552f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"19ba027b-2df9-4893-8e3b-ee2e4edfe98d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"40d43327-43b4-474e-934e-470e564f2cac","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fb256400-5f0f-4488-bba6-304befb35591","children":[],"html":"&lt;img class=\"pic\" alt=\"加载中\" data-src=\"./images/1.png\"&gt;","zIndex":254}],"html":"图片&lt;img&gt;标签先不设置src属性，将图片url放在data-src属性中","zIndex":253},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"89e088ae-5e93-421c-95f8-1ad9d30de417","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c6051f2b-acbc-4e28-bdf4-bda0f7f50ba8","children":[],"html":"可视区域高度：const viewHeight = window.innerHeight || document.documentElement.clientHeight","zIndex":256},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1b3e5c21-ff58-4b06-a6e1-05c9e29687f2","children":[],"html":"判断元素露出：viewHeight - imgs[i].getBoundingClientRect().top &gt; 0","zIndex":257}],"html":"监听滚动事件，判断图片是否出现中当前可视区域内，如果出现的话就将data-src中的数据赋值给src属性","layout":{"quadrant":1},"zIndex":255}],"html":"原理","zIndex":252}],"html":"懒加载","collapsed":true,"zIndex":251},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"885a46f2-e7b5-422a-a28a-02ea7c0a474d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"2bd452d5-ce74-46f3-abb7-470bb9599772","children":[],"html":"防抖节流都运用的闭包思想。它们是通过对事件对应的回调函数进行包裹，以自由变量的形式缓存时间信息，最后用setTimeout来控制事件的触发频率。","zIndex":259},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8a60bc1d-c5fe-4a45-8b65-e51121c7be5c","children":[],"html":"防抖 debounce：事件触发n秒后再执行回调，如果n秒内被触发，就重新开始计时。可以用在点击按钮请求的场景，避免发出多次请求。","zIndex":260},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5eab851e-6b9d-44c9-a4e6-89f143171ae7","children":[],"html":"节流 throttle：事件在单位时间内，会以第一次被触发的时间为准开始计时，无论被触发多少次，在单位时间内都只能被执行一次。可以用在scroll事件监听上，降低事件被触发的频率。","zIndex":261}],"html":"防抖节流","collapsed":true,"zIndex":258},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"189c03cb-3b0f-4e3f-9b90-803f265c8912","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"857237d4-7af3-4671-a72b-64507bde93ac","children":[],"html":"如果你的列表中有大量的图片，用<span style=\"font-weight:bold;\">时间分片</span>更合理，否则大量的图片反复的进行解码渲染会更卡顿。如果你只是纯文本那么用<span style=\"font-weight:bold;\">虚拟列表</span>体验会更好，起码滚动条不会一直抖","layout":{"quadrant":1},"zIndex":263},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7d383675-1968-4f68-9571-2115217ceb50","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6df0b8ea-5c1d-4472-86ea-cacb296ae593","children":[],"html":"把大数据量切割成很多个小数据组依次渲染，执行完一组再执行下一组数据，其思想是建立一个队列，通过定时器/requestAnimationFrame来进行渲染，执行完的出队，直到全部执行完毕，渲染队列清空。","zIndex":265},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1c31297f-78e9-4b70-89c4-ee2cd192c1aa","children":[],"html":"缺点：会将所有的数据渲染成dom节点展示在页面上，但实际上用户并不需要一次性查看这么多数据，而且回流和重绘的开销也会越来越大，懒加载的实现也是同理","zIndex":266}],"html":"分片渲染","zIndex":264},{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"df984b35-b5ca-4a92-a185-cb7e364ad6d6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"178c3e8e-88f5-4f13-a64b-e50349a0a85a","children":[],"html":"在可视窗口维护一个列表，可视窗口上下都会有个缓存区域，真实dom只会在可视窗口和上下缓存区存在","zIndex":268},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ab363f28-fe5a-4b18-8b7b-d55bc24cd4e7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2d4d8356-24c8-4618-8fce-7b29a6172e25","children":[],"html":"不把长列表数据一次性全部直接渲染在页面上","zIndex":270},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ecf8b432-1d26-47af-8c8f-cfae31633c23","children":[],"html":"截取长列表一部分数据用来填充可视区域","zIndex":271},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d6424779-d3dd-44c1-99c8-d1bd6fea70f0","children":[],"html":"长列表数据不可视部分使用空白占位填充","zIndex":272},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a43f42d4-f653-4a6b-a418-3949f68c48db","children":[],"html":"监听滚动事件根据滚动位置动态改变可视列表","zIndex":273},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"11f57c7d-2b73-465a-ab4c-07ffdc6d2765","children":[],"html":"监听滚动事件根据滚动位置动态改变空白填充","zIndex":274}],"html":"原理","zIndex":269},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"57119a25-b190-42e6-9369-c4d5ad5c0784","children":[],"html":"TODO：vue-infinite-scroll的源码","zIndex":275}],"html":"虚拟列表","layout":{"quadrant":1},"zIndex":267},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b7c02406-a139-4824-9f18-85045309e60e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f9ae5cbc-9740-45dd-91e5-63c89ddd6dc2","children":[],"html":"浏览器会在空闲时间执行回调，适合优先级不高、不操作dom、执行时间可预测的任务","zIndex":277},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"59d78bed-a102-4068-9d7a-87e3e65ce61f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"97676a45-7153-4609-96f1-8d3ca29db604","children":[],"html":"适用于非高优先级任务","zIndex":279},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c8eb96ea-96d6-4edd-b9d4-526a151a7d3c","children":[],"html":"尽可能不超支分配到的时间，50ms","zIndex":280},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e414fd96-f31f-4a42-b4bf-051c4c3dc8ed","children":[],"html":"避免在空闲回调中改变 DOM，如果需要改变，使用requestAnimationFrame","zIndex":281},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f1b86ee5-1c74-4e88-b659-41000605617c","children":[],"html":"避免运行时间无法预测的任务，比如Promise任务，为了保证任务按时执行，可以配置timeout参数","zIndex":282}],"html":"注意点","zIndex":278}],"html":"requestIdleCallback","zIndex":276}],"html":"大数据量渲染","layout":{"quadrant":1},"collapsed":true,"zIndex":262},{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"f828034f-6a36-4bca-bb9c-fc5f4f589599","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d9200e94-629f-4598-bc77-9a1e388a2840","children":[],"html":"TODO","zIndex":284}],"html":"大文件上传下载","zIndex":283},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"90c06030-7f99-4f31-a8dd-f471a55b2f4a","children":[],"html":"Web Worker","zIndex":285},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"20018ecc-350a-41bb-882c-3109c41fe85b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"ff2d5f98-ceb6-4f7d-9aa8-3d458cc6caef","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b6664c39-65be-42e7-9203-ddf9c2b5d52b","children":[],"html":"当React组件的state或者props变化时，从通过diff算法对比新的vdom树和旧的fiber树，去生成新的fiber树，这个就是协调的过程。","zIndex":288},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"12902769-5b4d-4184-845f-bdc27a77dfc2","children":[],"html":"如果一次性引发的重新渲染层级足够多、足够深，会带来额外的性能负担","zIndex":289}],"html":"原理分析","zIndex":287},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d6516e69-f35e-46d2-b5bd-eba3b071e557","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e2c8092d-24c6-4f19-a4c2-505aa0c1a8a2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f74de32e-3e87-4fad-aa6e-0b0bbe0045f1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"21286bd4-5e5f-4efe-bef4-815c63f21a1d","children":[],"html":"一般 50 ~ 60 FPS，就相当流畅了；","zIndex":293},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"372ab27c-5bfa-4fea-88fe-184cbe736344","children":[],"html":"在 30 ~ 50 FPS 之间就因人而异了，通常属于尚可接受的范畴；","zIndex":294},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1138ba2d-815b-4c75-884d-2fb79360ffc4","children":[],"html":"在 30 FPS 以下属于有明显卡顿，会令人不适。","zIndex":295}],"html":"FPS","zIndex":292},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e8ad10aa-45ff-417c-b6e5-dff3a8b47f53","children":[],"html":"需要调查客观运行环境的情况，比如浏览器与运行设备等","zIndex":296}],"html":"业务标准","zIndex":291},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"462de0ea-7fe5-400d-92e3-34429e53bcc7","children":[],"html":"数据支撑","zIndex":297}],"html":"优化时机","zIndex":290},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"88bf2fc4-eec1-405b-af1e-7fe0b22e0901","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ed7fd7f7-807f-497c-a838-eb2ee75b0da3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1aded531-6bcb-4290-95a1-2f5567e84b30","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"976266aa-93c8-49af-8fdc-ae2162546214","children":[],"html":"寻找运行该页面的设备机型与浏览器版本，确保能在相同环境下复现","zIndex":301},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c31fe52c-461d-4f43-b570-df7af0c1f145","children":[],"html":"增加埋点日志，采集更多的数据","zIndex":302}],"html":"不能复现","zIndex":300}],"html":"复现","zIndex":299},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"23f62100-6df8-4daa-9a6b-ff8c0042e4a0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f7b26b0d-198a-457e-a747-4ab5c1fa5810","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9f6de307-aa2d-4c9c-b094-e168927d9775","children":[],"html":"主要用于查询 JavaScript 执行栈中的耗时，确认函数卡顿点","zIndex":305}],"html":"Performance","zIndex":304},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"995c278c-c84c-43ff-ab2e-ca34234cc336","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d3f39b37-c586-4355-9244-3752dbb0c727","children":[],"html":"通过 React Developer Tools 中的 Profiler 分析组件渲染次数、开始时间及耗时","zIndex":307}],"html":"React Profiler","zIndex":306}],"html":"工具","zIndex":303}],"html":"定位方式","zIndex":298},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a8e5705e-99da-421f-a5b6-4f911d691893","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fd6ea91b-d919-453d-b4da-c0501f53385e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4c2b7690-ddf1-4fc8-ae1e-2d207a533be7","children":[],"html":"父组件给子组件传递的参数是一个计算得到的数据，或者一个箭头函数，那么每次render都会重新生成，造成子组件重新渲染。","zIndex":310}],"html":"参数动态变化","zIndex":309}],"html":"常见的坑","zIndex":308},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6904863f-5f97-4a8d-a4be-18dfdc6312cd","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bd4f0e95-7a6d-4e32-a3f6-9e19b5108a7c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8d2bc85c-7c8c-4c90-a6a0-60fbfe2bccdf","children":[],"html":"reselect","zIndex":313}],"html":"缓存","zIndex":312},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b0189f5e-d330-4461-8e0a-94ac58b5374b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7be5a112-3a06-46ae-b503-c51f0c3b418d","children":[],"html":"immerjs","zIndex":315}],"html":"不可变数据","zIndex":314},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"98a55368-c5f8-4a91-9ad3-2be21ffa39e2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"426805bb-3323-4a24-ac26-4b6e92d610da","children":[],"html":"React.memo + useCallback + useMemo","zIndex":317}],"html":"手动控制","zIndex":316}],"html":"处理方案","zIndex":311}],"html":"避免React重复渲染","collapsed":true,"zIndex":286}],"html":"应用","collapsed":true,"zIndex":2},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#E8EEFC","stroke":"transparent"},"id":"f0f31db4-145e-4cec-b14b-d64dca7a91a5","children":[{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"f0f9301d-2fa9-47dd-be26-ccdde45f2122","children":[],"html":"SSP官网","zIndex":318},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7ead9c02-28a0-432e-ad12-19aaca10c819","children":[],"html":"Nextjs H5","zIndex":319}],"html":"实践","treeEdge":{"stroke":"#6F81DB","stroke-width":2},"collapsed":true,"zIndex":0}],"layout":{"type":"standard","direction":[1,0]},"zIndex":6}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[407.8896484375,-33.74757385253906,1],"width":1601,"height":949},"viewportOption":"adapt","text":"性能优化用户体验衡量指标页面加载时长当用户请求一个网站时，如果在 1 秒内看不到关键内容，用户会产生任务被中断的感觉。用户交互反馈时长当用户点击某些按钮时，如果 100ms 内无法响应，用户会感受到延迟。Web 动画中的帧数如果 Web 中的动画没有达到 60fps，用户会感受到动画的卡顿。网络DNS prefetchDNS prefetch 是一种浏览器机制，可以在浏览器空闲时预先解析网页中的域名，以提前获取域名对应的 IP 地址，从而加速后续的页面加载过程。通常情况下，浏览器会自动执行 DNS prefetch，但也可以通过 HTML 的 <link> 元素手动指定需要预取的域名。HTTP优化方向减少请求花费的时间资源压缩压缩CSS、JS、图片Gzip原理是在一个文本文件中找出一些重复出现的字符串、临时替换它们，从而使整个文件变小Webpack的GzipWebpack的 Gzip 是为了在构建过程中去做一部分服务器的工作，为服务器分压服务端的Gzip服务器会启用自己的CPU去完成Gzip，以服务器压缩的时间开销和 CPU 开销（以及浏览器解析压缩文件的开销）为代价，省下了一些传输过程中的时间开销Gzip的压缩级别可以调整，压缩率越高，压缩速度越慢。对于静态资源文件，通常可以使用较高的压缩级别，而对于动态生成的内容，可能需要权衡压缩率和服务器性能。资源拆分入口点分割，配置多个entry分包配置提取公共第三方库删除冗余代码清除无用的CSSpurgecss-webpack-pluginTree Shaking避免babel辅助代码重复引入@babel/plugin-transform-runtime按需加载Suspence + React.lazy静态资源存放CDNCDNCDN （Content Delivery Network，即内容分发网络）指的是一组分布在各个地区的服务器。这些服务器存储着数据的副本，因此服务器可以根据哪些服务器与用户距离最近，来满足数据的请求。 CDN 提供快速服务，较少受高流量影响。核心点缓存我们把资源 copy 一份到 CDN 服务器上这个过程回源CDN 发现自己没有这个资源（一般是缓存的数据过期了），转头向根服务器（或者它的上层服务器）去要这个资源的过程如何使用CDN优化CDN 往往被用来存放静态资源，是加载静态资源提速的重要手段静态资源就是像 JS、CSS、图片等不需要业务服务器进行计算即得的资源。非纯静态资源它是指需要服务器在页面之外作额外计算的 HTML 页面。具体来说，当我打开某一网站之前，该网站需要通过权限认证等一系列手段确认我的身份、进而决定是否要把 HTML 页面呈现给我。这种情况下 HTML 确实是静态的，但它和业务服务器的操作耦合，我们把它丢到CDN 上显然是不合适的。减少网络请求次数HTTP缓存强缓存ExpiresCache-Control通过max-age控制资源有效期public 与 private：针对资源是否能够被代理服务缓存而存在的一组对立概念no-cache 绕开了浏览器，进入协商缓存流程no-store 不使用缓存优先级更高，浏览器再次请求资源时，会根据expires和cache-control判断目标资源是否命中强缓存，命中就直接从缓存中获取，不再请求服务端，HTTP状态码为200协商缓存协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304Last-Modified Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回：Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值：If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。缺点我们编辑了文件，但文件的内容没有改变。服务端并不清楚我们是否真正改变了文件，它仍然通过最后编辑时间进行判断。因此这个资源在再次被请求时，会被当做新资源，进而引发一次完整的响应——不该重新请求的时候，也会重新请求。当我们修改文件的速度过快时（比如花了 100ms 完成了改动），由于 If-Modified-Since 只能检查到以秒为最小计量单位的时间差，所以它是感知不到这个改动的——该重新请求的时候，反而没有重新请求了。EtagEtag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的当首次请求时，我们会在响应头里获取到一个最初的标识符字符串 ETag: W/\"2a3b-1602480f459\"那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了：If-None-Match: W/\"2a3b-1602480f459\"Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。因此启用 Etag 需要我们审时度势。正如我们刚刚所提到的——Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。缓存决策当我们的资源内容不可复用时，直接为 Cache-Control 设置 no-store否则考虑是否每次都需要向服务器进行缓存有效确认，如果需要，那么设 Cache-Control 的值为 no-cache否则考虑该资源是否可以被代理服务器缓存，根据其结果决定是设置为 private 还是 public；然后考虑该资源的过期时间，设置对应的 max-age 和 s-maxage 值；最后，配置协商缓存需要用到的 Etag、Last-Modified 等参数。缓存位置MemoryCache内存中的缓存，优先级最高，响应最快，有效期最短Service Worker CacheService Worker 是一种独立于主线程之外的 Javascript 线程。它脱离于浏览器窗体，因此无法直接访问 DOM。可以帮我们实现离线缓存、消息推送和网络代理等功能。Service Worker 的生命周期包括 install、active、working 三个阶段。一旦 Service Worker 被 install，它将始终存在，只会在 active 与 working 之间切换，除非我们主动终止它。这是它可以用来实现离线存储的重要先决条件。如何实现离线缓存serviceWorker注册一段js代码window.navigator.serviceWorker.register('/test.js').then(   function () {      console.log('注册成功')    }).catch(err => {      console.error(\"注册失败\")    })在js中实现缓存逻辑Service Worker会监听 install事件，我们在其对应的回调里可以实现初始化的逻辑  Service Worker会监听所有的网络请求，网络请求的产生触发的是fetch事件，我们可以在其对应的监听函数中实现对请求的拦截，进而判断是否有对应到该请求的缓存，实现从Service Worker中取到缓存的目的Server Worker 对协议是有要求的，必须以 https 协议为前提Push CachePush Cache 是指 HTTP2 在 server push 阶段存在的缓存Push Cache 是缓存的最后一道防线。浏览器只有在 Memory Cache、HTTP Cache 和 Service Worker Cache 均未命中的情况下才会去询问 Push Cache。Push Cache 是一种存在于会话阶段的缓存，当 session 终止时，缓存也随之释放。不同的页面只要共享了同一个 HTTP2 连接，那么它们就可以共享同一个 Push Cache。本地存储cookieWeb StorageindexedDB资源的压缩与合并->通过构建工具Webpack来实现渲染浏览器渲染过程解析HTML在这一步浏览器执行了所有的加载解析逻辑，在解析 HTML 的过程中发出了页面渲染所需的各种外部资源请求。计算样式浏览器将识别并加载所有的 CSS 样式信息与 DOM 树合并，最终生成页面 render 树（:after :before 这样的伪元素会在这个环节被构建到 DOM 树中）。计算图层布局页面中所有元素的相对位置信息，大小等信息均在这一步得到计算。绘制图层在这一步中浏览器会根据我们的 DOM 代码结果，把每一个页面图层转换为像素，并对所有的媒体文件进行解码。整合图层，得到页面最后一步浏览器会合并合各个图层，将数据由 CPU 输出给 GPU 最终绘制在屏幕上。（复杂的视图层会给这个阶段的 GPU 计算带来一些压力，在实际应用中为了优化动画性能，我们有时会手动区分不同的图层）。CSS优化每当一个新元素加入到这个 DOM 树当中，浏览器便会通过 CSS 引擎查遍 CSS 样式表，找到符合该元素的样式规则应用到这个元素上，然后再重新去绘制它性能提升方案CSS选择器使用CSS选择符是从右到左进行匹配的避免使用通配符，只对需要用到的元素进行选择。关注可以通过继承实现的属性，避免重复匹配重复定义。少用标签选择器。如果可以，用类选择器替代不要画蛇添足，id 和 class 选择器不应该被多余的标签选择器拖后腿。.myList#title -> #title减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最高不要超过三层），尽可能使用类来关联每一个标签元素。CSS加载CSS 是阻塞渲染的资源。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。尽早：将 CSS 放在 head 标签里尽快：启用 CDN 实现静态资源加载速度的优化JS优化使用async或defer的方式，让JS的下载变成异步的。当我们的脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。Dom 优化为什么DOM操作慢操作DOM实际上是JS引擎和渲染引擎通过桥接接口(Web API)通信，过桥要收费，无论是修改DOM还是仅仅访问DOM值，都存在性能损耗。会触发渲染树变化，导致回流和重绘如何减少DOM操作使用DOM Fragment作为容器完成内容处理，再一次性进行内容更新基于事件循环的异步更新优化在异步任务里进行DOM更新，需要包装成微任务，可以减少一次不必要的渲染，也不需要等到下一轮事件循环再生效生产实践Vue 和 React 的批量异步更新策略多次 setState，在JS层面会先执行完毕，而真正渲染的时候，只会做一次DOM操作nextTickVue 中每产生一个状态更新任务，它就会被塞进一个叫 callbacks 的数组（此处是任务队列的实现形式）中。这个任务队列在被丢进 micro 或 macro 队列之前，会先去检查当前是否有异步更新任务正在执行（即检查 pending 锁）。如果确认 pending 锁是开着的（false），就把它设置为锁上（true），然后对当前 callbacks 数组的任务进行派发（丢进 micro 或 macro 队列）和执行。设置 pending 锁的意义在于保证状态更新任务的有序进行，避免发生混乱。重绘和回流优化重绘修改DOM的样式，不影响几何属性回流改变DOM几何属性、改变DOM树结构、访问宽高距离等需要即时计算得到的属性值如何避免避免频繁操作样式，通过类名替换一次性修改多个样式使用CSS3动画或者变换，利用GPU加速，减少重绘和回来DOM离线化利用浏览器渲染队列机制利用渲染分层实现合成优化调优建立衡量标准指标FCP首次绘制内容的耗时。首屏统计的方式一直在变，起初是通过记录 window.performance.timing 中的 domComplete 与 domLoading 的时间差来完成，但这并不具备交互意义，现在通常是记录初次加载并绘制内容的时间。TTI是页面可交互的时间。通常通过记录 window.performance.timing 中的 domInteractive 与 fetchStart 的时间差来完成。Page Load页面完全加载时间。通常通过记录 window.performance.timing 中的 loadEventStart 与 fetchStart 的时间差来完成。FPS前端页面帧率，1秒内画面更新的次数。通常是在主线程打点完成记录。其原理是 requestAnimationFrame 会在页面重绘前被调用，而 FPS 就是计算两次之间的时间差。静态资源及API 请求成功率通常是通过 window.performance.getEntries( ) 来获取相关信息采集自己performancePerformance 工具最重要的是分析主线程的 Event Loop，分析每个 Task 的耗时、调用栈等信息当你点击某个宏任务的时候，在下面的面板会显示调用栈的详情（选择 bottom-up 是列表展示， call tree 是树形展示）有耗时较长的任务在summary面板会有long-task的警告解决long taskfiber架构：拆分task开启web worker，把复杂计算放在worker里如何排查内存泄漏导致内存泄漏的情况定时器用完没有清除元素从dom删除了，但是还有变量引用它闭包引用的变量不会被回收，如果引用大对象的闭包很多，也会导致内存泄漏全局变量console.log打印的变量，如果数据量大，也可能造成内心泄漏通过performance在页面上做某个操作时，查看performance面板，如果内存占用HEAP值不断增长，并且手动GC也没有回落，说明发生了内存泄漏通过memory先 GC，录制一次内存快照，再操作几次页面，然后 GC，再录制一次内存快照，拿到两次内存快照也是可以分析出有内存泄漏的如果GC 后内存占用依然增长，说明存在内存泄漏可以根据快照，找到变化的部分，定位到相关的代码lighthouse用户群工具APM工具Application Performance Monitoring（应用程序性能监控）国际上比较老牌的就是 New Relic国内的话可以直接考虑使用阿里云的 ARMS开源前端性能监控系统https://github.com/wangweianger/zanePerforhttps://github.com/rrweb-io/rrweb不太推荐使用开源项目自行搭建，因为数据的采集和处理都会消耗相当多的服务器资源，与成熟的产品服务相比，不管是投入的人力还是服务器运维成本都会更高AMP工具原理JavaScript SDKwindow.performance.timing确认优化原因以业务场景划分toCFCP、TTI、FPS、Page Load、静态资源及 API 请求成功率等几个指标都很重要，会直接影响关键业务的转化率管理后台更关注的是使用起来功能是否完整，运行是否流畅，对加载速度并没有很高的要求，所以通常只对 FPS 、静态资源及 API 请求成功率这三个指标更为关注。以用户比例划分TP（Top Percentile）比如 TP50、TP90、TP99 和 TP999 等指标，指高于 50%、90%、99% 等百分线的情况。如 TP50 就意味着，50% 的用户打开页面绘制内容的时间不超过 6 秒，90%的用户不超过 8 秒。如果要提升 FCP，那么就需要提升 TP 50、TP90、TP999 下的数据，这才是有正确方向的目标。TP50TP99实施方案过程FCPloading骨架屏SSRTTI优化策略优先加载让用户关注的内容，将异步加载与懒加载相结合优化方案核心内容同步加载非核心内容采取异步加载的方式延迟加载内容中的图片采用懒加载的方式避免占用网络资源。Page LoadWebpack打包commonChunk与异步组件FPSFPS 主要代表了卡顿的情况，在 React 中引起卡顿的主要原因有长列表与重渲染优化方案react-virtualized 或者 react-window 避免react组件频繁重渲染静态资源及API 请求成功率对于静态资源而言，尽量用CDN，可以大幅提升静态资源的成功率如果域名解析失败，就可以采取静态资源域名自动切换的方案；还有一个简单的方案是直接寻求 SRE 的协助。如果有运营商对内容做了篡改，我推荐使用 HTTPS计算收益结果数据技术服务于业务业务目标指导优化效果TP50TP99面试回答模板我负责的业务是 CRM 管理后台，用户付费进入操作使用，有一套非常标准的业务流程。在我做完性能优化后，整个付费率一下提升了 17%，效果还可以。前期管理后台的基础性能数据是没有的，我接手后接入了一套 APM 工具，才有了基础的性能数据。然后我对指标观察了一周多，思考了业务形态，发现其实用户对后台系统的加载速度要求并不高，但对系统的稳定性要求比较高。我也发现静态资源的加载成功率并不高，TP99 的成功率大约在 91%，这是因为静态资源直接从服务器拉取，服务器带宽形成了瓶颈，导致加载失败。我对 Webpack 的构建工作流做了改造，支持发布到 CDN，改造后 TP99 提升到了 99.9%。应用懒加载原理图片<img>标签先不设置src属性，将图片url放在data-src属性中<img class=\"pic\" alt=\"加载中\" data-src=\"./images/1.png\">监听滚动事件，判断图片是否出现中当前可视区域内，如果出现的话就将data-src中的数据赋值给src属性可视区域高度：const viewHeight = window.innerHeight || document.documentElement.clientHeight判断元素露出：viewHeight - imgs[i].getBoundingClientRect().top > 0防抖节流防抖节流都运用的闭包思想。它们是通过对事件对应的回调函数进行包裹，以自由变量的形式缓存时间信息，最后用setTimeout来控制事件的触发频率。防抖 debounce：事件触发n秒后再执行回调，如果n秒内被触发，就重新开始计时。可以用在点击按钮请求的场景，避免发出多次请求。节流 throttle：事件在单位时间内，会以第一次被触发的时间为准开始计时，无论被触发多少次，在单位时间内都只能被执行一次。可以用在scroll事件监听上，降低事件被触发的频率。大数据量渲染如果你的列表中有大量的图片，用时间分片更合理，否则大量的图片反复的进行解码渲染会更卡顿。如果你只是纯文本那么用虚拟列表体验会更好，起码滚动条不会一直抖分片渲染把大数据量切割成很多个小数据组依次渲染，执行完一组再执行下一组数据，其思想是建立一个队列，通过定时器/requestAnimationFrame来进行渲染，执行完的出队，直到全部执行完毕，渲染队列清空。缺点：会将所有的数据渲染成dom节点展示在页面上，但实际上用户并不需要一次性查看这么多数据，而且回流和重绘的开销也会越来越大，懒加载的实现也是同理虚拟列表在可视窗口维护一个列表，可视窗口上下都会有个缓存区域，真实dom只会在可视窗口和上下缓存区存在原理不把长列表数据一次性全部直接渲染在页面上截取长列表一部分数据用来填充可视区域长列表数据不可视部分使用空白占位填充监听滚动事件根据滚动位置动态改变可视列表监听滚动事件根据滚动位置动态改变空白填充TODO：vue-infinite-scroll的源码requestIdleCallback浏览器会在空闲时间执行回调，适合优先级不高、不操作dom、执行时间可预测的任务注意点适用于非高优先级任务尽可能不超支分配到的时间，50ms避免在空闲回调中改变 DOM，如果需要改变，使用requestAnimationFrame避免运行时间无法预测的任务，比如Promise任务，为了保证任务按时执行，可以配置timeout参数大文件上传下载TODOWeb Worker避免React重复渲染原理分析当React组件的state或者props变化时，从通过diff算法对比新的vdom树和旧的fiber树，去生成新的fiber树，这个就是协调的过程。如果一次性引发的重新渲染层级足够多、足够深，会带来额外的性能负担优化时机业务标准FPS一般 50 ~ 60 FPS，就相当流畅了；在 30 ~ 50 FPS 之间就因人而异了，通常属于尚可接受的范畴；在 30 FPS 以下属于有明显卡顿，会令人不适。需要调查客观运行环境的情况，比如浏览器与运行设备等数据支撑定位方式复现不能复现寻找运行该页面的设备机型与浏览器版本，确保能在相同环境下复现增加埋点日志，采集更多的数据工具Performance主要用于查询 JavaScript 执行栈中的耗时，确认函数卡顿点React Profiler通过 React Developer Tools 中的 Profiler 分析组件渲染次数、开始时间及耗时常见的坑参数动态变化父组件给子组件传递的参数是一个计算得到的数据，或者一个箭头函数，那么每次render都会重新生成，造成子组件重新渲染。处理方案缓存reselect不可变数据immerjs手动控制React.memo + useCallback + useMemo实践SSP官网Nextjs H5","graphicsBBox":{"x":890.3662109375,"y":202.25241088867188,"width":328.046875,"height":342.0000305175781}}