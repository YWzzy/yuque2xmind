{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#fae6e6"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"428d0137-3991-4f03-982b-1f401e0bafc7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"a398cdcf-6dd7-4061-824a-1f499450f5ac","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"881a7d83-6a1e-4f0d-8b1c-3ed2c875f868","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7825e156-e106-441a-9f7e-07f83e2de186","children":[],"html":"模块化是一种重要的前端工程化思想，是指将代码拆分成多个独立的，可复用的模块，每个模块有特定的功能和职责，可以提高代码的可维护性、复用性和开发效率。","layout":{"quadrant":1},"zIndex":7}],"html":"概念","zIndex":8},{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"df0b4c84-cbab-4dd0-9454-025ba95c85a2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"caf90f86-3f15-4d9a-b722-ef98bd587512","children":[],"html":"模块是一个实现特点功能的文件或代码块。每个模块都有自己的作用域和命名空间，可以避免变量污染和命名冲突。","zIndex":13},{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"30239e68-c789-4350-9f35-db9f5784e3e3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"674344f6-0cd2-4bb0-a789-f8753cf64259","children":[],"html":"导入","zIndex":10},{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"da042d1b-123a-45fc-9d03-5eca93376e3d","children":[],"html":"代码：模块的实际代码","zIndex":11},{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"860d4136-31e6-49a2-8ef6-b92356519e89","children":[],"html":"导出","zIndex":9}],"html":"JS模块包含三个部分","zIndex":12}],"html":"模式","zIndex":14},{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4a6a60c6-74f8-432e-89f0-b2af9a0fbc54","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7cbde667-82d4-45bd-b69f-cfff32cf96a9","children":[],"html":"模块化的规范包括：IIFE、AMD、CMD、UMD、CommonJS、ES6 Module等。","zIndex":5}],"html":"类型","zIndex":6}],"html":"模块概述","zIndex":15},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"0177a9e4-2ff7-4fcc-a730-8813da2a34a1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"907a00bc-1233-4679-aba0-b74ff3a19717","children":[],"html":"通过匿名自执行函数，创建一个局部范围来访问变量，避免全局变量污染","zIndex":22},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2560df78-b5a9-4d87-a395-b5511e78e7d7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a3c98846-2cc6-46df-af37-d68a09d3b690","children":[],"html":"模块数量较多时会产生命名冲突","zIndex":17},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0b637066-54c0-4c74-871f-60f0c09e69de","children":[],"html":"不利于模块化管理：需要手动管理模块之间依赖关系和加载顺序","zIndex":19},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dc20f857-d059-40e6-a039-2a75262ca53a","children":[],"html":"耦合度高：模块直接的依赖关系通常通过全局变量来传递，导致模块之间耦合度高","zIndex":20},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"91c7d615-a0af-4179-9be0-86dd0e6a74c1","children":[],"html":"性能问题：每个IIFE会创建一个新的作用域，并且在运行时执行其中代码，可能增加内存消耗和运行时开销","zIndex":18},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"94eb6abf-4125-499a-9d76-cc618f5cc7c1","children":[],"html":"难以复用","zIndex":16}],"html":"缺点","zIndex":21}],"html":"IIFE","zIndex":23},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"8c866f31-9595-4fd3-b250-e79c7a8aeacc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"edd202bf-6589-4d1f-a749-3541faacacb7","children":[],"html":"Node.js 采用的模块化规范，浏览器不支持。","zIndex":31},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dd01f9d8-4bd9-44fc-a00d-17c27f003397","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"70b3145e-50f5-49a6-af4b-6bce3aa32358","children":[],"html":"同步加载模块：由于 Node.js 主要运行在服务端，而所需加载的模块文件一般保存在本地硬盘，所以加载比较快，而无需考虑使用异步的方式；","icons":{"priority":0},"zIndex":37},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"386142a9-a554-43ba-900d-4205ce1b2e35","children":[],"html":"文件即模块，文件内所有代码都运行在独立的作用域，因此不会污染全局空间；","icons":{"priority":1},"zIndex":39},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3965c7f2-58d2-4477-8c2a-5a53dfdbe2c9","children":[],"html":"模块可以被多次引用、加载。第一次被加载时，<span style=\"font-weight:bold;\">会被缓存</span>，之后都从缓存中直接读取结果。","icons":{"priority":2},"layout":{"quadrant":1},"zIndex":38},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"489c98e2-cd31-4000-9e1d-e4b7bcc5f15a","children":[],"html":"加载某个模块，就是引入该模块的 module.exports 属性，该属性<span style=\"font-weight:bold;\">输出的是值拷贝</span>，一旦这个值被输出，模块内再发生变化不会影响到输出的值。","icons":{"priority":3},"zIndex":36},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"adc73bcf-c3de-46a1-a091-facb3440431d","children":[],"html":"模块加载顺序按照代码引入的顺序。","icons":{"priority":4},"zIndex":35}],"html":"特点","zIndex":40},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7d6ca196-ebd4-4fb5-a3f3-c2f1b955e735","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3be55e04-f50a-42bc-97e9-c1c8b600cec3","children":[],"html":"优点：很多工具系统和包都是CommonJS 构建的；在NodeJS中使用","zIndex":33},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"04ec7447-95bd-4be7-b6d2-2c9dbc07a733","children":[],"html":"缺点：不能直接在Web浏览器使用；本质上是同步的，不适合浏览器","zIndex":32}],"html":"优缺点","zIndex":34},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a26d570b-4f72-4253-8a6b-0d6afa630b1c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a6183823-87c2-440e-b488-d94a0b0c6610","children":[],"html":"导入导出：可以通过 require 函数来导入模块，它会读取、执行 JavaScript 文件，并返回该模块的 exports 对象，该对象只有在模块脚本运行完才会生成","zIndex":29},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"12161f11-5817-4dd2-b9f1-3c9f92153041","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4f18a022-65d9-4343-846d-af7f02d24ba5","children":[],"html":"1. 优先从缓存中加载","zIndex":25},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5690ebec-3ff9-4c9b-bb6f-fad9c16dc2da","children":[],"html":"2. 如果缓存中没有，检查是否是核心模块，如果是直接加载","zIndex":27},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1e3d39e5-78f6-43e7-aa23-7448deb00acf","children":[],"html":"3. 如果不是核心模块，检查是否是文件模块，解析路径，根据解析出的路径定位文件，然后执行并加载","zIndex":26},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"32f58308-fade-4856-ab43-73322b14808f","children":[],"html":"4. 如果以上都不是，沿当前路径向上逐级递归，直到根目录的node_modules目录","zIndex":24}],"html":"require 的加载过程","zIndex":28}],"html":"使用","zIndex":30}],"html":"CommonJS","zIndex":41},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"809c820b-c0d2-46d8-8370-b5ba96abe70c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dfcadbba-f3e4-44ce-a1f2-fe41d71fc08c","children":[],"html":"AMD是异步加载模块机制，解决了CommonJS同步加载的问题。它会同时并发加载所依赖的模块，当所有依赖模块都加载完成之后，再执行当前模块的回调函数。requireJS是AMD规范的一种实现。","width":579.996743936953,"zIndex":82},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e0507f11-e3f1-4a4c-979b-2e9b19b50da8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"952a8e28-93ab-47ae-93de-ee69cd2d4a43","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"15d83ad1-b2ed-4aa9-bfa9-c714dcfb7ffe","children":[],"html":"define(id?, dependencies?, factory);","zIndex":85}],"html":"定义模块","zIndex":84},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"656c74da-3e85-4684-9912-886368d69d6f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"80d82d48-e1c5-4d3e-bcfc-eb2e151cb566","children":[],"html":"require(dependencies?, callback);","zIndex":87}],"html":"使用模块","zIndex":86}],"html":"语法","zIndex":83},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a3aef7d0-769c-49d5-99c9-adcb15ada692","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"20180ef5-f571-4156-b620-b6bbc39bc7a9","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cc3219bc-426b-4275-96b4-e77fb96147eb","children":[],"html":"异步加载实现更好的启动时间","zIndex":90}],"html":"优点","zIndex":89},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b0bd65fa-e550-4e84-809e-9d4ec0de66c9","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3ea62c3a-3296-4a4b-8557-0999c226599b","children":[],"html":"语法复杂，学习成本高","zIndex":92},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cead1311-8a32-4ee2-b117-2a88a3ba5e0d","children":[],"html":"需要requireJS这样的加载器库来使用AMD","zIndex":93}],"html":"缺点","zIndex":91}],"html":"优缺点","zIndex":88}],"html":"AMD","collapsed":true,"zIndex":78},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"c2347eb5-ccc3-47eb-905a-f1054eed771c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c990880b-d44c-44db-b223-3843e8bf86c2","children":[],"html":"CMD 全称为 Common Module Definition，即通用模块定义。CMD 规范整合了 CommonJS 和 AMD 规范的特点。sea.js 是 CMD 规范的一个实现 。","zIndex":94},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"98e48e5e-fb57-401c-8b63-3acb87add019","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"32321e29-8e47-4348-aa13-575390998c38","children":[],"html":"define(function(require, exports, module) { ...&nbsp;<span style>});</span>","zIndex":96}],"html":"语法","zIndex":95},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bf26d525-a82c-4aba-a744-70700fc233dd","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e58a2f0d-938d-43c5-87b8-e3177003b0aa","children":[],"html":"CMD 最大的特点就是懒加载，不需要在定义模块的时候声明依赖，可以在模块执行时动态加载依赖。","height":55.31629124256142,"width":654.9241313248449,"zIndex":98}],"html":"优点","zIndex":97},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"66fd764b-6ddd-459e-972d-8cef337999cb","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"69ec5b83-3bce-485f-88bb-4c5dcc985ff5","children":[],"html":"AMD 需要异步加载模块，而 CMD 在加载模块时，可以同步加载（require），也可以异步加载（require.async）","height":58.69675344560892,"width":592.8191425806981,"zIndex":100},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"47b894ce-22f7-40b0-a759-a0bc484cf492","children":[],"html":"CMD 遵循依赖就近原则，AMD 遵循依赖前置原则。也就是说，在 AMD 中，需要把模块所需要的依赖都提前在依赖数组中声明。而在 CMD 中，只需要在具体代码逻辑内，使用依赖前，把依赖的模块 require 进来。","height":78.33665195965614,"width":708.6465266409991,"zIndex":101}],"html":"AMD 和 CMD 的区别","zIndex":99}],"html":"CMD","collapsed":true,"zIndex":79},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"75d931d2-d5c6-4cd3-b28c-2fd56299e127","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"323fee47-72c1-42ca-80f6-4f83007bbcb6","children":[],"html":"UMD 全称为 Universal Module Definition，即<span style=\"font-weight:bold;\">统一模块定义</span>。其实 UMD 并不是一个模块管理规范，而是带有前后端同构思想的模块封装工具。","width":926.271970134851,"zIndex":102},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"60b515a0-f83c-42a1-8fb2-db64c5302f86","children":[],"html":"UMD 是一组同时支持 AMD 和 CommonJS 的模式，它旨在使代码无论执行代码的环境如何都能正常工作，通过 UMD 可以在合适的环境选择对应的模块规范。比如在 Node.js 环境中采用 CommonJS 模块管理，在浏览器环境且支持 AMD 的情况下采用 AMD 模块，否则导出为全局函数。","height":95.2163212187852,"width":960.7737441102595,"zIndex":103},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0fa14596-b1b9-4462-9505-3b8effefbe34","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a74e246c-c004-490b-8908-ef6b688af53e","children":[],"html":"立即调用函数表达式 (IIFE)：它会检查使用模块的环境。其有两个参数：root 和 factory。 root 是对全局范围的 this 引用，而 factory 是定义模块的函数。","height":82.51423058115051,"width":603.8716369527715,"zIndex":105},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ee71daa1-4a2a-4d0a-a957-2c9a892f1361","children":[],"html":"匿名函数：创建模块，此匿名函数被传递任意数量的参数以指定模块的依赖关系。","height":47.85991420355185,"width":607.5682555929939,"zIndex":106}],"html":"UMD模块的组成","zIndex":104},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d12bf64a-eac2-4801-9e7c-8901cf7d3f34","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9d4bf27a-d565-495f-b791-9d8f852f44e6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4f00bd17-3e56-43a9-a87a-ffabb17ca4d1","children":[],"html":"1. 判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块；","zIndex":109},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"78f82e6a-9d0e-4e79-ba6d-55082d362b0f","children":[],"html":"2. 判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式；","zIndex":110},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bd2348d8-4f3b-4f02-adff-27a24a27a85a","children":[],"html":"3. 若两个都不存在，则将模块公开到全局（Window 或 Global）。","zIndex":111}],"html":"(function (root, factory) {<div>&nbsp; if (typeof define === 'function' &amp;&amp; define.amd) {</div><div>&nbsp; &nbsp; define([], factory);</div><div>&nbsp; } else if (typeof exports === 'object') {</div><div>&nbsp; &nbsp; module.exports,</div><div>&nbsp; &nbsp; module.exports = factory();</div><div>&nbsp; } else {</div><div>&nbsp; &nbsp; root.returnExports = factory();</div><div>&nbsp; }</div><div>}(this, function () {</div><div>&nbsp; // 模块内容定义</div><div>&nbsp; return {};</div><div>}));</div>","zIndex":108}],"html":"UMD 代码实现","zIndex":107},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3e699c51-d24a-41ad-9afc-fbe36e033392","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e38aa869-d8f3-4968-a07a-6b01007b3cd2","children":[],"html":"优点：小而简洁；适用服务器端和客户端","zIndex":113},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"304e6188-4e15-4d76-b7f6-2e82a2210b5c","children":[],"html":"缺点：不容易正确匹配","zIndex":114}],"html":"优缺点","zIndex":112}],"html":"UMD","collapsed":true,"zIndex":80},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"bd7520a9-b312-4d17-9687-0e7be1ff2298","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6c2b5573-202f-499a-9c63-296d71c7e29e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f6d4cfb6-4825-4022-932f-d995a596d6bc","children":[],"html":"1. 静态模块定义：模块的结构在代码解析阶段就可以确定，不需要运行时的加载和解析过程，这有助于提高性能和可预测性，实现在编译时静态优化","zIndex":53},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6fed9cfc-961d-4ca5-bc13-6c679da0d723","children":[],"html":"2. 原生模块支持：实现了原生模块，与Node.js模块加载器相兼容的语法，与其他模块系统如CommonJS和AMD相比，有明显的优势和改进。","zIndex":54},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2ef24898-f3f5-4f92-bacd-9efb6e78d2cf","children":[],"html":"3. 依赖关系管理","zIndex":52},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"152322fd-fa67-4be0-b9ae-7182b1d0e200","children":[],"html":"4. 代码重用和可维护性","zIndex":51}],"html":"ES6 推出的JS内置模块化方案，取代之前的AMD方案。ESM 的主要优势：","zIndex":55},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5006a282-5ff2-4ac6-b21e-2bc46187aa03","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2017b6be-8af4-47c0-bef0-0bdf0f3eb4f6","children":[],"html":"模块默认启用严格模式，比如分配给未声明的变量会报错","zIndex":115},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9de204ec-41b9-4258-94f0-e953651f8194","children":[],"html":"模块有一个词法顶级作用域，例如，运行 var foo = 42; 在模块内不会创建名为 foo 的全局变量，可通过浏览器中的 window.foo 访问","zIndex":116},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c3a5af98-f10f-4e8c-82a3-3fa78f30eb44","children":[],"html":"模块中的 this 并不引用全局 this，而是 undefined。 （如果需要访问全局 this，可以使用 globalThis）；","zIndex":117},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a41065c7-3675-4764-8c12-822869e7708c","children":[],"html":"新的静态导入和导出语法仅在模块中可用，并不适用于经典脚本。","zIndex":118},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8e81dc82-59ba-486e-a166-cee51b3d5ef4","children":[],"html":"顶层 await 在模块中可用，但在经典 JavaScript 脚本中不可用；","zIndex":119},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ba561ac9-454f-4f06-ba56-97734fbc3df8","children":[],"html":"await 不能在模块中的任何地方用作变量名，经典脚本中的变量可以在异步函数之外命名为 await；","zIndex":120},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dba2ad9f-3d78-4666-a33f-f3c500f354c5","children":[],"zIndex":121,"html":"JavaScript 会提升 import 语句。因此，可以在模块中的任何位置定义它们。"}],"html":"ESM 和 经典JS脚本的区别","collapsed":true,"zIndex":56},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8e820d4f-c433-4b38-86b0-d5bad5ea249d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f88a43b6-e917-4f9f-bf9e-f1701abbfc59","children":[],"html":"<span style=\"font-weight:bold;\">CommonJS 和 AMD 都是在运行时确定依赖关系，即运行时加载，CommonJS 加载的是拷贝。而 ES 模块是在编译时就确定依赖关系，所有加载的其实都是引用，这样做的好处是可以执行静态分析和类型检查。</span>","zIndex":57}],"html":"ESM 静态优化","zIndex":58},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e1a50868-0f49-4fdc-b2e3-663f5fdd8dbe","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"13fbf6a0-0d72-4027-9d2c-5661cb46b068","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"809c65af-7a2f-4ce5-b353-6c0b79843c4d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1246fd8f-6a80-4de2-9d53-26caa2ec9810","children":[],"html":"export {first, second, func};","zIndex":71}],"html":"命名导出","zIndex":72},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2466a134-1c0e-46a4-a61a-48865f99f912","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"43c2d27f-ac10-4f93-9a63-5bb8929f6b71","children":[],"html":"export default func;","zIndex":73}],"html":"默认导出","zIndex":74},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0b018ed0-1444-458e-963b-fae71e4389e2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c9912a5a-219d-4f78-8442-b5077e36c3e3","children":[],"html":"可以使用 as 关键字来重命名需要暴露出的变量或方法，经过重命名后同一变量可以多次暴露出去：export {first as second};","zIndex":69}],"html":"as","zIndex":70}],"html":"导出","zIndex":75},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"72d01a62-d7ab-4beb-9295-17461e20de69","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"af001a0e-a335-437a-afa7-bf3a0e22fed4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"664d52e6-e567-4f8d-8634-d204ef8ca9c5","children":[],"html":"import customName from './module';","layout":{"quadrant":1},"zIndex":63},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f632beee-6335-49ab-aa5c-366e22e40918","children":[],"html":"使用 as 重命名：import { fn as fn1 } from './profile';","layout":{"quadrant":1},"zIndex":64},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9629d809-efcd-4310-a2b6-94e268aa84bb","children":[],"html":"使用 as 关键字来加载整个模块，用于从另一个模块中导入所有命名导出，会忽略默认导出：import * as circle from './circle';","zIndex":62}],"html":"静态导入","zIndex":65},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"914583ff-0b1f-42bc-a7be-d385c2d4750b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e916ceb1-3923-4998-8ca2-fff32ab6f60a","children":[],"html":"&lt;script type=\"module\"&gt;<div>&nbsp; (async () =&gt; {</div><div>&nbsp; &nbsp; const moduleSpecifier = './lib.mjs';</div><div>&nbsp; &nbsp; const {repeat, shout} = await import(moduleSpecifier);</div><div>&nbsp; &nbsp; repeat('hello');</div><div>&nbsp; &nbsp; // → 'hello hello'</div><div>&nbsp; &nbsp; shout('Dynamic import in action');</div><div>&nbsp; &nbsp; // → 'DYNAMIC IMPORT IN ACTION!'</div><div>&nbsp; })();</div><div>&lt;/script&gt;</div>","zIndex":66}],"html":"动态导入","zIndex":67},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0129df22-ed2a-4c14-9278-19dea1dc4a60","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2f7e7016-df16-40e4-8ad2-c848f0319612","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"99e970d6-1c6a-470c-86a3-cb1aef7d0a45","children":[],"html":"1. 获取模块 URL：当需要动态加载其他模块或资源时，import.meta.url 提供了当前模块的 URL，这个 URL 是绝对路径，可以作为解析其他路径的基准。例如，你可以通过 new URL('data.txt', import.meta.url) 来获取与当前模块同一目录下的 data.txt 文件的 URL。<div>2. 访问环境变量：import.meta.env 允许你访问定义在 .env 文件中的环境变量。这对于在开发、测试和生产环境之间切换配置非常有用，因为你可以根据环境变量来动态调整模块的行为。</div><div>3. 热更新实现：在支持模块热更新（HMR）的开发环境中，如 Vite 和 Webpack，import.meta 可以用于实现模块的动态更新。这些环境会注入 import.meta.hot API，允许开发者处理模块热更新的逻辑。</div><div>4. 调试和定位：通过 import.meta 获取的模块信息，可以帮助开发者更好地定位模块在项目中的位置，便于调试和排查问题。</div>","zIndex":59}],"html":"它是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 URL。","zIndex":60}],"html":"import.meta","zIndex":61}],"html":"导入","zIndex":68}],"html":"语法","zIndex":76},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a815d56a-2d24-4566-8ca1-4fc3e00edecd","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"27cc9083-ddc3-48d9-bce0-bc7ac14021e6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fb039176-1c27-4aed-9a77-4cb59b762562","children":[],"html":"在 script 标签上添加 type=\"module\" 属性。通过该属性，浏览器知道这个文件是以模块化的方式运行的。而对于不支持的浏览器，需要通过 nomodule 属性来指定某脚本为 fallback 方案","zIndex":48}],"html":"在浏览器使用","zIndex":49},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a3f38c5d-c793-40fa-891f-b123afbc5755","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cc1ea7ab-9d77-4b27-8eac-9c31e80def35","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"849f669f-baa0-43fb-ac53-655416079920","children":[],"html":"使用 .mjs 扩展名保存模块；","zIndex":45},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4a4f7019-3a25-4e46-a75a-c7b667df2428","children":[],"html":"在最近的文件夹中创建一个 type=\"module\" 的 package.json 文件。","zIndex":44}],"html":"从 Node.js 13 开始，可以通过以下两种方式使用模块","zIndex":46},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ffa8a5e7-4972-46e8-922d-bd8d99ee4395","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3ad57833-3778-498f-ac2c-79182191ff43","children":[],"html":"可以在执行脚本启动时加上 --experimental-modules，不过这一用法要求相应的文件后缀名必须为 .mjs：","zIndex":42}],"html":"小于等于 12 版本的 Node.js 中使用 ES 模块","zIndex":43}],"html":"在nodejs使用","zIndex":47}],"html":"使用","zIndex":50}],"html":"ES Module","zIndex":77},{"border":{"shape":"rect","stroke":"transparent","fill":"#e1effa","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"cff6dc12-0fcb-4184-8d1e-0c0fb2527e01","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e1effa","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"173908e3-8f1d-492b-a443-b3f29a9a27c5","children":[],"html":"ES6 Module是值的引用；CommonJS是值的拷贝，一旦输出这个值，模块内部的变化就影响不到这个值","zIndex":1},{"border":{"shape":"rect","stroke":"transparent","fill":"#e1effa","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"63dc4182-92d0-4f84-8687-f0e8172f9a88","children":[],"html":"ES6 Module是编译的时候输出接口，CommonJS是运行加载","zIndex":3},{"border":{"shape":"rect","stroke":"transparent","fill":"#e1effa","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"607fabba-0f69-4306-a290-b3265a3c1a01","children":[],"html":"ES6 Module的import命令是异步加载模块，CommonJS的require()是同步加载","height":62.1231038566375,"width":528.2858156972253,"zIndex":2},{"border":{"shape":"rect","stroke":"transparent","fill":"#e1effa","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a224ce06-88c5-4aba-bb55-7bfb1a9f1110","children":[],"html":"共同点：CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。","zIndex":0}],"html":"ES Module 和 CommonJS 的区别","zIndex":4}],"html":"模块化","layout":{"type":"standard"},"icons":{"flag":2},"x":606,"y":2368.375,"type":"mindmap","zIndex":81}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[8,20,1],"width":1601,"height":949},"viewportOption":"adapt","text":"模块化模块概述概念模块化是一种重要的前端工程化思想，是指将代码拆分成多个独立的，可复用的模块，每个模块有特定的功能和职责，可以提高代码的可维护性、复用性和开发效率。模式模块是一个实现特点功能的文件或代码块。每个模块都有自己的作用域和命名空间，可以避免变量污染和命名冲突。JS模块包含三个部分导入代码：模块的实际代码导出类型模块化的规范包括：IIFE、AMD、CMD、UMD、CommonJS、ES6 Module等。IIFE通过匿名自执行函数，创建一个局部范围来访问变量，避免全局变量污染缺点模块数量较多时会产生命名冲突不利于模块化管理：需要手动管理模块之间依赖关系和加载顺序耦合度高：模块直接的依赖关系通常通过全局变量来传递，导致模块之间耦合度高性能问题：每个IIFE会创建一个新的作用域，并且在运行时执行其中代码，可能增加内存消耗和运行时开销难以复用CommonJSNode.js 采用的模块化规范，浏览器不支持。特点同步加载模块：由于 Node.js 主要运行在服务端，而所需加载的模块文件一般保存在本地硬盘，所以加载比较快，而无需考虑使用异步的方式；文件即模块，文件内所有代码都运行在独立的作用域，因此不会污染全局空间；模块可以被多次引用、加载。第一次被加载时，会被缓存，之后都从缓存中直接读取结果。加载某个模块，就是引入该模块的 module.exports 属性，该属性输出的是值拷贝，一旦这个值被输出，模块内再发生变化不会影响到输出的值。模块加载顺序按照代码引入的顺序。优缺点优点：很多工具系统和包都是CommonJS 构建的；在NodeJS中使用缺点：不能直接在Web浏览器使用；本质上是同步的，不适合浏览器使用导入导出：可以通过 require 函数来导入模块，它会读取、执行 JavaScript 文件，并返回该模块的 exports 对象，该对象只有在模块脚本运行完才会生成require 的加载过程1. 优先从缓存中加载2. 如果缓存中没有，检查是否是核心模块，如果是直接加载3. 如果不是核心模块，检查是否是文件模块，解析路径，根据解析出的路径定位文件，然后执行并加载4. 如果以上都不是，沿当前路径向上逐级递归，直到根目录的node_modules目录AMDAMD是异步加载模块机制，解决了CommonJS同步加载的问题。它会同时并发加载所依赖的模块，当所有依赖模块都加载完成之后，再执行当前模块的回调函数。requireJS是AMD规范的一种实现。语法定义模块define(id?, dependencies?, factory);使用模块require(dependencies?, callback);优缺点优点异步加载实现更好的启动时间缺点语法复杂，学习成本高需要requireJS这样的加载器库来使用AMDCMDCMD 全称为 Common Module Definition，即通用模块定义。CMD 规范整合了 CommonJS 和 AMD 规范的特点。sea.js 是 CMD 规范的一个实现 。语法define(function(require, exports, module) { ... });优点CMD 最大的特点就是懒加载，不需要在定义模块的时候声明依赖，可以在模块执行时动态加载依赖。AMD 和 CMD 的区别AMD 需要异步加载模块，而 CMD 在加载模块时，可以同步加载（require），也可以异步加载（require.async）CMD 遵循依赖就近原则，AMD 遵循依赖前置原则。也就是说，在 AMD 中，需要把模块所需要的依赖都提前在依赖数组中声明。而在 CMD 中，只需要在具体代码逻辑内，使用依赖前，把依赖的模块 require 进来。UMDUMD 全称为 Universal Module Definition，即统一模块定义。其实 UMD 并不是一个模块管理规范，而是带有前后端同构思想的模块封装工具。UMD 是一组同时支持 AMD 和 CommonJS 的模式，它旨在使代码无论执行代码的环境如何都能正常工作，通过 UMD 可以在合适的环境选择对应的模块规范。比如在 Node.js 环境中采用 CommonJS 模块管理，在浏览器环境且支持 AMD 的情况下采用 AMD 模块，否则导出为全局函数。UMD模块的组成立即调用函数表达式 (IIFE)：它会检查使用模块的环境。其有两个参数：root 和 factory。 root 是对全局范围的 this 引用，而 factory 是定义模块的函数。匿名函数：创建模块，此匿名函数被传递任意数量的参数以指定模块的依赖关系。UMD 代码实现(function (root, factory) {  if (typeof define === 'function' && define.amd) {    define([], factory);  } else if (typeof exports === 'object') {    module.exports,    module.exports = factory();  } else {    root.returnExports = factory();  }}(this, function () {  // 模块内容定义  return {};}));1. 判断是否支持 AMD（define 是否存在），存在则使用 AMD 方式加载模块；2. 判断是否支持 Node.js 模块格式（exports 是否存在），存在则使用 Node.js 模块格式；3. 若两个都不存在，则将模块公开到全局（Window 或 Global）。优缺点优点：小而简洁；适用服务器端和客户端缺点：不容易正确匹配ES ModuleES6 推出的JS内置模块化方案，取代之前的AMD方案。ESM 的主要优势：1. 静态模块定义：模块的结构在代码解析阶段就可以确定，不需要运行时的加载和解析过程，这有助于提高性能和可预测性，实现在编译时静态优化2. 原生模块支持：实现了原生模块，与Node.js模块加载器相兼容的语法，与其他模块系统如CommonJS和AMD相比，有明显的优势和改进。3. 依赖关系管理4. 代码重用和可维护性ESM 和 经典JS脚本的区别模块默认启用严格模式，比如分配给未声明的变量会报错模块有一个词法顶级作用域，例如，运行 var foo = 42; 在模块内不会创建名为 foo 的全局变量，可通过浏览器中的 window.foo 访问模块中的 this 并不引用全局 this，而是 undefined。 （如果需要访问全局 this，可以使用 globalThis）；新的静态导入和导出语法仅在模块中可用，并不适用于经典脚本。顶层 await 在模块中可用，但在经典 JavaScript 脚本中不可用；await 不能在模块中的任何地方用作变量名，经典脚本中的变量可以在异步函数之外命名为 await；JavaScript 会提升 import 语句。因此，可以在模块中的任何位置定义它们。ESM 静态优化CommonJS 和 AMD 都是在运行时确定依赖关系，即运行时加载，CommonJS 加载的是拷贝。而 ES 模块是在编译时就确定依赖关系，所有加载的其实都是引用，这样做的好处是可以执行静态分析和类型检查。语法导出命名导出export {first, second, func};默认导出export default func;as可以使用 as 关键字来重命名需要暴露出的变量或方法，经过重命名后同一变量可以多次暴露出去：export {first as second};导入静态导入import customName from './module';使用 as 重命名：import { fn as fn1 } from './profile';使用 as 关键字来加载整个模块，用于从另一个模块中导入所有命名导出，会忽略默认导出：import * as circle from './circle';动态导入<script type=\"module\">  (async () => {    const moduleSpecifier = './lib.mjs';    const {repeat, shout} = await import(moduleSpecifier);    repeat('hello');    // → 'hello hello'    shout('Dynamic import in action');    // → 'DYNAMIC IMPORT IN ACTION!'  })();</script>import.meta它是一个给 JavaScript 模块暴露特定上下文的元数据属性的对象。它包含了这个模块的信息，比如说这个模块的 URL。1. 获取模块 URL：当需要动态加载其他模块或资源时，import.meta.url 提供了当前模块的 URL，这个 URL 是绝对路径，可以作为解析其他路径的基准。例如，你可以通过 new URL('data.txt', import.meta.url) 来获取与当前模块同一目录下的 data.txt 文件的 URL。2. 访问环境变量：import.meta.env 允许你访问定义在 .env 文件中的环境变量。这对于在开发、测试和生产环境之间切换配置非常有用，因为你可以根据环境变量来动态调整模块的行为。3. 热更新实现：在支持模块热更新（HMR）的开发环境中，如 Vite 和 Webpack，import.meta 可以用于实现模块的动态更新。这些环境会注入 import.meta.hot API，允许开发者处理模块热更新的逻辑。4. 调试和定位：通过 import.meta 获取的模块信息，可以帮助开发者更好地定位模块在项目中的位置，便于调试和排查问题。使用在浏览器使用在 script 标签上添加 type=\"module\" 属性。通过该属性，浏览器知道这个文件是以模块化的方式运行的。而对于不支持的浏览器，需要通过 nomodule 属性来指定某脚本为 fallback 方案在nodejs使用从 Node.js 13 开始，可以通过以下两种方式使用模块使用 .mjs 扩展名保存模块；在最近的文件夹中创建一个 type=\"module\" 的 package.json 文件。小于等于 12 版本的 Node.js 中使用 ES 模块可以在执行脚本启动时加上 --experimental-modules，不过这一用法要求相应的文件后缀名必须为 .mjs：ES Module 和 CommonJS 的区别ES6 Module是值的引用；CommonJS是值的拷贝，一旦输出这个值，模块内部的变化就影响不到这个值ES6 Module是编译的时候输出接口，CommonJS是运行加载ES6 Module的import命令是异步加载模块，CommonJS的require()是同步加载共同点：CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。","graphicsBBox":{"x":606,"y":433,"width":1694,"height":3833}}