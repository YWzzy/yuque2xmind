{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"id":"7a61797f-8450-4d5e-bfde-55b2449df6d0","x":1205.3662298828126,"y":1937.375,"html":"Webpack","type":"mindmap","defaultContentStyle":{"color":"rgb(38, 38, 38)"},"border":{"fill":"#F5F5F5","shape":"rect","stroke":"transparent","stroke-width":2},"children":[{"border":{"shape":"rect","stroke":"transparent"},"treeEdge":{"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"02d19cc5-753d-4948-b2c3-91854093e6c5","children":[{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"rgba(0, 0, 0, 0)","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"id":"a13d564f-1455-4ba4-942e-34e1717435cd","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a8729bd1-20f6-46f3-9bf7-65c0558ef080","children":[],"html":"模块打包器，用于将各种模块、资源文件打包成浏览器可以加载和运行的静态资源文件。","height":45.49999994812015,"width":568.9999810546874,"zIndex":67},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"762b2534-d302-419c-83d3-fe4c1580eb50","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"60141b19-89dd-4fbb-b5b9-c59b9de447fe","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9217b77a-ab8a-4571-b5f8-dae14c36b56d","children":[],"html":"是由webpack打包出来的⽂件","zIndex":70}],"html":"bundle","zIndex":69},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ec0fa65b-9575-4668-8a85-7352f8ab867d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3a9a0414-c6a1-4ceb-94d7-0a5c381252e8","children":[],"html":"代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割","zIndex":72}],"html":"chunk","zIndex":71},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"21f1da87-56e9-4366-8de5-bf3984d44831","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"48657859-0d9d-4feb-8b40-42a87e5964fa","children":[],"html":"是开发中的单个模块，webpack中⼀切皆模块，⼀个模块对应⼀个⽂件","zIndex":74}],"html":"module","zIndex":73}],"html":"核心概念","zIndex":68}],"html":"概念","collapsed":true,"zIndex":55},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"rgba(0, 0, 0, 0)","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"id":"4031dc58-2c7e-46b9-a837-2a71b68ca697","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"23607dc8-7e93-40f0-858e-69abaf694fab","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9a513f8a-6174-4da1-b43f-9f2902b047e3","children":[],"html":"启动构建，读取与合并配置参数，加载plugin，实例化 Compiler","zIndex":76}],"html":"初始化","layout":{"quadrant":1},"zIndex":75},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6a10e22a-c735-4bc9-8867-b377d2cdef46","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"99e2a73f-4f7f-4b0d-a83c-a6d7de947882","children":[],"html":"从Entry出发，针对每个模块<span style=\"font-weight:bold;\">串行</span>调用对应的loader去翻译文件的内容，再去找这个模块依赖的模块，递归地进行编译处理","zIndex":78}],"html":"编译","layout":{"quadrant":1},"zIndex":77},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"02d8d3cd-5868-4b44-9ab7-f8036013cd56","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e680f63d-9822-422b-963a-d3f113749b65","children":[],"html":"将编译后的模块组合成chunk，将chunk转换成文件，输出到文件系统中","zIndex":80}],"html":"输出","zIndex":79},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3560a120-791b-4b4f-8816-a3566c9bd0d9","children":[],"html":"在构建过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到对应的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。","width":634.4999810546892,"zIndex":81}],"html":"构建流程","collapsed":true,"zIndex":57},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8cce65a1-9bca-48ad-ad4c-0c27948a985b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"16f72ae3-659e-4d27-8d1d-416f3d39ee3e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"35a247ad-5e39-4490-a12a-f9581bfa3c40","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3e91c71b-662d-45b2-852b-6d81d79dbac0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ca51f1f2-7ce7-4747-b79c-9da03b26a279","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"40313c85-ea7e-4fa0-a359-fabb6c95dd1e","children":[],"html":"{<div>&nbsp; &nbsp; &nbsp; &nbsp; test: /\\.js$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; exclude: /node_modules/, // 排除node_modules代码不编译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; loader: \"babel-loader\",</div><div>},</div>","layout":{"quadrant":1},"zIndex":86}],"html":"是 webpack 和 babel 通信的桥梁，不会做es6转义为es5的工作","zIndex":85}],"html":"babel-loader","zIndex":84},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"37a9cc56-0293-43bb-a402-70856027cb37","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fb19a7b9-1f64-49ed-8609-ec04ae5b002a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"cd1b481e-0999-4dbd-b9dc-b10473fe89ea","children":[],"html":"@babel/preset-env: 一个智能预设，允许您使用最新的 JavaScript","zIndex":89},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"84ac05d2-50e3-43cb-b698-7095822f9610","children":[],"html":"@babel/preset-react：一个用来编译 React jsx 语法的预设","zIndex":90},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c7696006-194c-413b-8c6e-cdbfc07a6a0c","children":[],"html":"@babel/preset-typescript：一个用来编译 TypeScript 语法的预设","zIndex":91}],"html":"presets：预设，就是一组 Babel 插件, 扩展 Babel 功能，它能将 ES6 的一些语法进行编译转换，比如箭头函数、扩展运算符等","layout":{"quadrant":1},"zIndex":88}],"html":"ES6语法编译","zIndex":87},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5e917c72-91a5-4ba9-b5cf-3a90c8a7dfbc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1fb1011a-e258-45dd-95db-a40333563a16","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"0e0064aa-4869-4407-b196-ee463b662df4","children":[],"html":"直接使用promise语法，eslint会报错，需要修改eslint配置","zIndex":94},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6c4a42d4-d8d1-49d0-a5db-6d246eef3490","children":[],"html":"npm i @babel/eslint-parser -D","zIndex":95},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"61085164-1930-41b6-91f4-cc3278f0e899","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a64c9841-8752-4211-8e40-feee9b400385","children":[],"html":"module.exports = {<div>&nbsp; <span style=\"font-weight:bold;\">parser: \"@babel/eslint-parser\", // 支持最新的最终 ECMAScript 标准</span></div><div>};</div>","zIndex":97}],"html":".eslintrc.js","zIndex":96},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e4fe3c38-0e77-43fc-8bff-dd96acc5bd65","children":[],"html":"对 promise 编译转换：npm i core-js","zIndex":98}],"html":"core-js：专门用来做ES6及以上API的polyfill，可以处理presets处理不了的async函数、promise对象，数组includes方法等等。polyfill 就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性。","layout":{"quadrant":1},"zIndex":93}],"html":"polyfill","layout":{"quadrant":1},"zIndex":92},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"dce4a082-6a0e-4273-92ba-02b59492eef7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"0fd76b9b-fa70-45f6-b653-83d74b0083a9","children":[],"html":"module.exports = {<div>&nbsp; // 智能预设：能够编译ES6语法</div><div>&nbsp; presets: [</div><div>&nbsp; &nbsp; [</div><div>&nbsp; &nbsp; &nbsp; \"@babel/preset-env\",</div><div>&nbsp; &nbsp; &nbsp; // 按需加载core-js的polyfill</div><div>&nbsp; &nbsp; &nbsp; { useBuiltIns: \"usage\", corejs: { version: \"3\", proposals: true } },</div><div>&nbsp; &nbsp; ],</div><div>&nbsp; ],</div><div>};</div>","zIndex":100}],"html":"babel 配置：babel.config.js","zIndex":99}],"html":"babel","zIndex":83}],"html":"处理js","layout":{"quadrant":1},"zIndex":82},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ea17a4fe-7440-4bfa-bd27-6dddf7f5896f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b8623711-7938-41aa-895b-647ae1360741","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"54b1c9e7-531a-4093-a7e2-95afa838c758","children":[],"html":"将css文件编译成webpack能识别的模块","zIndex":103}],"html":"css-loader","zIndex":102},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"83956c6d-3720-44be-9be3-7bf94fffff9c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a3a861a1-cdb6-4b4f-999c-e37a8b9d1855","children":[],"html":"动态创建一个style标签，里面放置webpack中css模块的内容","zIndex":105}],"html":"style-loader","zIndex":104},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7031e7d4-34ef-4100-a63b-50c2e4b2ebae","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f3697048-9ab9-4b2f-970f-8ff09dafccb8","children":[],"html":"将sass/less文件编译成css文件","zIndex":107}],"html":"sass-loader/less-loader/stylus-loader","zIndex":106},{"start":0,"end":2,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"{<div>&nbsp; &nbsp; &nbsp;test: /\\.less$/,</div><div>&nbsp; &nbsp; &nbsp;use: [\"style-loader\", \"css-loader\", \"less-loader\"],</div><div>}</div>","defaultContentStyle":{"color":"#262626"},"id":"b678a058-a801-4ec8-8470-6b4c096e343f","children":[],"zIndex":108}],"html":"处理样式","collapsed":true,"zIndex":101},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6adf628a-d452-419d-b7c0-cf3fff1db3c5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"3a134d4f-4f29-4d96-9db1-4f8706585e31","children":[],"html":"postcss-loader：扩展 CSS 语法，可以配合 autoprefixer 插件自动补齐 CSS3 前缀","height":59.239939355461956,"width":582.6429185546908,"zIndex":110},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"96a6dc14-4d29-424b-aa3c-e34b4e4d6209","children":[],"html":"npm i postcss-loader postcss postcss-preset-env -D","zIndex":111},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6fbeb886-ec70-4c5e-9e8e-5301c3680467","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7f6138fa-9414-495a-a963-ebb4de926c17","children":[],"html":"{<div>&nbsp; &nbsp; &nbsp; &nbsp; // 用来匹配 .css 结尾的文件</div><div>&nbsp; &nbsp; &nbsp; &nbsp; test: /\\.css$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // use 数组里面 Loader 执行顺序是从右到左</div><div>&nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; MiniCssExtractPlugin.loader,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"css-loader\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loader: \"postcss-loader\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; postcssOptions: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"postcss-preset-env\", // 能解决大多数样式兼容性问题</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ],</div><div>},</div>","height":469.7311893554622,"width":472.66854355469013,"layout":{"quadrant":1},"zIndex":113}],"html":"配置","zIndex":112},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"018a858a-cca2-4c93-9b70-2a694af0bd22","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1bf6d0ad-1a96-4a1b-ba12-1559335545e8","children":[],"html":"在 package.json 文件中添加 browserslist 来控制样式的兼容性做到什么程度","height":58.12393935546049,"width":518.2580435546906,"zIndex":115},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ae23fd37-4d75-4e7c-9ff7-6de7c257437f","children":[],"html":"{<div>&nbsp; // 其他省略</div><div>&nbsp; \"browserslist\": [\"ie &gt;= 8\"]</div><div>}</div>","zIndex":116}],"html":"控制兼容性","zIndex":114}],"html":"处理css兼容性","layout":{"quadrant":1},"zIndex":109},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"80adee94-e8f2-4249-9199-8784caadcc5b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9c83a672-0f41-44bc-9079-a992303fc256","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f6fbd6ce-9d60-406c-bb1a-91181002d6c8","children":[],"html":"file-loader: 把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件","zIndex":119},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3cfcc7fd-ce8f-4ab7-9d4f-fb87771bb186","children":[],"html":"url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)","zIndex":120}],"html":"webpack4 处理图片使用 file-loader 和 url-loader","zIndex":118},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"de7e5b7e-de68-468b-869f-c1ca75c2d2d9","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"41d77956-ddb2-4d96-bb03-afe28acaa2ca","children":[],"html":"{<div>&nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(png|jpe?g|gif|webp)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; type: \"asset\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; parser: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dataUrlCondition: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; maxSize: 10 * 1024 // 小于10kb的图片会被base64处理</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; generator: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将图片文件输出到 static/imgs 目录中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将图片文件命名 [hash:8][ext][query]</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [hash:8]: hash值取8位</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [ext]: 使用之前的文件扩展名</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // [query]: 添加之前的query参数</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; filename: \"static/imgs/[hash:8][ext][query]\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; },</div><div>},</div>","zIndex":122}],"html":"webpack5 可以通过在module.rules中设置type: asset，可以在配置中修改打包阈值，以及修改输出资源的名称和路径(路径最好在output中统一配置)","zIndex":121}],"html":"处理图片","collapsed":true,"zIndex":117},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"b7e502ac-dcfd-4c7f-a80e-1204a4c3fadb","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"289e8c41-93b5-40e1-9021-acb8f2073f46","children":[],"html":"{<div>&nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(ttf|woff2?|mp4|mp3|avi)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; type: \"asset/resource\",</div><div>},</div>","zIndex":124},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7116988f-9732-4555-bcef-b9f0022f6b5e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"980c77d0-a9ce-4050-b31a-f1c484ec95a4","children":[],"html":"type: \"asset/resource\" 相当于file-loader, 将文件转化成 Webpack 能识别的资源，其他不做处理","zIndex":126},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ff5e17e8-862c-48a4-8af9-08ac9245275c","children":[],"html":"type: \"asset\" 相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式","zIndex":127}],"html":"type: \"asset/resource\"和type: \"asset\"的区别","zIndex":125}],"html":"处理字体图标及其他资源(音视频)","collapsed":true,"zIndex":123},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"965b9609-20d1-40fd-b2f5-2846b66e7213","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"945621e9-c0b2-40be-b5e6-281afe9b4524","children":[],"html":"raw-loader：加载文件原始内容（utf-8）","zIndex":129},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"690ec8a5-f204-4845-81ef-2a0c3ccf9361","children":[],"html":"source-map-loader：加载额外的 Source Map 文件，以方便断点调试","zIndex":130},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"535b97db-cbfc-4e17-93a6-052b1d20688d","children":[],"html":"svg-inline-loader：将压缩后的 SVG 内容注入代码中","zIndex":131},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d32df09a-0738-4af4-9edd-c22b3b1d9324","children":[],"html":"awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loader","zIndex":132},{"border":{"shape":"rect","stroke":"transparent","fill":"#e2e6f8","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"0bb1fd30-7246-4184-a4ff-e4a8dae3c09b","children":[],"html":"cache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里","zIndex":133}],"html":"其他","collapsed":true,"zIndex":128}],"html":"常用的 Loader","layout":{"quadrant":1},"collapsed":true,"zIndex":59},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"04bc2227-3a8c-4482-8260-bdbacf1f57ab","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3f894e4f-c0a2-4b99-967a-5dc6fc2a5e71","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"607c83e0-0011-4782-b063-a314f4cace27","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f2648a8d-39c6-4d8f-9fdc-39f34567e61e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"052d86eb-2ba7-4196-b2f4-24cf6d68bf50","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"06d81acd-1d70-4f06-b52f-8c076a5ed630","children":[],"html":"module.exports = {<div>&nbsp; // 继承 Eslint 规则</div><div>&nbsp; extends: [\"eslint:recommended\"],</div><div>&nbsp; env: {</div><div>&nbsp; &nbsp; node: true, // 启用node中全局变量</div><div>&nbsp; &nbsp; browser: true, // 启用浏览器中全局变量</div><div>&nbsp; },</div><div>&nbsp; parserOptions: {</div><div>&nbsp; &nbsp; ecmaVersion: 6, // ES 语法版本</div><div>&nbsp; &nbsp; sourceType: \"module\", // ES 模块化</div><div>&nbsp; &nbsp; ecmaFeatures: { // ES 其他特性</div><div>&nbsp; &nbsp; &nbsp; jsx: true // 如果是 React 项目，就需要开启 jsx 语法</div><div>&nbsp; &nbsp; }</div><div>&nbsp; },</div><div>&nbsp; rules: {</div><div>&nbsp; &nbsp; \"no-var\": 2, // 不能使用 var 定义变量</div><div>&nbsp; },</div><div>};</div>","width":388.0485191406269,"zIndex":138}],"html":"eslint 配置文件：.eslintrc.js","zIndex":137},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cdc81f6f-9eff-4ff8-bce7-a911a36f544d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f894485e-7aab-46a8-82b4-8fb79f443a89","children":[],"html":" plugins: [<div>&nbsp; &nbsp; new ESLintWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; // 指定检查文件的根目录</div><div>&nbsp; &nbsp; &nbsp; context: path.resolve(__dirname, \"src\"),</div><div>&nbsp; &nbsp; }),</div><div>&nbsp; ],</div>","layout":{"quadrant":1},"zIndex":140}],"html":"webpack.config.js","zIndex":139}],"html":"配合eslint、vscode eslint插件做代码格式检查","zIndex":136}],"html":"eslint-webpack-plugin","layout":{"quadrant":1},"zIndex":135}],"html":"代码格式检查","collapsed":true,"zIndex":134},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b4d9ed64-4816-43d0-9d43-4bfbdc37f859","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5d4fc05d-6888-48c0-a282-f518d736c99d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b8eb4acf-0d73-4e14-ad14-84f78e3ea831","children":[],"html":"plugins: [<div>&nbsp; &nbsp; new HtmlWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; // 以 public/index.html 为模板创建文件</div><div>&nbsp; &nbsp; &nbsp; // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源</div><div>&nbsp; &nbsp; &nbsp; template: path.resolve(__dirname, \"public/index.html\"),</div><div>&nbsp; &nbsp; }),</div><div>&nbsp; ],</div>","width":592.7595435546909,"zIndex":143}],"html":"html-webpack-plugin","zIndex":142}],"html":"处理html","layout":{"quadrant":1},"zIndex":141},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7c512e0c-8ae9-4552-a333-26a82a1464f1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ea79be26-6f0d-4fbe-a997-d05d42a7ef70","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"33227dee-a3f6-4fa8-90a7-2ba069293469","children":[],"html":"使用loader处理样式后，Css 文件被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式。这样访问页面时会出现闪屏现象。","zIndex":146},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a3a4c473-9e9b-420a-969d-da20ac5037bc","children":[],"html":"这个插件可以单独生成css文件，通过link标签加载","zIndex":147},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9522f1e0-4d90-4e61-a14a-29c08f9e1579","children":[],"html":"// 提取css成单独文件<div>new MiniCssExtractPlugin({</div><div>&nbsp; &nbsp; &nbsp; // 定义输出文件名和目录</div><div>&nbsp; &nbsp; &nbsp; filename: \"static/css/main.css\",</div><div>}),</div>","zIndex":148}],"html":"mini-css-extract-plugin","zIndex":145}],"html":"提取css成单独文件","collapsed":true,"zIndex":144},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a9e58c55-aed8-4e01-99bd-799b8ec7fbd9","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7b3b59ad-9783-4ffd-88ef-c5a14dcf3013","children":[],"html":"css-minimizer-webpack-plugin","zIndex":150},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4471d100-71a8-47ab-a815-8ad56a1e9e9c","children":[],"html":"默认生产模式已经开启了：html 压缩和 js 压缩，不需要额外配置","zIndex":151}],"html":"css压缩","collapsed":true,"zIndex":149},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"47f39846-b03c-41f5-9180-1e748104e128","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"708ac2fd-7d79-42b8-8875-c0e257ad2574","children":[],"html":"terser-webpack-plugin","zIndex":153}],"html":"js压缩","layout":{"quadrant":1},"collapsed":true,"zIndex":152},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2bb778b6-8886-49c6-9a3b-ba485498e358","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b7fde613-8a7f-4d03-94d7-0a607dc3daa0","children":[],"html":"ModuleConcatenationPlugin: 开启 Scope Hoisting ？？？？","zIndex":155},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6c6fbe2d-5199-4b1c-a911-37f8862c3500","children":[],"html":"webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)","zIndex":156},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d665c026-6470-4a11-8c80-27338a42ca13","children":[],"html":"webpack-dashboard：可以更友好的展示相关打包信息","zIndex":157},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"46a30966-246c-4a60-b281-423c8d47f606","children":[],"html":"webpack-merge：提取公共配置，减少重复配置代码","zIndex":158},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3b1e09c4-e6bf-431b-b755-56e9412a8359","children":[],"html":"speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)","layout":{"quadrant":1},"zIndex":159},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d0a6d843-c4a2-4230-b9e2-c5fb03afe18f","children":[],"html":"size-plugin：监控资源体积变化，尽早发现问题","zIndex":160},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"aed8e73b-b585-436e-aeeb-03d64005261c","children":[],"html":"HotModuleReplacementPlugin：模块热替换","zIndex":161}],"html":"一些提高开发效率的插件","collapsed":true,"zIndex":154}],"html":"常用的 Plugin","layout":{"quadrant":1},"collapsed":true,"zIndex":61},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"rgba(0, 0, 0, 0)","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"id":"0b8cb8d7-304d-4281-b69c-802a997a41dc","children":[{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"504e27d5-975a-4a94-a871-d8a40aff9d59","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a7e56dfe-3069-4d16-9402-0311d5a3aead","children":[],"html":"Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。","zIndex":163},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"403abcf1-542c-43be-aa91-36f80347161a","children":[],"html":"Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。","zIndex":164}],"html":"作用不同","zIndex":162},{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"13d0db1f-a1b5-4085-a58d-bb1ae03ed8e7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f9ca728d-445a-4627-b8f0-0fa82ee909fc","children":[],"html":"Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。","zIndex":166},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8aa2d395-7f0a-48d3-8e8c-169748e65caa","children":[],"html":"Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。","zIndex":167}],"html":"配置不同","zIndex":165}],"html":"Loader 和 Plugin 的区别","collapsed":true,"zIndex":60},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"aa756862-019b-4603-8e2c-9428f5971049","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"63936f3c-6a04-424f-ab5c-166910658973","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f8947ae5-2242-41d8-9509-4b12546bdbb9","children":[],"html":"直接在 entry 中指定单页应用的入口即可","zIndex":169}],"html":"单页应用配置","zIndex":168},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a08e4358-d089-4bdb-a0d3-b20b634a8527","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4906c992-4b40-40a3-8873-3a80de4b2a1d","children":[],"html":"可以使用webpack的 AutoWebPlugin 来完成简单自动化的构建","zIndex":171}],"html":"多页应用配置","zIndex":170},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"04ee4888-e06c-4faf-8c92-2660637a5475","children":[],"html":"react 脚手架配置","zIndex":172},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"48ad4395-a3cb-4963-8bed-95be6be417a7","children":[],"html":"vue 脚手架配置","zIndex":173}],"html":"配置相关","layout":{"quadrant":1},"collapsed":true,"zIndex":58},{"border":{"shape":"rect","stroke":"transparent"},"treeEdge":{"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"eeaeadb7-fa13-4433-bcb3-68050aaba5ce","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"4edf0aa0-9bb5-4050-94df-87854ac8b9b4","children":[],"html":"开发服务器 &amp; 自动编译代码","zIndex":174},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"f4ada701-c0df-433c-9d03-d8181a16f0b9","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"1bbfeb7d-f234-4c77-b82b-19dcd2854d5e","children":[],"html":"devServer: {<div>&nbsp; &nbsp; host: \"localhost\", // 启动服务器域名</div><div>&nbsp; &nbsp; port: \"3000\", // 启动服务器端口号</div><div>&nbsp; &nbsp; open: true, // 是否自动打开浏览器</div><div>},</div><div>mode: \"development\",</div>","layout":{"quadrant":1},"zIndex":176}],"html":"配置","zIndex":175},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"ce309376-adaa-402f-bcd7-7b05d5b25e01","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"badf3bf0-9347-4607-8a52-a1c88479796d","children":[],"html":"npx webpack serve","zIndex":178}],"html":"运行指令","zIndex":177},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"7309ee68-1324-4593-abf2-3e8c974f0773","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"61e8e31a-78fa-40e4-b208-d8fc160c43a3","children":[],"html":"当使用开发服务器时，所有代码都会在内存中编译打包，并不会输出到 dist 目录下","height":54.521939355465406,"width":536.5807310546879,"zIndex":180}],"html":"特点","zIndex":179}],"html":"webpack-dev-server","collapsed":true,"layout":{"quadrant":1},"zIndex":56},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#6EC4C4"},"defaultContentStyle":{"color":"#262626"},"id":"56966f16-bf20-4c62-a6fa-8ff2d99d4845","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d2e848fd-d811-4534-bd09-164a1bfc385b","children":[],"html":"文件指纹，是指打包后输出的文件名的后缀","zIndex":181},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"60c7abbf-f359-40f4-b555-60945e175841","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1d54b497-2a08-4803-aa2d-c63f322648a5","children":[],"html":"Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改","zIndex":183},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"58f5c7bb-a7d0-4234-a669-9e72552dab15","children":[],"html":"Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhash","zIndex":184},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e361a04f-7481-4cf6-812b-c16a3d48eab0","children":[],"html":"Contenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变","zIndex":185}],"html":"类型","zIndex":182},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"24279a4d-de31-4c80-9e82-541a0e42a7bb","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c57fddf6-e16b-4981-a73d-27746e8de630","children":[],"html":"设置 output 的 filename，用 chunkhash","zIndex":187}],"html":"JS的文件指纹设置","zIndex":186},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"51711bb0-2d6c-4900-8281-a2255f667cd1","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"25270940-6436-4431-b36f-04aed14c3878","children":[],"html":"设置 MiniCssExtractPlugin 的 filename，使用 contenthash","zIndex":189}],"html":"CSS的文件指纹设置","zIndex":188},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5571f40b-78ab-4e7a-97e9-bd07366357e8","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fb3adc08-1278-49da-92c8-00dab0b2721b","children":[],"html":"设置file-loader的name，使用hash","zIndex":191}],"html":"图片的文件指纹设置","zIndex":190}],"html":"hash","layout":{"quadrant":1},"collapsed":true,"zIndex":54}],"html":"基础","icons":{"priority":0},"zIndex":63,"collapsed":true},{"border":{"shape":"rect","stroke":"transparent"},"treeEdge":{"stroke":"#6EC4C4"},"defaultContentStyle":{"color":"#262626"},"id":"84af719d-d5c0-4345-80d0-fa6bf818d496","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"e3a36249-0388-46dd-bf9c-6f392e1f4ea9","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"0cef4cbe-f1a2-4487-ada8-3dea2ffd4877","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"18126a86-0394-45c3-89a3-66af23d8ad26","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"215d5693-c32f-4c8f-b577-a53c342fa41e","children":[],"html":"优点：打包编译速度快，只包含行映射；缺点：没有列映射","layout":{"quadrant":1},"zIndex":194},{"border":{"shape":"rect","stroke":"#6ec4c4"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"75390e13-3817-412b-9a90-bd2604467f49","children":[],"html":"module.exports = {<div>&nbsp; // 其他省略</div><div>&nbsp; mode: \"development\",</div><div>&nbsp; devtool: \"cheap-module-source-map\",</div><div>};</div>","zIndex":195}],"html":"开发模式：cheap-module-source-map","zIndex":193},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"b73d4b04-425a-4c24-8646-1e9aa39c0c97","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"8e5e2389-26cc-4c50-96d0-6da2fc0d4e58","children":[],"html":"优点：包含行/列映射；缺点：打包编译速度更慢","zIndex":197},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"70607fca-0f91-4572-a89a-67f46ac45c3a","children":[],"html":"module.exports = {<div>&nbsp; // 其他省略</div><div>&nbsp; mode: \"production\",</div><div>&nbsp; devtool: \"source-map\",</div><div>};</div>","zIndex":198}],"html":"生产模式：source-map","zIndex":196}],"html":"使用 Source Map 让开发或上线时代码报错能有更加准确的错误提示","zIndex":192}],"html":"提升开发体验","layout":{"quadrant":1},"collapsed":true,"zIndex":1},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"d88125d8-5495-44e9-bdb4-ad12ccb17556","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"80d5ab5d-6758-4535-b6d6-e6b644339faf","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"0598a0d3-0b88-4540-a70c-04860543db4b","children":[],"html":"speed-measure-webpack-plugin","zIndex":199},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"81a919d4-47a0-4dfe-b80e-36692a38b5b3","children":[],"html":"缺点：有些 Loader 或者 Plugin 新版本会不兼容，需要进行降级处理，在 webpack5.x 中为了使用费时分析去对插件进行降级或者修改配置写法是非常不划算的，不建议使用","zIndex":200}],"html":"构建费时分析","collapsed":true,"zIndex":12},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"25021b94-ff5d-4817-96d0-f697f670e568","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"9ffbd13a-c44e-4458-b068-4c324bb5b7b8","children":[],"html":"使用 HotModuleReplacement 让开发时只重新编译打包更新变化了的代码，不变的代码使用缓存，从而使更新速度更快","zIndex":201},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"3f9007e7-a743-4139-a821-27afb9525a33","children":[],"html":"HMR/热模块替换：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面","zIndex":202},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"52c36876-ed3f-4fc2-84d4-b35283fd4a07","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"9584801b-8eec-4612-a6cf-91f6b0d9a43a","children":[],"html":"module.exports = {<div>&nbsp; devServer: {</div><div>&nbsp; &nbsp; host: \"localhost\", // 启动服务器域名</div><div>&nbsp; &nbsp; port: \"3000\", // 启动服务器端口号</div><div>&nbsp; &nbsp; open: true, // 是否自动打开浏览器</div><div>&nbsp; &nbsp; hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了）</div><div>&nbsp; },</div><div>};</div>","height":201.82143042688585,"width":471.7618858165956,"zIndex":204},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"32a2e9b2-8958-40fb-a287-1de80f01fc7a","children":[],"html":"此时 css 样式经过 style-loader 处理，已经具备 HMR 功能了。 但是 js 还不行。","zIndex":205}],"html":"基本配置","zIndex":203},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"2e7df69d-c71c-451d-a7af-2e71f772e818","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"518d724b-fff6-40f5-85cc-04170e95a7aa","children":[],"html":"实际开发我们会使用其他 loader 来解决，比如：vue-loader","width":524.7618858165956,"zIndex":207},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"68d15583-0ca9-4eab-8146-e15f16ed73aa","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"116c368b-0f9c-4f57-acd6-75a658170180","children":[],"html":"npm i -D @pmmmwh/react-refresh-webpack-plugin react-refresh","zIndex":209},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"7a235787-6155-411c-8783-dd3d635967bd","children":[],"html":"{<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.(jsx|js)$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include: path.resolve(__dirname, \"../src\"),</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loader: \"babel-loader\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheDirectory: true,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheCompression: false,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // \"@babel/plugin-transform-runtime\", // presets中包含了</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"react-refresh/babel\", // 开启js的HMR功能</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>},</div>","zIndex":210},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"79933991-eb44-4e5c-b8b9-40c510d78fcf","children":[],"html":"new ReactRefreshWebpackPlugin(), // 解决js的HMR功能运行时全局变量的问题","height":60.00000185545514,"width":572.9999810546924,"zIndex":211}],"html":"react","zIndex":208}],"html":"js 配置","zIndex":206}],"html":"HotModuleReplacement","collapsed":true,"layout":{"quadrant":1},"zIndex":14},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"a91a199f-fe37-47ef-b411-5aa5ef3cbb5d","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"8deb9294-6aa7-4a09-92ea-43abe2fed30b","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"bf485fdd-84a0-48f5-a3c7-cdbc4c92d7ee","children":[],"html":"用于创建 import 或 require 的别名，用来简化模块引用，配置不宜过多","zIndex":213}],"html":"alias","zIndex":212},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"e2e4121e-8b1d-4a41-b8b8-cfb0ea2acaf1","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"2dbe9291-a290-4c17-8f5b-5a3eb4f10d8b","children":[],"html":"webpack 就会按照 extensions 配置的数组从左到右的顺序去尝试解析模块，高频文件后缀名放前面","zIndex":215}],"html":"extensions","zIndex":214},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"9b8be374-a179-416c-80d8-80343ea56acf","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"cf98a553-3701-4960-9185-68628107155a","children":[],"html":"告诉 webpack 优先 src 目录下查找需要解析的文件，会大大节省查找时间","zIndex":217},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"76bf51e0-89e8-4d77-9713-7f3109d858bf","children":[],"html":"resolve: {<div>&nbsp; &nbsp; &nbsp;modules: [resolve('src'), 'node_modules'],</div><div>&nbsp; },</div>","zIndex":218}],"html":"modules","zIndex":216}],"html":"优化resolve配置","collapsed":true,"zIndex":16},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"53459406-179d-4e55-89c1-92f9e0847c5c","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"3688ba9e-fae2-4e78-9cee-bbefd8ff44c4","children":[],"html":"externals 配置选项提供了「从输出的 bundle 中排除依赖」的方法。此功能通常对 library 开发人员来说是最有用的","zIndex":219},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"f6a03ee9-e347-489e-b98e-f6ff08d12633","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"1d28da01-591d-4989-b55c-b29a8c26028c","children":[],"html":"externals: {<div>&nbsp; &nbsp; jquery: 'jQuery',</div><div>},</div>","zIndex":221}],"html":"使用场景：从 CDN 引入 jQuery，而不是把它打包","zIndex":220}],"html":"externals","collapsed":true,"zIndex":18},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"78446610-efea-4777-8c00-c5f1d76572b7","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"08b408d1-fb78-40c2-9788-c817f566b401","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"db2600f7-15ea-4487-91df-a2d6cb1202a9","children":[],"html":"使用 OneOf 让资源文件一旦被某个 loader 处理了，就不会继续遍历了，打包速度更快","zIndex":223},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"2a573ef3-05c7-46f0-bafd-4feaf658c4ef","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"466325ed-3d16-4998-a978-46260146dd0c","children":[],"html":"打包时每个文件都会经过所有 loader 处理，虽然因为 test 正则原因实际没有处理上，但是都要过一遍。比较慢","zIndex":225}],"html":"why","collapsed":true,"layout":{"quadrant":1},"zIndex":224},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"11adf963-4368-4995-864d-ead8af8af395","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"412372e5-02c1-4aa2-9a8a-3a4f0d0e404e","children":[],"html":"只能匹配上一个 loader, 剩下的就不匹配了","zIndex":227}],"html":"what","collapsed":true,"layout":{"quadrant":1},"zIndex":226},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"9cbaa359-bddf-43cd-8ec0-e8dcb23bd4fe","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"b1a383a3-23e2-4f2b-8f88-fe13d7e80c86","children":[],"html":"module: {<div>&nbsp; &nbsp; rules: [</div><div>&nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; oneOf: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.css$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // use 数组里面 Loader 执行顺序是从右到左</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [\"style-loader\", \"css-loader\"],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.less$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [\"style-loader\", \"css-loader\", \"less-loader\"],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.js$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // exclude: /node_modules/, // 排除node_modules代码不编译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include: path.resolve(__dirname, \"../src\"), // 也可以用包含</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loader: \"babel-loader\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ],</div><div>&nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; ],</div><div>&nbsp; },</div>","width":518.7618858165952,"zIndex":229}],"html":"how","collapsed":true,"zIndex":228}],"html":"oneOf","collapsed":true,"layout":{"quadrant":1},"zIndex":222},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"b52f97de-fab7-46fc-b0a6-64a413edd3ff","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"442da9f2-fe9d-44be-babd-adc73dd60154","children":[],"html":"使用 Include/Exclude 排除或只检测某些文件，处理的文件更少，速度更快","zIndex":231},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"39b80c67-7329-49cc-91c2-b6a777a17969","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"cf99b8cb-22da-472e-958e-0a88625498e8","children":[],"html":"开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中了。而这些文件是不需要编译可以直接使用的。<div>所以我们在对 js 文件处理时，要排除 node_modules 下面的文件</div>","zIndex":233}],"html":"why","zIndex":232},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"c2fbbc42-0c81-4e2f-b976-46dbbc4d09cd","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"3a8bc203-2823-4c02-88ea-bdf59be39e73","children":[],"html":"include：包含，只处理xxx文件","zIndex":235},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"a64ef5bc-3fb3-417a-8c33-63b04e9303b0","children":[],"html":"exclude：排除，除了xxx文件以外其他文件都处理","zIndex":236}],"html":"what","zIndex":234}],"html":"Include/Exclude","collapsed":true,"layout":{"quadrant":1},"zIndex":230}],"html":"缩小范围","collapsed":true,"zIndex":19},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"cd61279f-c835-48a9-97c7-b2c89353254a","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"a092c2be-ac0e-45bf-b700-9c3bf750a21c","children":[],"html":"不需要解析依赖的第三方大型类库等，可以通过这个字段进行配置，以提高构建速度","zIndex":237},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"e8e5ece7-b6ad-4535-870c-d156b0d331f6","children":[],"html":"使用 noParse 进行忽略的模块文件中不会解析 import、require 等语法","zIndex":238},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"abffca47-da72-465f-acd1-216b1c9c2d75","children":[],"html":"module: {&nbsp;<div>&nbsp; &nbsp; noParse: /jquery|lodash/,</div><div>&nbsp; &nbsp; rules:[...]</div><div>&nbsp; }</div>","zIndex":239}],"html":"noParse","collapsed":true,"zIndex":17},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"44f9450f-1c40-4ff9-a059-1395f9c47ae5","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"d2da9312-f78f-4efd-bedd-1e35dd5e2fe9","children":[],"html":"使用场景：将插件中的非中文语音排除掉，这样就可以大大节省打包的体积了","zIndex":240},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"02edda2d-4e4d-4f68-9690-4345ff1f2e6a","children":[],"html":"plugins:[ // 配置插件<div>&nbsp; &nbsp; ...</div><div>&nbsp; &nbsp; new webpack.IgnorePlugin({</div><div>&nbsp; &nbsp; &nbsp; resourceRegExp: /^\\.\\/locale$/,</div><div>&nbsp; &nbsp; &nbsp; contextRegExp: /moment$/,</div><div>&nbsp; &nbsp; }),</div><div>&nbsp; ]&nbsp;&nbsp;</div>","zIndex":241}],"html":"IgnorePlugin","collapsed":true,"zIndex":15},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"5f869275-8892-4db4-8b83-255b807d2df1","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"ed41733e-9fb6-479c-925b-c5cf33685d48","children":[],"html":"使用 Thead 多进程处理 eslint 和 babel 任务，速度更快。（需要注意的是，进程启动通信都有开销的，要在比较多代码处理时使用才有效果）","zIndex":242},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"32d730b8-f92d-4b32-934c-03b54de59ead","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"51abcab9-6f50-482d-b6a6-bdde54aba39c","children":[],"html":"多进程打包：开启电脑的多个进程同时干一件事，速度更快。","zIndex":244},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"6f268c05-f935-4f84-851b-a5fe145f59ef","children":[],"html":"需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销。","height":53.22550185546643,"width":594.8073560546886,"zIndex":245}],"html":"what","layout":{"quadrant":1},"zIndex":243},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"b7316578-d251-43a4-bc72-353985b5f5f4","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"15192158-6ae4-4903-871c-5d95eca29417","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"446a93e8-9afa-419e-8ca8-f51c7d087c2f","children":[],"html":"// nodejs核心模块，直接使用<div>const os = require(\"os\");</div><div>// cpu核数</div><div>const threads = os.cpus().length;</div>","zIndex":248}],"html":"我们启动进程的数量就是我们 CPU 的核数","zIndex":247},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"c3754a08-762b-47d7-bcd9-688a4936eced","children":[],"html":"npm i thread-loader -D","zIndex":249},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"2f67d318-0c3b-4784-946c-dfe07cc7686a","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"73b56916-04bf-4de4-a30c-3dc19908ed17","children":[],"html":"{<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.js$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // exclude: /node_modules/, // 排除node_modules代码不编译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include: path.resolve(__dirname, \"../src\"), // 也可以用包含</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loader: \"thread-loader\", // 开启多进程</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workers: threads, // 数量</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loader: \"babel-loader\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheDirectory: true, // 开启babel编译缓存</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],</div><div>},</div>","zIndex":251}],"html":"babel-loader","zIndex":250},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"db55b0f4-7dca-476c-a940-db3dc3924605","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"e8fa5727-870e-4f05-88b9-45b9a0b0a894","children":[],"html":"plugins: [<div>&nbsp; &nbsp; new ESLintWebpackPlugin({</div><div>&nbsp; &nbsp; &nbsp; // 指定检查文件的根目录</div><div>&nbsp; &nbsp; &nbsp; context: path.resolve(__dirname, \"../src\"),</div><div>&nbsp; &nbsp; &nbsp; exclude: \"node_modules\", // 默认值</div><div>&nbsp; &nbsp; &nbsp; cache: true, // 开启缓存</div><div>&nbsp; &nbsp; &nbsp; // 缓存目录</div><div>&nbsp; &nbsp; &nbsp; cacheLocation: path.resolve(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; __dirname,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; \"../node_modules/.cache/.eslintcache\"</div><div>&nbsp; &nbsp; &nbsp; ),</div><div>&nbsp; &nbsp; &nbsp; <span style=\"font-weight:bold;\">threads, // 开启多进程</span></div><div>&nbsp; &nbsp; }),</div><div>&nbsp; ],</div><div>&nbsp; optimization: {</div><div>&nbsp; &nbsp; minimize: true,</div><div>&nbsp; &nbsp; minimizer: [</div><div>&nbsp; &nbsp; &nbsp; // 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了</div><div>&nbsp; &nbsp; &nbsp; new TerserPlugin({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style=\"font-weight:bold;\">parallel: threads // 开启多进程</span></div><div>&nbsp; &nbsp; &nbsp; })</div><div>&nbsp; &nbsp; ],</div><div>&nbsp; }</div>","width":599.2986060546896,"zIndex":253}],"html":"plugins","zIndex":252}],"html":"how","layout":{"quadrant":1},"zIndex":246},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"040c2608-0acf-412b-b476-be529dae14d0","children":[],"html":"项目越来越大，打包速度会越来越慢，提升打包速度主要是提升js的打包速度，而对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。<div>我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了</div>","height":119.44293935546688,"width":570.7091060546886,"layout":{"quadrant":1},"zIndex":254}],"html":"多进程配置 thread-loader","collapsed":true,"zIndex":13},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"a0abcf96-0c16-4238-ab95-da7f406d3f10","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"e68ff0ca-be77-48dd-85f4-e0c9ee3c96c8","children":[],"html":"使用 Cache 对 eslint 和 babel 处理的结果进行缓存，让第二次打包速度更快","zIndex":255},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"5e458e5e-ad3c-4466-b75b-7b592c50e25e","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"e75a8fce-fa7b-47dc-aed1-f811e092963c","children":[],"html":"每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。<div>我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了</div>","zIndex":257}],"html":"why","layout":{"quadrant":1},"zIndex":256},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"b6012ddc-9793-456f-87bc-852c12460417","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"9a16df9a-1587-4a40-9803-791bb7c8bbec","children":[],"html":"对 Eslint 检查 和 Babel 编译结果进行缓存","zIndex":259}],"html":"what","layout":{"quadrant":1},"zIndex":258},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"a8fc22f0-891b-46d6-be5d-e72249a234fd","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"2e442337-4406-4af4-b290-f2abec1e8423","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"f380e198-db03-4875-b6de-aa0975aea60b","children":[],"html":"{<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.js$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include: path.resolve(__dirname, \"../src\"), // 也可以用包含</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loader: \"babel-loader\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheDirectory: true, // 开启babel编译缓存</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheCompression: false, // 缓存文件不要压缩</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>},</div>","zIndex":262}],"html":"babel-loader","zIndex":261},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"f6bfb7fb-e022-48c1-85c3-2402d98049c7","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"bfc5af7f-7ec7-44b0-a152-00cc93c12f06","children":[],"html":"new ESLintWebpackPlugin({<div>&nbsp; &nbsp; &nbsp; // 指定检查文件的根目录</div><div>&nbsp; &nbsp; &nbsp; context: path.resolve(__dirname, \"../src\"),</div><div>&nbsp; &nbsp; &nbsp; exclude: \"node_modules\", // 默认值</div><div>&nbsp; &nbsp; &nbsp; cache: true, // 开启缓存</div><div>&nbsp; &nbsp; &nbsp; // 缓存目录</div><div>&nbsp; &nbsp; &nbsp; cacheLocation: path.resolve(</div><div>&nbsp; &nbsp; &nbsp; &nbsp; __dirname,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; \"../node_modules/.cache/.eslintcache\"</div><div>&nbsp; &nbsp; &nbsp; ),</div><div>}),</div>","zIndex":264}],"html":"eslint plugin","zIndex":263}],"html":"配置","collapsed":true,"layout":{"quadrant":1},"zIndex":260}],"html":"利用缓存","collapsed":true,"zIndex":11}],"html":"优化打包构建速度","layout":{"quadrant":1},"zIndex":20},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"1ec0c64a-0113-45e5-a7e9-73b13cdf1576","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"30818a4b-b6b8-4d6c-838d-0e10cc305a3c","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"20a5d62a-eafa-4ea6-a441-5518289440d9","children":[],"html":"webpack-bundle-analyzer","zIndex":22}],"html":"构建结果分析","zIndex":23},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"1a180c0d-c4fe-4636-ae67-3a4547abc1be","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"07cd5866-cfb4-41a8-b250-949c664b2ee6","children":[],"html":"optimize-css-assets-webpack-plugin&nbsp;","zIndex":265}],"html":"压缩 CSS","layout":{"quadrant":1},"collapsed":true,"zIndex":24},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"102b11ed-5ee8-40e6-9613-003690310a89","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"49a1560b-396b-4b1a-ac73-a223731ad37c","children":[],"html":"purgecss-webpack-plugin","zIndex":30},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"8e852e8c-3cfe-44d8-b0d2-37427b9879e1","children":[],"html":"new PurgecssPlugin({<div>&nbsp; &nbsp; &nbsp; paths: glob.sync(`${PATHS.src}/**/*`, {nodir: true})</div><div>}),</div>","zIndex":29}],"html":"清除无用的 CSS","layout":{"quadrant":1},"zIndex":31},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"d1924529-a47d-4745-b947-25960b3fdead","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"35d07336-5ee1-4154-90c7-44b76f5d085b","children":[],"html":"在生成环境下打包默认会开启 js 压缩，但是当我们手动配置 optimization 选项之后，就不再默认对 js 进行压缩，需要我们手动去配置。","zIndex":266},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"6ad82191-36ec-4ffd-a6f9-bb19beaf367d","children":[],"html":" webpack5 内置了terser-webpack-plugin 插件，所以我们不需重复安装，直接引用就可以了","zIndex":267}],"html":"压缩 JS","layout":{"quadrant":1},"collapsed":true,"zIndex":33},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"c976dfb2-1d91-4c17-af4a-cec158a79d03","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"a1e3cd94-aa4f-4d81-a018-69151b864747","children":[],"html":"使用 @babel/plugin-transform-runtime 插件对 babel 进行处理，让辅助代码从中引入，而不是每个文件都生成辅助代码，从而体积更小。","zIndex":36},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"6b365d65-68f9-495e-85e6-874f4db45473","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"77eeda09-ccae-4c8c-978d-11fa7802ce2f","children":[],"html":"Babel 为编译的每个文件都插入了辅助代码，使代码体积过大","zIndex":268},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"b7ee0cbc-9884-4bf7-9209-b99d7736147a","children":[],"html":"Babel 对一些公共方法使用了非常小的辅助代码，比如 _extend。默认情况下会被添加到每一个需要它的文件中。","zIndex":269},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"5685fb48-1eb3-46d5-ad86-70f6da227a3a","children":[],"html":"你可以将这些辅助代码作为一个独立模块，来避免重复引入","zIndex":270}],"html":"why","collapsed":true,"zIndex":37},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"b15b46af-ae76-4d74-8df8-e14a58027c05","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"4fefe048-727b-4f7a-ad2a-5fe055c43694","children":[],"html":"@babel/plugin-transform-runtime: 禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 @babel/plugin-transform-runtime 并且使所有辅助代码从这里引用","zIndex":271}],"html":"what","collapsed":true,"zIndex":35},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"72ee4e4c-d0e9-45a7-a075-392d3dca25f2","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"b5a0b96d-8afd-4d7e-9b6a-bd3f974e0680","children":[],"html":"{<div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; test: /\\.js$/,</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // exclude: /node_modules/, // 排除node_modules代码不编译</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; include: path.resolve(__dirname, \"../src\"), // 也可以用包含</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; use: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loader: \"thread-loader\", // 开启多进程</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; workers: threads, // 数量</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; loader: \"babel-loader\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; options: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheDirectory: true, // 开启babel编译缓存</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; cacheCompression: false, // 缓存文件不要压缩</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; <span style=\"font-weight:bold;\">plugins: [\"@babel/plugin-transform-runtime\"], </span>// 减少代码体积</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ],</div><div>},</div>","width":690.9756685546895,"zIndex":272}],"html":"how","collapsed":true,"zIndex":34}],"html":"避免babel辅助代码重复引入","layout":{"quadrant":1},"zIndex":38},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"513c0195-c1d5-4061-9572-ce2bbc93d5a9","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"31e328d5-5290-46cc-b8c5-c6cd312b4950","children":[],"html":"使用 Tree Shaking 剔除了没有使用的多余代码，让代码体积更小","zIndex":273},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"7d8ed215-6abd-400d-b3b8-c86bcb175df4","children":[],"html":"Tree Shaking 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码，它依赖 ES Module。","zIndex":274},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"785b36e4-5c02-4e7f-9174-1aa6ab739b03","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"7341dfbb-1555-4ee6-b1d5-592055c8fbfa","children":[],"html":"module.exports = {<div>&nbsp; presets: [</div><div>&nbsp; &nbsp; [</div><div>&nbsp; &nbsp; &nbsp; \"@babel/preset-env\",</div><div>&nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; <span style=\"font-weight:bold;\">module: false,</span></div><div>&nbsp; &nbsp; &nbsp; &nbsp; useBuiltIns: \"entry\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; corejs: \"3.9.1\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; targets: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; chrome: \"58\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ie: \"11\",</div><div>&nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; ],</div><div>&nbsp; ],</div><div>};</div>","height":376.46962685546464,"width":213.95623105469076,"zIndex":276}],"html":"Webpack 已经默认开启了这个功能，需要在 .bablerc 里面设置 model：false，即可在生产环境下默认开启","zIndex":275}],"html":"Tree shaking","collapsed":true,"zIndex":32},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"81505d8e-0fe5-488f-b1e8-ca80f8c89970","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"d00b1abf-e707-44e2-b7b2-8bb09e74aa36","children":[],"html":"Scope Hoisting 即作用域提升，原理是将多个模块放在同一个作用域下，并重命名防止命名冲突，通过这种方式可以减少函数声明和内存开销。","zIndex":27},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"46bff6c7-8a1c-4e6c-a284-ca6152b4cfb0","children":[],"html":"webpack 默认支持，在生产环境下默认开启","zIndex":26},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"9affcc5a-cabd-4406-a786-288f0184512d","children":[],"html":"只支持 es6 代码","zIndex":25}],"html":"Scope Hoisting","layout":{"quadrant":1},"zIndex":28},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"4d5094a3-d8ae-4a08-a439-c3c601d591cc","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"1c2263d0-1406-4f4f-99b8-a669fbc0151f","children":[],"html":"使用 Image Minimizer 对项目中图片进行压缩，体积更小，请求速度更快。（需要注意的是，如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。）","zIndex":277}],"html":"图片压缩","collapsed":true,"zIndex":21}],"html":"优化构建结果","layout":{"quadrant":1},"zIndex":39},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"97098a91-6005-4a02-9973-c165121c33b0","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"120cd3be-b756-4f90-9407-823040abc61f","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"61d4d445-b168-4bc7-bc38-d6be6799db6a","children":[],"html":"配置多个打包入口，多页打包","zIndex":278}],"html":"入口点分割","layout":{"quadrant":1},"collapsed":true,"zIndex":3},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"c9dd6ade-5164-410c-afee-7b66c5140e3c","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"dbb01414-adc4-475a-b6c2-59adb8eee75c","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"acf2974e-9358-413d-a5fb-2f2c907b2638","children":[],"html":"使用 Code Split 对代码进行分割成多个 js 文件，从而使单个文件体积更小，并行加载 js 速度更快。并通过 import 动态导入语法进行按需加载，从而达到需要使用时才加载该资源，不用时不加载资源。同时可以充分利用浏览器缓存","zIndex":280}],"html":"why","zIndex":279},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"84528345-801e-4adb-930c-bcd825ff51c5","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"15c63b25-15b7-48b7-a3bd-1dc31332b2a9","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"b5b301e8-c09e-4771-8b9e-b1eadac32245","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"88dcdd28-6a12-44b5-a344-c1e8797037e7","children":[],"html":"新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹","zIndex":284},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"5b1ce3d9-2af9-4042-9065-175fa237ae8e","children":[],"html":"新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）","zIndex":285},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"a8ebdbc9-823a-4930-9747-7c22c80e0a57","children":[],"html":"当按需加载 chunks 时，并行请求的最大数量小于或等于 30","zIndex":286},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"9c210bfd-378e-4549-bf7e-027b342700c0","children":[],"html":"当加载初始化页面时，并发请求的最大数量小于或等于 30","zIndex":287}],"html":"自动拆分 chunks 默认配置","zIndex":283}],"html":"配置 optimization.splitChunks","zIndex":282},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"545aea2c-c291-4b60-8dce-a98576a31f4d","children":[],"html":"分割文件：将打包生成的文件进行分割，生成多个 js 文件。","zIndex":288},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"87c17565-6b8d-4fd6-b39b-20f35fb12a20","children":[],"html":"按需加载：需要哪个文件就加载哪个文件","zIndex":289}],"html":"what","zIndex":281},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"aa36aad8-7464-4e6e-8cf5-85a33dc07dae","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"88c4cf55-ae4a-4157-a690-61188ad1bd35","children":[],"html":"optimization: {<div>&nbsp; &nbsp; // 代码分割配置</div><div>&nbsp; &nbsp; splitChunks: {</div><div>&nbsp; &nbsp; &nbsp; chunks: \"all\", // 对所有模块都进行分割</div><div>&nbsp; &nbsp; &nbsp; // 其他内容用默认配置即可</div><div>&nbsp; &nbsp; },</div><div>&nbsp; },</div>","height":169.0213143554663,"width":316.2398560546885,"zIndex":291},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"b0544239-7eca-4396-9e23-cfe351037061","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"5584bd17-154d-447d-98c1-9eeaf8699af8","children":[],"html":"document.getElementById(\"btn\").onClick = function () {<div>&nbsp; // eslint会对动态导入语法报错，需要修改eslint配置文件</div><div>&nbsp; // webpackChunkName: \"math\"：这是webpack动态导入模块命名的方式</div><div>&nbsp; // \"math\"将来就会作为[name]的值显示。</div><div>&nbsp; import(/* webpackChunkName: \"math\" */ \"./js/math.js\").then(({ count }) =&gt; {</div><div>&nbsp; &nbsp; console.log(count(2, 1));</div><div>&nbsp; });</div><div>};</div>","zIndex":293}],"html":"动态导入","zIndex":292},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"7ff6b0f6-d8e2-4026-b4bc-02e4a3fc16e6","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"ce79bdcd-4700-44e0-ac00-9db1b0d4d8dd","children":[],"html":"npm i eslint-plugin-import -D","zIndex":295},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"8d11ea56-f9bb-47c4-a748-1d04379433d2","children":[],"html":"// .eslintrc.js<div>module.exports = {</div><div>&nbsp; // 继承 Eslint 规则</div><div>&nbsp; extends: [\"eslint:recommended\"],</div><div>&nbsp; env: {</div><div>&nbsp; &nbsp; node: true, // 启用node中全局变量</div><div>&nbsp; &nbsp; browser: true, // 启用浏览器中全局变量</div><div>&nbsp; },</div><div>&nbsp; plugins: [\"import\"], // 解决动态导入import语法报错问题 --&gt; 实际使用eslint-plugin-import的规则解决的</div><div>&nbsp; parserOptions: {</div><div>&nbsp; &nbsp; ecmaVersion: 6,</div><div>&nbsp; &nbsp; sourceType: \"module\",</div><div>&nbsp; },</div><div>&nbsp; rules: {</div><div>&nbsp; &nbsp; \"no-var\": 2, // 不能使用 var 定义变量</div><div>&nbsp; },</div><div>};</div>","height":426.5783143554647,"width":711.5534185546894,"zIndex":296}],"html":"eslint 配置","collapsed":true,"zIndex":294}],"html":"how","zIndex":290}],"html":"分包配置 + 按需加载","collapsed":true,"zIndex":6},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8e482417-9f1a-4eb2-aab2-4665b5f8d102","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cfa60cbf-9b95-4bec-9cb8-8895210e4296","children":[],"html":"SplitChunksPlugin插件来进行公共模块抽取，利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码","zIndex":297}],"html":"提取公共第三方库","layout":{"quadrant":1},"collapsed":true,"zIndex":8},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"bd0ea06b-99b7-4e2a-9aff-1e780e991678","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"0e4c9b6a-35b7-4c4d-8932-940eeb017806","children":[],"html":"使用 Preload / Prefetch 对代码进行提前加载，等未来需要使用时就能直接使用，从而用户体验更好","zIndex":298},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"e7955a5b-8dd2-4258-8f1b-6cdf08a94f75","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"69a7c1fa-db06-4b7b-ab98-dee808bcf4dc","children":[],"html":"如果资源体积大的话，懒加载会有明显的闪现效果，影响用户体验。需要再浏览器空闲时间，加载后续需要使用的资源","zIndex":300}],"html":"why","zIndex":299},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"f9abe4a5-3a90-4115-9093-99de0807e218","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"514bbc1c-4fbf-4ff1-b6f8-ef22eafc2cc2","children":[],"html":"Preload：告诉浏览器立即加载资源。","zIndex":302},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"423d02cd-54b5-4ec9-8559-1a39c7b6624b","children":[],"html":"Prefetch：告诉浏览器在空闲时才开始加载资源。","zIndex":303},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"5abb147b-edad-4724-9e98-a7402e41324b","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"6c6e2810-4271-4cbf-bd30-37e16f7b77af","children":[],"html":"都只会加载资源，并不执行；都有缓存","zIndex":305}],"html":"共同点","zIndex":304},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"cdc256a5-bfb7-4f3e-b4f3-2d21ac4746ea","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"a4384d1d-4cde-437f-9c10-337aa4639c8e","children":[],"html":"Preload加载优先级高，Prefetch加载优先级低","zIndex":307},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"afc89a74-f209-43c4-a53e-1a0bce319d23","children":[],"html":"Preload只能加载当前页面需要使用的资源，Prefetch可以加载当前页面资源，也可以加载下一个页面需要使用的资源","zIndex":308}],"html":"区别","zIndex":306},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"7af3bae9-56e4-40b9-80cc-aeee50199b1e","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"052859fa-2f92-4d08-b2ea-025170e32623","children":[],"html":"当前页面优先级高的资源用 Preload 加载","zIndex":310},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"8603ac00-bd8a-462b-83ac-f4345363565c","children":[],"html":"下一个页面需要使用的资源用 Prefetch 加载","zIndex":311}],"html":"总结","zIndex":309},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"dd9a887c-d9ad-481c-b951-c7423ffe2ee8","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"59c3818c-b537-4da5-af77-e9f8029fc09b","children":[],"html":"兼容性差，我们可以去 Can I Use 网站查询 API 的兼容性问题，Preload 相对于 Prefetch 兼容性好一点","zIndex":313}],"html":"问题","zIndex":312}],"html":"what","collapsed":true,"zIndex":301},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"45d7e416-5323-483d-862f-6b11b45d0371","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"db53d9e2-ef6b-47d8-9a94-496c052a1b9a","children":[],"html":"npm i @vue/preload-webpack-plugin -D","zIndex":315},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"326c275a-0f3a-4f6d-ac36-9ab0c8e5e905","children":[],"html":"new PreloadWebpackPlugin({<div>&nbsp; &nbsp; &nbsp; rel: \"preload\", // preload兼容性更好</div><div>&nbsp; &nbsp; &nbsp; as: \"script\",</div><div>&nbsp; &nbsp; &nbsp; // rel: 'prefetch' // prefetch兼容性更差</div><div>}),</div>","zIndex":316}],"html":"how","collapsed":true,"zIndex":314},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"be6ef61e-336d-403d-ab01-32f14d35438e","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"9fb623a6-4237-4b4e-a9a5-5e0fe1cc7989","children":[],"html":"// 按需加载<div>img.addEventListener('click', () =&gt; {</div><div>&nbsp; import( /* webpackPrefetch: true */ './desc').then(({ default: element }) =&gt; {</div><div>&nbsp; &nbsp; console.log(element)</div><div>&nbsp; &nbsp; document.body.appendChild(element)</div><div>&nbsp; })</div><div>})</div>","zIndex":318},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"fc9cfe67-0b67-4af5-88ab-0bff650db590","children":[],"html":"import(/* webpackPreload: true */ 'ChartingLibrary');","zIndex":319}],"html":"官网示例","zIndex":317}],"html":"preload / prefetch","collapsed":true,"zIndex":9},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"f7ddbad2-d15e-46b4-8441-51c2c0c11d73","children":[{"border":{"shape":"rect","stroke":"transparent"},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"3317b2c4-6624-45bf-9e1b-0369155dd0dc","children":[],"html":"使用 Network Cache 能对输出资源文件进行更好的命名，将来好做缓存，从而用户体验更好","zIndex":320},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"655dd54a-3e07-420d-ab07-bbd0bdf5b780","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"f14f7a88-a47f-42aa-9ca2-77c4b1107ace","children":[],"html":"对静态资源做缓存优化，浏览器再次请求资源可以从缓存中读取，速度快","zIndex":322}],"html":"why","zIndex":321},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"55c5225e-b8f2-4976-b2fe-fb8fb18bb31a","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"1ee651d0-d9c0-41cf-84a8-add7bf5ba954","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"1efc4f4b-5f75-4fb7-b7d4-1da2c9e8e0fc","children":[],"html":"每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。","zIndex":325}],"html":"fullhash","zIndex":324},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"db7946b1-b378-49ee-a1f3-82ddb2541f0e","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"42e4917a-575e-497f-95c9-a75ab4983882","children":[],"html":"根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。我们 js 和 css 是同一个引入，会共享一个 hash 值。","zIndex":327}],"html":"chunkhash","zIndex":326},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"50d53ab1-2b6c-4eed-866c-38f8366a9548","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"430f3912-52df-4473-8881-75c501ad1f3d","children":[],"html":"根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。","zIndex":329}],"html":"contenthash","zIndex":328},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"8f3b76ef-8ab6-4682-88a6-45b0fdddd786","children":[],"html":"output: {<div>&nbsp; &nbsp; path: path.resolve(__dirname, \"../dist\"), // 生产模式需要输出</div><div>&nbsp; &nbsp; // [contenthash:8]使用contenthash，取8位长度</div><div>&nbsp; &nbsp; filename: \"static/js/[name].[contenthash:8].js\", // 入口文件打包输出资源命名方式</div><div>&nbsp; &nbsp; chunkFilename: \"static/js/[name].[contenthash:8].chunk.js\", // 动态导入输出资源命名方式</div><div>&nbsp; &nbsp; assetModuleFilename: \"static/media/[name].[hash][ext]\", // 图片、字体等资源命名方式（注意用hash）</div><div>&nbsp; &nbsp; clean: true,</div><div>&nbsp; },</div>","height":206.5770993611343,"width":706.9002078120602,"zIndex":330}],"html":"what","zIndex":323},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"79c1a4d2-fed6-4735-bd2e-251b8ef5d0d8","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"7f68f187-495c-45bf-90e4-7cbeaf685a5e","children":[],"html":"使用contenthash，当一个文件依赖的文件改变，而导致这个文件的hash值改变，缓存失效","zIndex":332},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"5dd9acbf-0709-4c9c-82de-476eb0debb8b","children":[],"html":"解决：将hash值保存在一个runtime文件中。runtime 文件只保存文件的 hash 值和它们与文件关系，整个文件体积就比较小，所以变化重新请求的代价也小","height":85.04081818199643,"width":547.5407973812194,"zIndex":333},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"c0644909-9038-4643-bf28-249eecb27664","children":[],"html":"optimization:{<div>&nbsp; &nbsp; // 提取runtime文件</div><div>&nbsp; &nbsp; runtimeChunk: {</div><div>&nbsp; &nbsp; &nbsp; name: (entrypoint) =&gt; `runtime~${entrypoint.name}`, // runtime文件命名规则</div><div>&nbsp; &nbsp; },</div><div>}</div>","width":557.5181216442584,"zIndex":334}],"html":"问题","zIndex":331}],"html":"network cache","collapsed":true,"zIndex":7},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b85c8176-81a8-4209-9507-d8315b9f7f52","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d2dfdc2c-b517-48a5-9a23-c71106d15d98","children":[],"html":"在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径","zIndex":4}],"html":"利用CDN加速","layout":{"quadrant":1},"zIndex":5},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"1c21b870-6d25-4901-8c82-91f52e34322f","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"c93b7ed6-b3cb-4d36-af3d-b9fbb5312d84","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"92d76db9-656e-4a4c-b5e4-a1a297029de9","children":[],"html":"开发 Web App 项目，项目一旦处于网络离线情况，就没法访问了。我们希望给项目提供离线体验。","zIndex":336}],"html":"why","zIndex":335},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"1d98e7a8-0477-4fcf-ad98-5ef35450f02d","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"cdfebbde-a3dd-49aa-856e-951221330f08","children":[],"html":"渐进式网络应用程序(progressive web application - PWA)：是一种可以提供类似于 native app(原生应用程序) 体验的 Web App 的技术。<div>其中最重要的是，在 离线(offline) 时应用程序能够继续运行功能。</div><div>内部通过 Service Workers 技术实现的。</div>","zIndex":338}],"html":"what","zIndex":337},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"78c48221-c5cb-44d6-9a91-47962c1e9a05","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"dbae8de8-6cbd-42d7-8164-3aa732bbc677","children":[],"html":"npm i workbox-webpack-plugin -D","zIndex":340},{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"4a07a414-cc6a-4709-bcea-01ec993072c9","children":[],"html":"new WorkboxPlugin.GenerateSW({<div>&nbsp; &nbsp; &nbsp; // 这些选项帮助快速启用 ServiceWorkers</div><div>&nbsp; &nbsp; &nbsp; // 不允许遗留任何“旧的” ServiceWorkers</div><div>&nbsp; &nbsp; &nbsp; clientsClaim: true,</div><div>&nbsp; &nbsp; &nbsp; skipWaiting: true,</div><div>}),</div>","zIndex":341},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"bd74cbc8-c0ad-4463-8455-9b135663b07d","children":[{"border":{"shape":"rect","stroke":"#6ec4c4"},"defaultContentStyle":{"color":"#262626"},"id":"fcb95e73-eeaf-40ec-942b-904e650f877a","children":[],"html":"if (\"serviceWorker\" in navigator) {<div>&nbsp; window.addEventListener(\"load\", () =&gt; {</div><div>&nbsp; &nbsp; navigator.serviceWorker</div><div>&nbsp; &nbsp; &nbsp; .register(\"/service-worker.js\")</div><div>&nbsp; &nbsp; &nbsp; .then((registration) =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; console.log(\"SW registered: \", registration);</div><div>&nbsp; &nbsp; &nbsp; })</div><div>&nbsp; &nbsp; &nbsp; .catch((registrationError) =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; console.log(\"SW registration failed: \", registrationError);</div><div>&nbsp; &nbsp; &nbsp; });</div><div>&nbsp; });</div><div>}</div>","zIndex":343}],"html":"main.js","zIndex":342},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"39611a4e-79e3-4888-bb97-cf87d5bb2e58","children":[{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"e05ecc4f-b05c-4d0e-82ae-fd2dc43e054b","children":[],"html":"npm i serve -g","zIndex":345},{"border":{"shape":"rect","stroke":"transparent"},"defaultContentStyle":{"color":"#262626"},"id":"7e4df74c-60f7-4df8-bfc8-ff124cdf7f6b","children":[],"html":"serve dist","zIndex":346}],"html":"解决路径问题","zIndex":344}],"html":"how","zIndex":339}],"html":"pwa","collapsed":true,"layout":{"quadrant":1},"zIndex":2}],"html":"优化代码运行性能","layout":{"quadrant":1},"zIndex":10},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"defaultContentStyle":{"color":"#262626"},"id":"7776616b-c6e5-4d31-8eb1-13388ffdcb62","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"41b546be-63de-4e1d-b6eb-1c0a875366e4","children":[],"html":"服务端设置http缓存头（cache-control）","zIndex":347},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b28a3f53-2f95-4c9f-849c-2ff88e60050a","children":[],"html":"打包依赖和运行时用到不同的chunk，即作为splitChunk，因为他们几乎是不变的","height":62.26530797791452,"width":556.6927248188617,"zIndex":348},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d994ae32-a96d-408e-aa55-fc8948aeaa34","children":[],"html":"延迟加载：使用import()方式，可以动态加载的文件分到独立的chunk，以得到自己的chunkhash","zIndex":349},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e8e391eb-9d24-4278-84e3-523a78baeb8d","children":[],"html":"保持hash值的稳定：编译过程和文件内通的更改尽量不影响其他文件hash的计算，对于低版本webpack生成的增量数字id不稳定问题，可用hashedModuleIdsPlugin基于文件路径生成解决","zIndex":350}],"html":"webpack如何实现持久化缓存","layout":{"quadrant":1},"collapsed":true,"zIndex":0}],"html":"优化","icons":{"priority":1},"zIndex":65,"collapsed":true},{"border":{"shape":"rect","stroke":"transparent"},"treeEdge":{"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"388d9616-c2ab-43c0-93eb-7ae285328641","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"391b90ef-d7c3-46dd-aead-8ebe1b5b2383","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"02e25631-6556-42ea-92f1-31b2ca03bfee","children":[],"html":"webpack把⼀切当成<span style=\"font-weight:bold;\">模块</span>，它会递归地构建⼀个<span style=\"font-weight:bold;\">依赖关系图</span>，使用<span style=\"font-weight:bold;\">loaders和plugins</span>对模块进行处理和优化，最终将各种资源打包成<span style=\"font-weight:bold;\">静态文件</span>","layout":{"quadrant":1},"zIndex":351},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"92d98983-1563-495a-8063-d4ad9268af27","children":[],"html":"Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。","layout":{"quadrant":1},"zIndex":352},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6a6c9718-596f-44cc-9558-c7b78b172836","children":[],"html":"打包后的文件是一个<span style=\"font-weight:bold;\">立即执行函数</span>，这个立即执行函数接收一个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。立即执行函数内部则处理模块之间的引用，执行模块等。","layout":{"quadrant":1},"zIndex":353}],"html":"模块打包原理","layout":{"quadrant":1},"collapsed":true,"zIndex":41},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"rgba(0, 0, 0, 0)","stroke":"transparent"},"id":"30ccefad-ce82-485c-a843-ae915a3c0aab","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"269c74dd-a703-4b2e-ba44-203b70c82780","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6f8ca084-edbf-4147-919a-eaacc637a473","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8d3cf1f4-7e0c-46e9-9349-1ae9fcd78e6f","children":[],"html":"帮忙webpack识别它不能识别的模块","zIndex":356},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"bb6603fd-2f2e-4454-bae4-bef036f968b6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c06ef3e3-7a09-4a44-ab39-6f8d4fd18b04","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"816e6790-b1d6-4252-8162-56fa2b175b05","children":[],"html":"content：文件内容","zIndex":359},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"10c0ef18-744f-4386-8e6d-accef9970b8f","children":[],"html":"map：sourcemap","zIndex":360},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"11dff275-15ea-4054-9b5f-4c7780060d09","children":[],"html":"meta：别的loader传递的数据","zIndex":361}],"html":"loader 接收三个参数","zIndex":358}],"html":"loader 是一个函数，当webpack解析资源时，会调用相应的loader去处理；loader接收到文件内容作为参数，处理后返回内容出去","zIndex":357},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1ee83009-a1d7-460e-8c52-1ae9a0d4af0c","children":[],"html":"针对每个文件类型，loader支持以数组的形式配置多个，在webpack转换文件类型时，会按照顺序链式调用每一个loader，前一个loader返回的内容会作为下一个loader的入参","zIndex":362}],"html":"概念","zIndex":355},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"15131137-0a12-47d2-b38a-08d2fa7b51af","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3ffc3375-ee68-4cb7-8ede-d809738311ba","children":[],"html":"相同优先级：从下到上，从右到左","zIndex":364},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"2d09f156-4259-4dc3-a6c1-b1ed1cbbc4c6","children":[],"html":"enforce: pre &gt; normal &gt; inline &gt; post","zIndex":365}],"html":"执行顺序","zIndex":363},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b9bd840a-fac3-4789-b3a9-1d0054de846a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7bc255c4-4365-45b8-9a03-9946ef174266","children":[],"html":"同步loader","zIndex":367},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"25213392-dad1-409d-bac0-0e11160ef407","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"49cfd8d9-03fb-4fcf-a290-bbc85d828b3c","children":[],"html":"需要调用async方法得到callback","layout":{"quadrant":1},"zIndex":369},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"dff92cf6-9ff6-4948-a532-ef14d59e21c1","children":[],"html":"会等异步操作执行完，再执行下一个loader","zIndex":370}],"html":"异步loader","zIndex":368},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5580aa01-2961-4919-8bd7-be327908ade8","children":[],"html":"Raw loader","zIndex":371},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"34e20849-49d8-49ee-8909-fc47e3d39313","children":[],"html":"Pitching Loader","zIndex":372}],"layout":{"quadrant":1},"html":"分类","zIndex":366},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"158e7bfe-dc24-4d68-8378-6252d5592777","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1d4622bb-14c3-4c02-ab3c-592f0d459a7d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8fc21342-7f98-4618-ac89-da35e2c33b35","children":[],"html":"异步回调loader，返回this.callback","zIndex":375}],"html":"this.async","zIndex":374},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4de8290b-8bf9-42b9-b950-c49b378ad5af","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"26ae36bd-1c66-4fc3-9160-96c599659010","children":[],"html":"可以同步或者异步调用并返回多个结果的函数","zIndex":377}],"html":"this.callback","zIndex":376},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fcc69ed9-18c5-49a8-9379-b0167a268873","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"0f9207ac-e486-49b8-ba65-6af9363de3a4","children":[],"html":"获取loader的options","zIndex":379}],"html":"this.getOptions(schema)","zIndex":378},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3cb40769-5212-4b94-a419-7533d9454a39","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c2afc64a-2817-48eb-9ac6-12addec259b5","children":[],"html":"产生一个文件","zIndex":381}],"html":"this.emitFile","zIndex":380},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"94235a46-7cde-4cde-ba04-e1c7075f2b86","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c7784e17-49da-4426-9123-de556c238f3d","children":[],"html":"返回一个相对路径","zIndex":383}],"html":"this.utils.contextify","zIndex":382},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d71f9613-9861-4f09-97a4-10310f40df1b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"887a6dda-ae1c-4d21-9de1-9b4d6c0cf42a","children":[],"html":"返回一个绝对路径","zIndex":385}],"html":"this.utils.absolutify","zIndex":384}],"html":"loader api","zIndex":373}],"html":"基础","layout":{"quadrant":1},"zIndex":354},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"25b1c5b2-5c91-4443-b33e-c96cd37f5490","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"728c8913-5249-44cb-b3a6-7654bf39d1f2","children":[{"border":{"shape":"rect","stroke":"#96c8ec","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"868a51b6-299e-4efc-9f45-750802acb3e1","children":[],"html":"// loaders/clean-log-loader.js<div>module.exports = function cleanLogLoader(content) {</div><div>&nbsp; // 将console.log替换为空</div><div>&nbsp; return content.replace(/console\\.log\\(.*\\);?/g, \"\");</div><div>};</div>","zIndex":388}],"html":"手写clean-log-loader","zIndex":387},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c9ba5a2e-89db-41ef-a17e-853feb62086e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"11edc82c-616e-45ef-995b-665b92467ede","children":[],"html":"作用：编译js代码，将ES6+语法便于成ES5-语法","zIndex":390},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ea4f02ce-c908-421a-9204-f584cfb749ec","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5520321c-81f9-418b-a689-60a34d7d9e93","children":[],"html":"npm i @babel/core @babel/preset-env -D","zIndex":392}],"html":"下载依赖","zIndex":391},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"dc994483-1042-4bd9-804e-aaf281e2efae","children":[{"border":{"shape":"rect","stroke":"#69b1e4","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"397e5e7d-0547-410f-ba57-e2147d074403","children":[],"html":"const schema = require(\"./schema.json\");<div>const babel = require(\"@babel/core\");</div><div><br></div><div>module.exports = function (content) {</div><div>&nbsp; const options = this.getOptions(schema);</div><div>&nbsp; // 使用异步loader</div><div>&nbsp; const callback = this.async();</div><div>&nbsp; // 使用babel对js代码进行编译</div><div>&nbsp; babel.transform(content, options, function (err, result) {</div><div>&nbsp; &nbsp; callback(err, result.code);</div><div>&nbsp; });</div><div>};</div>","zIndex":394}],"html":"loaders/babel-loader/index.js","zIndex":393},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"85aaaafb-3ab8-45a6-a0aa-b1e4122273b1","children":[{"border":{"shape":"rect","stroke":"#69b1e4","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1348e192-2bb2-4f91-9824-45d1d41e52ed","children":[],"html":"{<div>&nbsp; \"type\": \"object\",</div><div>&nbsp; \"properties\": {</div><div>&nbsp; &nbsp; \"presets\": {</div><div>&nbsp; &nbsp; &nbsp; \"type\": \"array\"</div><div>&nbsp; &nbsp; }</div><div>&nbsp; },</div><div>&nbsp; \"additionalProperties\": true</div><div>}</div>","zIndex":396}],"html":"loaders/banner-loader/schema.json","zIndex":395}],"html":"手写babel-loader","zIndex":389}],"html":"如何编写 Loader","zIndex":386}],"html":"Loader 原理","treeEdge":{"stroke":"#69B1E4","stroke-width":2},"collapsed":true,"zIndex":43},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"c85fe600-0848-4630-a9cb-3c762b99ccef","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"84daffc0-f34f-4516-9a50-04e6f6c094f2","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4d213cb4-90f0-43d2-bfff-0beb76274d26","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f5423b30-162b-4257-9702-346860474f03","children":[],"layout":{"quadrant":1},"html":"通过插件可以加入自定义的构建行为，增强 webpack 构建能力","zIndex":399}],"html":"概念","zIndex":398},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"953cc3a4-9156-4d97-ae50-8bd4b53e1146","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"90c69bf3-a8b6-46d2-bf7b-cb8c10218b40","children":[],"html":"webpack在编译代码过程中，会触发一系列的Tapable钩子事件，插件所做的，就是找到对应的钩子，往上面挂上自己的任务，也就是注册事件。所以，在webpack构建过程中，插件注册的事件就会随着钩子的触发而执行。","layout":{"quadrant":1},"zIndex":401}],"html":"工作原理","zIndex":400},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d7fbb3c8-7c42-45e4-9aa9-4c281de21019","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9a54e033-c865-4511-aefa-329445b6b154","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"12807aac-d8a5-40db-9ada-bb632b52d3ef","children":[],"html":"钩子的本质就是：事件。为了方便我们直接介入和控制编译过程，webpack 把<span style=\"font-weight:bold;\">编译过程中触发的各类关键事件封装成事件接口暴露出来</span>。这些接口被称做：hooks（钩子）。开发插件，离不开这些钩子。","zIndex":404}],"html":"钩子","zIndex":403},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0de89309-40ed-4e2c-84af-b81eb67fba0e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"479e83da-603d-4ed8-8ad7-f0a9652c826b","children":[],"html":"Tapable 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。webpack 中目前有十种 hooks","zIndex":406},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2b5c8281-fb62-4584-9be7-129f51fc137c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"428604ef-391b-482d-bc8f-23741fc59d9c","children":[],"html":"tap：可以注册同步钩子和异步钩子","zIndex":408},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4cfd4301-29b6-4595-8f4a-1310a88d5602","children":[],"html":"tapAsync：回调方式注册异步钩子","zIndex":409},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fa86e083-7a45-4fbb-84b6-8c5876fd424f","children":[],"html":"tapPromise：Promise 方式注册异步钩子","zIndex":410}],"html":"tapable 还统一暴露了三个方法给插件，用于注入不同类型的自定义构建行为","zIndex":407}],"html":"Tapable","zIndex":405}],"html":"webpack内部的钩子","zIndex":402},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"270e6202-4165-43b2-a70b-32374cb2bf3d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c925fcfe-acef-40c3-a7c2-2e4c223fb3b3","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"545abb79-9bc6-4583-b9b6-ee26f0172246","children":[],"html":"compiler 对象中保存着完整的 Webpack 环境配置","zIndex":413},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"29d953df-0b66-4719-bc6c-014e4027bb2d","children":[],"html":"每次启动 webpack 构建时它都是一个独一无二，<span style=\"font-weight:bold;\">仅会创建一次</span>的对象","zIndex":414},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"93957d87-71b7-4e4e-b90f-d5bf29d35076","children":[],"html":"这个对象会在首次启动 Webpack 时创建，我们可以通过 compiler 对象上访问到 Webapck 的主环境配置，比如 loader 、 plugin 等等配置信息。","zIndex":415},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"73789a90-875d-4e82-9997-b7fc397aa5d0","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e686e309-8683-4fb2-8844-41c806f286c5","children":[],"html":"compiler.options 可以访问本次启动 webpack 时候所有的配置文件，包括但不限于 loaders 、 entry 、 output 、 plugin 等等完整配置信息","zIndex":417},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a2fb7bfd-b187-43e4-a5fb-51a0c8671c02","children":[],"html":"compiler.inputFileSystem 和 compiler.outputFileSystem 可以进行文件操作，相当于 Nodejs 中 fs。","zIndex":418},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"69b60cd8-0559-48f8-b515-8936ce573549","children":[],"html":"compiler.hooks 可以注册 tapable 的不同种类 Hook，从而可以在 compiler 生命周期中植入不同的逻辑。","zIndex":419}],"html":"主要属性","zIndex":416}],"html":"Compiler","zIndex":412},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dc3fab81-0833-4cd5-9efa-f16f71437e35","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"935bcd69-32a1-4fda-ab61-deecb88d04ea","children":[],"html":"compilation 对象代表一次资源的构建，compilation 实例能够访问所有的模块和它们的依赖。","zIndex":421},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"de9784c5-fe1d-4bc1-8ed2-7ae80be4b4d8","children":[],"html":"一个 compilation 对象会对构建依赖图中所有模块，进行编译。 在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)。","zIndex":422},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a7cbdd72-7fe5-478e-81e6-a52f65b5b6e0","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cd508988-307e-432e-adbf-9490708f8e56","children":[],"html":"compilation.modules 可以访问所有模块，打包的每一个文件都是一个模块","zIndex":424},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"14eb905b-0e8c-4c02-af2c-46011d355861","children":[],"html":"compilation.chunks chunk 即是多个 modules 组成而来的一个代码块。入口文件引入的资源组成一个 chunk，通过代码分割的模块又是另外的 chunk","zIndex":425},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ed339fc3-b59b-437a-abb7-6c6f82abd447","children":[],"html":"compilation.assets 可以访问本次打包生成所有文件的结果","zIndex":426},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cc8921c4-722b-4ca3-a862-503357572422","children":[],"html":"compilation.hooks 可以注册 tapable 的不同种类 Hook，用于在 compilation 编译模块阶段进行逻辑添加以及修改","zIndex":427}],"html":"主要属性","zIndex":423}],"html":"Compilation","zIndex":420},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"85f8e12f-328f-4fa6-8155-6e1d966e5580","children":[{"border":{"shape":"rect","stroke":"#e482d4","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dbf08747-af27-40af-9e29-532d09e37d67","children":[],"html":"<div style=\"text-align:center;\">&#8203;<br></div>","height":609.2700000000018,"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1712922596964-aa4dd5de-d2d0-4f9d-be0c-2a369c54ff44.png","naturalWidth":1315,"naturalHeight":2000,"uploadInfo":{"hash":"c2af995aad90c26bb4232b73e605e85f435e829c6aa3925c83a5340a2ed19504","fileName":"yuque_diagram (7).png","fileType":"image/png","fileSize":266674,"localTempSrc":"blob:https://www.yuque.com/f54c9840-8601-4027-b58f-0ef5b207897e","state":-2},"width":390.0750250000012,"height":593.2700000000018},"width":430.72373105468796,"zIndex":429}],"html":"生命周期","zIndex":428}],"html":"Plugin 构建对象","zIndex":411}],"html":"基础","layout":{"quadrant":1},"zIndex":397},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d5879daa-b8a1-4a39-8953-a0b4d0033d86","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"595bc177-1b08-46cd-98aa-298b61de0d80","children":[],"html":"1. webpack 读取配置时，会new plugin实例，执行插件的constructor方法","width":520.8290668192185,"zIndex":431},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bd76e052-f158-4fa5-b613-a09c5114db43","children":[],"html":"2. webpack 创建 compiler 对象","zIndex":432},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"97139f92-8956-4858-b5a1-4bbf0cff745c","children":[],"html":"3. 遍历所有插件，调用插件的apply 方法","zIndex":433},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c3d3c995-8bd7-4d77-a30e-991423b8072a","children":[],"html":"4. 执行剩下的编译流程 (触发各个hooks事件)","zIndex":434}],"html":"实现原理","collapsed":true,"zIndex":430},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bd513044-1e6b-4b13-b581-76c67b647e9b","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"410be45d-6740-4d70-81ff-625b8eb822fa","children":[],"html":"compiler 暴露了和 Webpack 整个生命周期相关的钩子","zIndex":436},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8e7d79dc-6f23-4608-b2d3-9c162aa94314","children":[],"html":"compilation 暴露了与模块和依赖有关的粒度更小的事件钩子","zIndex":437},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c97e3a14-2e53-4718-b88e-140beb9f3d8c","children":[],"html":"插件需要在其原型上绑定apply方法，才能访问 compiler 实例","zIndex":438},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f641533a-146e-4601-a91f-d8c6058c4d71","children":[],"html":"传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件","zIndex":439},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"40257989-4be1-4686-9944-015aefa9a646","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"778b7218-026b-4839-941b-83969f115647","children":[],"html":"emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)","zIndex":441},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ac68ad8b-6b7d-47b8-baa7-ea767598c9dd","children":[],"html":"watch-run 当依赖的文件发生变化时会触发","zIndex":442}],"html":"找出合适的事件点去完成想要的功能","zIndex":440},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"745e4524-60a0-4a0f-88f6-6d9ed96770b6","children":[],"html":"异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住","zIndex":443},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"14e0d7e3-7ace-4ada-97d6-098409046ab8","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b335e0d3-6bdb-429c-a4a9-b135c8fe4f92","children":[],"html":"作用：给打包输出文件添加注释","zIndex":445},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bfb4d5ab-ea1b-47f4-a1a8-e0f23eddf97a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d71a7a05-eb14-486a-a43e-69c3377dc3cd","children":[],"html":"需要打包输出前添加注释：需要使用 compiler.hooks.emit 钩子, 它是打包输出前触发","zIndex":447},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e0b35418-003b-4ac5-82c9-5dca0a7ced61","children":[],"html":"如何获取打包输出的资源？compilation.assets 可以获取所有即将输出的资源文件","zIndex":448},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ac076e23-e111-4b8b-8ea6-8080ef417ac6","children":[{"border":{"shape":"rect","stroke":"#e482d4","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"329cbe4b-c8f8-41e5-ab08-ef804505fee9","children":[],"html":"// plugins/banner-webpack-plugin.js<div>class BannerWebpackPlugin {</div><div>&nbsp; constructor(options = {}) {</div><div>&nbsp; &nbsp; this.options = options;</div><div>&nbsp; }</div><div><br></div><div>&nbsp; apply(compiler) {</div><div>&nbsp; &nbsp; // 需要处理文件</div><div>&nbsp; &nbsp; const extensions = [\"js\", \"css\"];</div><div><br></div><div>&nbsp; &nbsp; // emit是异步串行钩子</div><div>&nbsp; &nbsp; compiler.hooks.emit.tapAsync(\"BannerWebpackPlugin\", (compilation, callback) =&gt; {</div><div>&nbsp; &nbsp; &nbsp; // compilation.assets包含所有即将输出的资源</div><div>&nbsp; &nbsp; &nbsp; // 通过过滤只保留需要处理的文件</div><div>&nbsp; &nbsp; &nbsp; const assetPaths = Object.keys(compilation.assets).filter((path) =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const splitted = path.split(\".\");</div><div>&nbsp; &nbsp; &nbsp; &nbsp; return extensions.includes(splitted[splitted.length - 1]);</div><div>&nbsp; &nbsp; &nbsp; });</div><div><br></div><div>&nbsp; &nbsp; &nbsp; assetPaths.forEach((assetPath) =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const asset = compilation.assets[assetPath];</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; const source = `/*</div><div>* Author: ${this.options.author}</div><div>*/\\n${asset.source()}`;</div><div><br></div><div>&nbsp; &nbsp; &nbsp; &nbsp; // 覆盖资源</div><div>&nbsp; &nbsp; &nbsp; &nbsp; compilation.assets[assetPath] = {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 资源内容</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; source() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return source;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 资源大小</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; size() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return source.length;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; };</div><div>&nbsp; &nbsp; &nbsp; });</div><div><br></div><div>&nbsp; &nbsp; &nbsp; callback();</div><div>&nbsp; &nbsp; });</div><div>&nbsp; }</div><div>}</div><div><br></div><div>module.exports = BannerWebpackPlugin;</div>","height":1064.1562518554565,"width":620.1912310546886,"zIndex":450}],"html":"实现","collapsed":true,"zIndex":449}],"html":"开发思路","zIndex":446}],"html":"开发一个插件","collapsed":true,"zIndex":444}],"html":"如何编写 Plugin","collapsed":true,"zIndex":435}],"html":"Plugin 原理","collapsed":true,"layout":{"quadrant":1},"zIndex":45},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#77C386"},"defaultContentStyle":{"color":"#262626"},"id":"7769389c-9407-4150-b12a-6c2becbd8a50","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4e92ffa8-6d63-4a4b-ae22-a7b417386d3e","children":[],"html":"treeShaking 也叫摇树优化，是一种通过移除多于代码，来优化打包体积的，生产环境默认开启","zIndex":451},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3559470c-c4ad-4fd6-b0d9-a7dac4fee174","children":[],"html":"可以在代码不运行的状态下，分析出不需要的代码；","zIndex":452},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"11d66594-535e-49cb-a92e-2cb41714d357","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d35c71a1-323e-48eb-aff6-4d6fcfe6e3d4","children":[],"html":"ES6 Module引入进行静态分析，所以编译时能正确判断到底加载了哪些模块","zIndex":454},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2ebe6b88-0397-4643-b76d-8c547e1088f1","children":[],"html":"判断哪些模块和变量没有被使用或者引用，进而删除对应代码","zIndex":455}],"html":"实现方式是利用了ES6模块的规范","zIndex":453}],"html":"TreeShaking 原理","layout":{"quadrant":1},"collapsed":true,"zIndex":46},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"rgba(0, 0, 0, 0)","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#77C386"},"id":"9f3ca60d-fa22-454a-913f-25c84ba695bb","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"ec197182-affe-48aa-b17a-be419d1bb5b7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b5dfe975-c06e-4184-81f3-98f28c35ad51","children":[],"html":"HMR是webpack的热更新功能，这个机制可以做到不用刷新浏览器就能将更新后的模块替换掉旧的模块。可以提高开发效率。","zIndex":457}],"html":"概念","zIndex":456},{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"4063c682-83e8-4082-9111-fd64518eb2b5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d6dfcbdb-d298-417f-a257-a57068e9e735","children":[],"html":"1. webpack在构建bundle时，往每个bundle中加入一段 HMR runtime 的js 和一段监听Websocket消息的js","zIndex":459},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"326cf28f-2985-42ba-afb2-1d462f4684a1","children":[],"html":"2. 文件修改会触发webpack重新构建","zIndex":460},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9aa31893-5686-4670-bd36-6b128f36d1ed","children":[],"html":"3. 服务器(webpack dev server)与浏览器维护了一个Websocket，当本地资源发送变化时，WDS会向浏览器推送更新，并带上构建时的hash。","zIndex":461},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3ec55be4-c1b1-4e86-997a-f02cdac9cac8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1f12193c-69ef-4da5-8276-47f0c8cc9550","children":[],"html":"拿到增加更新后的处理，由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。","zIndex":463}],"html":"4. 浏览器通过jsonp拉取更新的模块文件，jsonp回调触发模块热替换，实现chunk的增量更新","zIndex":462}],"html":"原理","zIndex":458}],"html":"<a href=\"https://zhuanlan.zhihu.com/p/30669007\" target=\"_blank\" style>HMR 热更新实现原理</a>","collapsed":true,"zIndex":44},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E48484"},"defaultContentStyle":{"color":"#262626"},"id":"d5d806e5-8e98-454f-ba76-d18ead6cce3f","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b75a4c69-fdff-4caa-8fcf-e60174deb477","children":[],"html":"解析：将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程","zIndex":464},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"16a9926c-8b36-450b-9404-1d3c3de2616d","children":[],"html":"转换：对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作生产新的 AST","zIndex":465},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"88a7f6b7-c986-49b8-b8e3-7707833fafe8","children":[],"html":"生成：将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator","zIndex":466}],"html":"Babel 原理","collapsed":true,"layout":{"quadrant":1},"zIndex":42},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#e48484"},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9f98aef2-7062-447c-8f61-1eb82fb5a951","children":[],"html":"Webpack 核心库 Tapabel","zIndex":40}],"html":"原理","layout":{"quadrant":1},"icons":{"priority":2},"zIndex":64,"collapsed":true},{"border":{"shape":"rect","stroke":"transparent"},"treeEdge":{"stroke":"#DFB85D"},"defaultContentStyle":{"color":"#262626"},"id":"7fc27bc4-848b-486d-8b7f-3f612fab3cab","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5125018c-cf20-414e-b1b2-1d27b78b2c3d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8b2e305f-004f-416f-b991-bbfae33582eb","children":[],"html":"webpack每次编译都需要重新构建","zIndex":49},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5d4e83f9-37e2-4fea-920e-eeed12b9b297","children":[],"html":"vite使用浏览器原生支持的ESM规范来执行代码，开发阶段不需要编译","zIndex":51},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9d75928d-6cd6-4757-b69a-c8ad2995cb67","children":[],"html":"vite会从文件入口出发，遇到import语句，将对应的模块通过http请求加载到浏览器中","zIndex":50},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"07a78409-74b5-4de4-a95e-312d1753d3c3","children":[],"html":"项目越大，vite开发时的优势越明显","zIndex":48}],"html":"vite","layout":{"quadrant":1},"zIndex":52},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2cb48e96-2fff-4000-9ee0-a13da235446b","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"204bd4d3-5a8a-4278-a703-07f22da50961","children":[],"html":"Grunt、Gulp是基于任务运行的⼯具，和Webpack是完全不同的两类工具","zIndex":467},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"192c8e4e-95e5-4e82-91d4-e49f6fc5a206","children":[],"html":"它们会自动执行指定的任务，就像流水线，把资源放上去然后通过不同插件进行加工，它们包含活跃的社区，丰富的插件，能方便的打造各种工作流。","zIndex":468},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0a6cddf0-e045-4d34-8e64-58210814b412","children":[],"html":"现在主流的方式是用npm  script代替Grunt、Gulp来打造任务流。","zIndex":469}],"html":"grunt、gulp","layout":{"quadrant":1},"collapsed":true,"zIndex":53},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"32a263de-d612-4f88-bfe7-8c23e0fac9ca","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b38e28f0-8244-4209-a7d9-ed209c31f845","children":[],"html":"Rollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除无用的代码，可以最大程度上降低代码体积。","zIndex":470},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"772e425a-0dbb-4318-8a61-36def8b352ae","children":[],"html":"但是 rollup没有webpack如此多的的如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适合库的开发。","zIndex":471},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"636ed6e9-98bb-49d3-9b25-5fa04a8d28f5","children":[],"html":"parcel适用于简单的实验性项目，使用门槛低，但是生态差、报错信息不够全面","zIndex":472}],"html":"rollup、parcel","layout":{"quadrant":1},"collapsed":true,"zIndex":47}],"html":"对比","icons":{"priority":3},"zIndex":62,"collapsed":true}],"layout":{"type":"standard","direction":[1,0]},"zIndex":66}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[720.4287109375,1617.375,1],"width":1601,"height":949},"viewportOption":"adapt","text":"Webpack基础概念模块打包器，用于将各种模块、资源文件打包成浏览器可以加载和运行的静态资源文件。核心概念bundle是由webpack打包出来的⽂件chunk代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割module是开发中的单个模块，webpack中⼀切皆模块，⼀个模块对应⼀个⽂件构建流程初始化启动构建，读取与合并配置参数，加载plugin，实例化 Compiler编译从Entry出发，针对每个模块串行调用对应的loader去翻译文件的内容，再去找这个模块依赖的模块，递归地进行编译处理输出将编译后的模块组合成chunk，将chunk转换成文件，输出到文件系统中在构建过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到对应的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果。常用的 Loader处理jsbabelbabel-loader是 webpack 和 babel 通信的桥梁，不会做es6转义为es5的工作{        test: /\\.js$/,        exclude: /node_modules/, // 排除node_modules代码不编译        loader: \"babel-loader\",},ES6语法编译presets：预设，就是一组 Babel 插件, 扩展 Babel 功能，它能将 ES6 的一些语法进行编译转换，比如箭头函数、扩展运算符等@babel/preset-env: 一个智能预设，允许您使用最新的 JavaScript@babel/preset-react：一个用来编译 React jsx 语法的预设@babel/preset-typescript：一个用来编译 TypeScript 语法的预设polyfillcore-js：专门用来做ES6及以上API的polyfill，可以处理presets处理不了的async函数、promise对象，数组includes方法等等。polyfill 就是用社区上提供的一段代码，让我们在不兼容某些新特性的浏览器上，使用该新特性。直接使用promise语法，eslint会报错，需要修改eslint配置npm i @babel/eslint-parser -D.eslintrc.jsmodule.exports = {  parser: \"@babel/eslint-parser\", // 支持最新的最终 ECMAScript 标准};对 promise 编译转换：npm i core-jsbabel 配置：babel.config.jsmodule.exports = {  // 智能预设：能够编译ES6语法  presets: [    [      \"@babel/preset-env\",      // 按需加载core-js的polyfill      { useBuiltIns: \"usage\", corejs: { version: \"3\", proposals: true } },    ],  ],};处理样式css-loader将css文件编译成webpack能识别的模块style-loader动态创建一个style标签，里面放置webpack中css模块的内容sass-loader/less-loader/stylus-loader将sass/less文件编译成css文件{     test: /\\.less$/,     use: [\"style-loader\", \"css-loader\", \"less-loader\"],}处理css兼容性postcss-loader：扩展 CSS 语法，可以配合 autoprefixer 插件自动补齐 CSS3 前缀npm i postcss-loader postcss postcss-preset-env -D配置{        // 用来匹配 .css 结尾的文件        test: /\\.css$/,        // use 数组里面 Loader 执行顺序是从右到左        use: [          MiniCssExtractPlugin.loader,          \"css-loader\",          {            loader: \"postcss-loader\",            options: {              postcssOptions: {                plugins: [                  \"postcss-preset-env\", // 能解决大多数样式兼容性问题                ],              },            },          },        ],},控制兼容性在 package.json 文件中添加 browserslist 来控制样式的兼容性做到什么程度{  // 其他省略  \"browserslist\": [\"ie >= 8\"]}处理图片webpack4 处理图片使用 file-loader 和 url-loaderfile-loader: 把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件url-loader：与 file-loader 类似，区别是用户可以设置一个阈值，大于阈值会交给 file-loader 处理，小于阈值时返回文件 base64 形式编码 (处理图片和字体)webpack5 可以通过在module.rules中设置type: asset，可以在配置中修改打包阈值，以及修改输出资源的名称和路径(路径最好在output中统一配置){        test: /\\.(png|jpe?g|gif|webp)$/,        type: \"asset\",        parser: {          dataUrlCondition: {            maxSize: 10 * 1024 // 小于10kb的图片会被base64处理          }        },        generator: {          // 将图片文件输出到 static/imgs 目录中          // 将图片文件命名 [hash:8][ext][query]          // [hash:8]: hash值取8位          // [ext]: 使用之前的文件扩展名          // [query]: 添加之前的query参数          filename: \"static/imgs/[hash:8][ext][query]\",        },},处理字体图标及其他资源(音视频){        test: /\\.(ttf|woff2?|mp4|mp3|avi)$/,        type: \"asset/resource\",},type: \"asset/resource\"和type: \"asset\"的区别type: \"asset/resource\" 相当于file-loader, 将文件转化成 Webpack 能识别的资源，其他不做处理type: \"asset\" 相当于url-loader, 将文件转化成 Webpack 能识别的资源，同时小于某个大小的资源会处理成 data URI 形式其他raw-loader：加载文件原始内容（utf-8）source-map-loader：加载额外的 Source Map 文件，以方便断点调试svg-inline-loader：将压缩后的 SVG 内容注入代码中awesome-typescript-loader：将 TypeScript 转换成 JavaScript，性能优于 ts-loadercache-loader: 可以在一些性能开销较大的 Loader 之前添加，目的是将结果缓存到磁盘里常用的 Plugin代码格式检查eslint-webpack-plugin配合eslint、vscode eslint插件做代码格式检查eslint 配置文件：.eslintrc.jsmodule.exports = {  // 继承 Eslint 规则  extends: [\"eslint:recommended\"],  env: {    node: true, // 启用node中全局变量    browser: true, // 启用浏览器中全局变量  },  parserOptions: {    ecmaVersion: 6, // ES 语法版本    sourceType: \"module\", // ES 模块化    ecmaFeatures: { // ES 其他特性      jsx: true // 如果是 React 项目，就需要开启 jsx 语法    }  },  rules: {    \"no-var\": 2, // 不能使用 var 定义变量  },};webpack.config.jsplugins: [    new ESLintWebpackPlugin({      // 指定检查文件的根目录      context: path.resolve(__dirname, \"src\"),    }),  ],处理htmlhtml-webpack-pluginplugins: [    new HtmlWebpackPlugin({      // 以 public/index.html 为模板创建文件      // 新的html文件有两个特点：1. 内容和源文件一致 2. 自动引入打包生成的js等资源      template: path.resolve(__dirname, \"public/index.html\"),    }),  ],提取css成单独文件mini-css-extract-plugin使用loader处理样式后，Css 文件被打包到 js 文件中，当 js 文件加载时，会创建一个 style 标签来生成样式。这样访问页面时会出现闪屏现象。这个插件可以单独生成css文件，通过link标签加载// 提取css成单独文件new MiniCssExtractPlugin({      // 定义输出文件名和目录      filename: \"static/css/main.css\",}),css压缩css-minimizer-webpack-plugin默认生产模式已经开启了：html 压缩和 js 压缩，不需要额外配置js压缩terser-webpack-plugin一些提高开发效率的插件ModuleConcatenationPlugin: 开启 Scope Hoisting ？？？？webpack-bundle-analyzer: 可视化 Webpack 输出文件的体积 (业务组件、依赖第三方模块)webpack-dashboard：可以更友好的展示相关打包信息webpack-merge：提取公共配置，减少重复配置代码speed-measure-webpack-plugin: 可以看到每个 Loader 和 Plugin 执行耗时 (整个打包耗时、每个 Plugin 和 Loader 耗时)size-plugin：监控资源体积变化，尽早发现问题HotModuleReplacementPlugin：模块热替换Loader 和 Plugin 的区别作用不同Loader 本质就是一个函数，在该函数中对接收到的内容进行转换，返回转换后的结果。 因为 Webpack 只认识 JavaScript，所以 Loader 就成了翻译官，对其他类型的资源进行转译的预处理工作。Plugin 就是插件，基于事件流框架 Tapable，插件可以扩展 Webpack 的功能，在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。配置不同Loader 在 module.rules 中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 test(类型文件)、loader、options (参数)等属性。Plugin 在 plugins 中单独配置，类型为数组，每一项是一个 Plugin 的实例，参数都通过构造函数传入。配置相关单页应用配置直接在 entry 中指定单页应用的入口即可多页应用配置可以使用webpack的 AutoWebPlugin 来完成简单自动化的构建react 脚手架配置vue 脚手架配置webpack-dev-server开发服务器 & 自动编译代码配置devServer: {    host: \"localhost\", // 启动服务器域名    port: \"3000\", // 启动服务器端口号    open: true, // 是否自动打开浏览器},mode: \"development\",运行指令npx webpack serve特点当使用开发服务器时，所有代码都会在内存中编译打包，并不会输出到 dist 目录下hash文件指纹，是指打包后输出的文件名的后缀类型Hash：和整个项目的构建相关，只要项目文件有修改，整个项目构建的 hash 值就会更改Chunkhash：和 Webpack 打包的 chunk 有关，不同的 entry 会生出不同的 chunkhashContenthash：根据文件内容来定义 hash，文件内容不变，则 contenthash 不变JS的文件指纹设置设置 output 的 filename，用 chunkhashCSS的文件指纹设置设置 MiniCssExtractPlugin 的 filename，使用 contenthash图片的文件指纹设置设置file-loader的name，使用hash优化提升开发体验使用 Source Map 让开发或上线时代码报错能有更加准确的错误提示开发模式：cheap-module-source-map优点：打包编译速度快，只包含行映射；缺点：没有列映射module.exports = {  // 其他省略  mode: \"development\",  devtool: \"cheap-module-source-map\",};生产模式：source-map优点：包含行/列映射；缺点：打包编译速度更慢module.exports = {  // 其他省略  mode: \"production\",  devtool: \"source-map\",};优化打包构建速度构建费时分析speed-measure-webpack-plugin缺点：有些 Loader 或者 Plugin 新版本会不兼容，需要进行降级处理，在 webpack5.x 中为了使用费时分析去对插件进行降级或者修改配置写法是非常不划算的，不建议使用HotModuleReplacement使用 HotModuleReplacement 让开发时只重新编译打包更新变化了的代码，不变的代码使用缓存，从而使更新速度更快HMR/热模块替换：在程序运行中，替换、添加或删除模块，而无需重新加载整个页面基本配置module.exports = {  devServer: {    host: \"localhost\", // 启动服务器域名    port: \"3000\", // 启动服务器端口号    open: true, // 是否自动打开浏览器    hot: true, // 开启HMR功能（只能用于开发环境，生产环境不需要了）  },};此时 css 样式经过 style-loader 处理，已经具备 HMR 功能了。 但是 js 还不行。js 配置实际开发我们会使用其他 loader 来解决，比如：vue-loaderreactnpm i -D @pmmmwh/react-refresh-webpack-plugin react-refresh{            test: /\\.(jsx|js)$/,            include: path.resolve(__dirname, \"../src\"),            loader: \"babel-loader\",            options: {              cacheDirectory: true,              cacheCompression: false,              plugins: [                // \"@babel/plugin-transform-runtime\", // presets中包含了                \"react-refresh/babel\", // 开启js的HMR功能              ],            },},new ReactRefreshWebpackPlugin(), // 解决js的HMR功能运行时全局变量的问题优化resolve配置alias用于创建 import 或 require 的别名，用来简化模块引用，配置不宜过多extensionswebpack 就会按照 extensions 配置的数组从左到右的顺序去尝试解析模块，高频文件后缀名放前面modules告诉 webpack 优先 src 目录下查找需要解析的文件，会大大节省查找时间resolve: {     modules: [resolve('src'), 'node_modules'],  },externalsexternals 配置选项提供了「从输出的 bundle 中排除依赖」的方法。此功能通常对 library 开发人员来说是最有用的使用场景：从 CDN 引入 jQuery，而不是把它打包externals: {    jquery: 'jQuery',},缩小范围oneOf使用 OneOf 让资源文件一旦被某个 loader 处理了，就不会继续遍历了，打包速度更快why打包时每个文件都会经过所有 loader 处理，虽然因为 test 正则原因实际没有处理上，但是都要过一遍。比较慢what只能匹配上一个 loader, 剩下的就不匹配了howmodule: {    rules: [      {        oneOf: [          {            test: /\\.css$/,            // use 数组里面 Loader 执行顺序是从右到左            use: [\"style-loader\", \"css-loader\"],          },          {            test: /\\.less$/,            use: [\"style-loader\", \"css-loader\", \"less-loader\"],          },          {            test: /\\.js$/,            // exclude: /node_modules/, // 排除node_modules代码不编译            include: path.resolve(__dirname, \"../src\"), // 也可以用包含            loader: \"babel-loader\",          },        ],      },    ],  },Include/Exclude使用 Include/Exclude 排除或只检测某些文件，处理的文件更少，速度更快why开发时我们需要使用第三方的库或插件，所有文件都下载到 node_modules 中了。而这些文件是不需要编译可以直接使用的。所以我们在对 js 文件处理时，要排除 node_modules 下面的文件whatinclude：包含，只处理xxx文件exclude：排除，除了xxx文件以外其他文件都处理noParse不需要解析依赖的第三方大型类库等，可以通过这个字段进行配置，以提高构建速度使用 noParse 进行忽略的模块文件中不会解析 import、require 等语法module: {     noParse: /jquery|lodash/,    rules:[...]  }IgnorePlugin使用场景：将插件中的非中文语音排除掉，这样就可以大大节省打包的体积了plugins:[ // 配置插件    ...    new webpack.IgnorePlugin({      resourceRegExp: /^\\.\\/locale$/,      contextRegExp: /moment$/,    }),  ]  多进程配置 thread-loader使用 Thead 多进程处理 eslint 和 babel 任务，速度更快。（需要注意的是，进程启动通信都有开销的，要在比较多代码处理时使用才有效果）what多进程打包：开启电脑的多个进程同时干一件事，速度更快。需要注意：请仅在特别耗时的操作中使用，因为每个进程启动就有大约为 600ms 左右开销。how我们启动进程的数量就是我们 CPU 的核数// nodejs核心模块，直接使用const os = require(\"os\");// cpu核数const threads = os.cpus().length;npm i thread-loader -Dbabel-loader{            test: /\\.js$/,            // exclude: /node_modules/, // 排除node_modules代码不编译            include: path.resolve(__dirname, \"../src\"), // 也可以用包含            use: [              {                loader: \"thread-loader\", // 开启多进程                options: {                  workers: threads, // 数量                },              },              {                loader: \"babel-loader\",                options: {                  cacheDirectory: true, // 开启babel编译缓存                },              },            ],},pluginsplugins: [    new ESLintWebpackPlugin({      // 指定检查文件的根目录      context: path.resolve(__dirname, \"../src\"),      exclude: \"node_modules\", // 默认值      cache: true, // 开启缓存      // 缓存目录      cacheLocation: path.resolve(        __dirname,        \"../node_modules/.cache/.eslintcache\"      ),      threads, // 开启多进程    }),  ],  optimization: {    minimize: true,    minimizer: [      // 当生产模式会默认开启TerserPlugin，但是我们需要进行其他配置，就要重新写了      new TerserPlugin({        parallel: threads // 开启多进程      })    ],  }项目越来越大，打包速度会越来越慢，提升打包速度主要是提升js的打包速度，而对 js 文件处理主要就是 eslint 、babel、Terser 三个工具，所以我们要提升它们的运行速度。我们可以开启多进程同时处理 js 文件，这样速度就比之前的单进程打包更快了利用缓存使用 Cache 对 eslint 和 babel 处理的结果进行缓存，让第二次打包速度更快why每次打包时 js 文件都要经过 Eslint 检查 和 Babel 编译，速度比较慢。我们可以缓存之前的 Eslint 检查 和 Babel 编译结果，这样第二次打包时速度就会更快了what对 Eslint 检查 和 Babel 编译结果进行缓存配置babel-loader{            test: /\\.js$/,            include: path.resolve(__dirname, \"../src\"), // 也可以用包含            loader: \"babel-loader\",            options: {              cacheDirectory: true, // 开启babel编译缓存              cacheCompression: false, // 缓存文件不要压缩            },},eslint pluginnew ESLintWebpackPlugin({      // 指定检查文件的根目录      context: path.resolve(__dirname, \"../src\"),      exclude: \"node_modules\", // 默认值      cache: true, // 开启缓存      // 缓存目录      cacheLocation: path.resolve(        __dirname,        \"../node_modules/.cache/.eslintcache\"      ),}),优化构建结果构建结果分析webpack-bundle-analyzer压缩 CSSoptimize-css-assets-webpack-plugin 清除无用的 CSSpurgecss-webpack-pluginnew PurgecssPlugin({      paths: glob.sync(`${PATHS.src}/**/*`, {nodir: true})}),压缩 JS在生成环境下打包默认会开启 js 压缩，但是当我们手动配置 optimization 选项之后，就不再默认对 js 进行压缩，需要我们手动去配置。webpack5 内置了terser-webpack-plugin 插件，所以我们不需重复安装，直接引用就可以了避免babel辅助代码重复引入使用 @babel/plugin-transform-runtime 插件对 babel 进行处理，让辅助代码从中引入，而不是每个文件都生成辅助代码，从而体积更小。whyBabel 为编译的每个文件都插入了辅助代码，使代码体积过大Babel 对一些公共方法使用了非常小的辅助代码，比如 _extend。默认情况下会被添加到每一个需要它的文件中。你可以将这些辅助代码作为一个独立模块，来避免重复引入what@babel/plugin-transform-runtime: 禁用了 Babel 自动对每个文件的 runtime 注入，而是引入 @babel/plugin-transform-runtime 并且使所有辅助代码从这里引用how{            test: /\\.js$/,            // exclude: /node_modules/, // 排除node_modules代码不编译            include: path.resolve(__dirname, \"../src\"), // 也可以用包含            use: [              {                loader: \"thread-loader\", // 开启多进程                options: {                  workers: threads, // 数量                },              },              {                loader: \"babel-loader\",                options: {                  cacheDirectory: true, // 开启babel编译缓存                  cacheCompression: false, // 缓存文件不要压缩                  plugins: [\"@babel/plugin-transform-runtime\"], // 减少代码体积                },              },            ],},Tree shaking使用 Tree Shaking 剔除了没有使用的多余代码，让代码体积更小Tree Shaking 是一个术语，通常用于描述移除 JavaScript 中的没有使用上的代码，它依赖 ES Module。Webpack 已经默认开启了这个功能，需要在 .bablerc 里面设置 model：false，即可在生产环境下默认开启module.exports = {  presets: [    [      \"@babel/preset-env\",      {        module: false,        useBuiltIns: \"entry\",        corejs: \"3.9.1\",        targets: {          chrome: \"58\",          ie: \"11\",        },      },    ],  ],};Scope HoistingScope Hoisting 即作用域提升，原理是将多个模块放在同一个作用域下，并重命名防止命名冲突，通过这种方式可以减少函数声明和内存开销。webpack 默认支持，在生产环境下默认开启只支持 es6 代码图片压缩使用 Image Minimizer 对项目中图片进行压缩，体积更小，请求速度更快。（需要注意的是，如果项目中图片都是在线链接，那么就不需要了。本地项目静态图片才需要进行压缩。）优化代码运行性能入口点分割配置多个打包入口，多页打包分包配置 + 按需加载why使用 Code Split 对代码进行分割成多个 js 文件，从而使单个文件体积更小，并行加载 js 速度更快。并通过 import 动态导入语法进行按需加载，从而达到需要使用时才加载该资源，不用时不加载资源。同时可以充分利用浏览器缓存what配置 optimization.splitChunks自动拆分 chunks 默认配置新的 chunk 可以被共享，或者模块来自于 node_modules 文件夹新的 chunk 体积大于 20kb（在进行 min+gz 之前的体积）当按需加载 chunks 时，并行请求的最大数量小于或等于 30当加载初始化页面时，并发请求的最大数量小于或等于 30分割文件：将打包生成的文件进行分割，生成多个 js 文件。按需加载：需要哪个文件就加载哪个文件howoptimization: {    // 代码分割配置    splitChunks: {      chunks: \"all\", // 对所有模块都进行分割      // 其他内容用默认配置即可    },  },动态导入document.getElementById(\"btn\").onClick = function () {  // eslint会对动态导入语法报错，需要修改eslint配置文件  // webpackChunkName: \"math\"：这是webpack动态导入模块命名的方式  // \"math\"将来就会作为[name]的值显示。  import(/* webpackChunkName: \"math\" */ \"./js/math.js\").then(({ count }) => {    console.log(count(2, 1));  });};eslint 配置npm i eslint-plugin-import -D// .eslintrc.jsmodule.exports = {  // 继承 Eslint 规则  extends: [\"eslint:recommended\"],  env: {    node: true, // 启用node中全局变量    browser: true, // 启用浏览器中全局变量  },  plugins: [\"import\"], // 解决动态导入import语法报错问题 --> 实际使用eslint-plugin-import的规则解决的  parserOptions: {    ecmaVersion: 6,    sourceType: \"module\",  },  rules: {    \"no-var\": 2, // 不能使用 var 定义变量  },};提取公共第三方库SplitChunksPlugin插件来进行公共模块抽取，利用浏览器缓存可以长期缓存这些无需频繁变动的公共代码preload / prefetch使用 Preload / Prefetch 对代码进行提前加载，等未来需要使用时就能直接使用，从而用户体验更好why如果资源体积大的话，懒加载会有明显的闪现效果，影响用户体验。需要再浏览器空闲时间，加载后续需要使用的资源whatPreload：告诉浏览器立即加载资源。Prefetch：告诉浏览器在空闲时才开始加载资源。共同点都只会加载资源，并不执行；都有缓存区别Preload加载优先级高，Prefetch加载优先级低Preload只能加载当前页面需要使用的资源，Prefetch可以加载当前页面资源，也可以加载下一个页面需要使用的资源总结当前页面优先级高的资源用 Preload 加载下一个页面需要使用的资源用 Prefetch 加载问题兼容性差，我们可以去 Can I Use 网站查询 API 的兼容性问题，Preload 相对于 Prefetch 兼容性好一点hownpm i @vue/preload-webpack-plugin -Dnew PreloadWebpackPlugin({      rel: \"preload\", // preload兼容性更好      as: \"script\",      // rel: 'prefetch' // prefetch兼容性更差}),官网示例// 按需加载img.addEventListener('click', () => {  import( /* webpackPrefetch: true */ './desc').then(({ default: element }) => {    console.log(element)    document.body.appendChild(element)  })})import(/* webpackPreload: true */ 'ChartingLibrary');network cache使用 Network Cache 能对输出资源文件进行更好的命名，将来好做缓存，从而用户体验更好why对静态资源做缓存优化，浏览器再次请求资源可以从缓存中读取，速度快whatfullhash每次修改任何一个文件，所有文件名的 hash 至都将改变。所以一旦修改了任何一个文件，整个项目的文件缓存都将失效。chunkhash根据不同的入口文件(Entry)进行依赖文件解析、构建对应的 chunk，生成对应的哈希值。我们 js 和 css 是同一个引入，会共享一个 hash 值。contenthash根据文件内容生成 hash 值，只有文件内容变化了，hash 值才会变化。所有文件 hash 值是独享且不同的。output: {    path: path.resolve(__dirname, \"../dist\"), // 生产模式需要输出    // [contenthash:8]使用contenthash，取8位长度    filename: \"static/js/[name].[contenthash:8].js\", // 入口文件打包输出资源命名方式    chunkFilename: \"static/js/[name].[contenthash:8].chunk.js\", // 动态导入输出资源命名方式    assetModuleFilename: \"static/media/[name].[hash][ext]\", // 图片、字体等资源命名方式（注意用hash）    clean: true,  },问题使用contenthash，当一个文件依赖的文件改变，而导致这个文件的hash值改变，缓存失效解决：将hash值保存在一个runtime文件中。runtime 文件只保存文件的 hash 值和它们与文件关系，整个文件体积就比较小，所以变化重新请求的代价也小optimization:{    // 提取runtime文件    runtimeChunk: {      name: (entrypoint) => `runtime~${entrypoint.name}`, // runtime文件命名规则    },}利用CDN加速在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径pwawhy开发 Web App 项目，项目一旦处于网络离线情况，就没法访问了。我们希望给项目提供离线体验。what渐进式网络应用程序(progressive web application - PWA)：是一种可以提供类似于 native app(原生应用程序) 体验的 Web App 的技术。其中最重要的是，在 离线(offline) 时应用程序能够继续运行功能。内部通过 Service Workers 技术实现的。hownpm i workbox-webpack-plugin -Dnew WorkboxPlugin.GenerateSW({      // 这些选项帮助快速启用 ServiceWorkers      // 不允许遗留任何“旧的” ServiceWorkers      clientsClaim: true,      skipWaiting: true,}),main.jsif (\"serviceWorker\" in navigator) {  window.addEventListener(\"load\", () => {    navigator.serviceWorker      .register(\"/service-worker.js\")      .then((registration) => {        console.log(\"SW registered: \", registration);      })      .catch((registrationError) => {        console.log(\"SW registration failed: \", registrationError);      });  });}解决路径问题npm i serve -gserve distwebpack如何实现持久化缓存服务端设置http缓存头（cache-control）打包依赖和运行时用到不同的chunk，即作为splitChunk，因为他们几乎是不变的延迟加载：使用import()方式，可以动态加载的文件分到独立的chunk，以得到自己的chunkhash保持hash值的稳定：编译过程和文件内通的更改尽量不影响其他文件hash的计算，对于低版本webpack生成的增量数字id不稳定问题，可用hashedModuleIdsPlugin基于文件路径生成解决原理模块打包原理webpack把⼀切当成模块，它会递归地构建⼀个依赖关系图，使用loaders和plugins对模块进行处理和优化，最终将各种资源打包成静态文件Webpack 实际上为每个模块创造了一个可以导出和导入的环境，本质上并没有修改 代码的执行逻辑，代码执行顺序与模块加载顺序也完全一致。打包后的文件是一个立即执行函数，这个立即执行函数接收一个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。立即执行函数内部则处理模块之间的引用，执行模块等。Loader 原理基础概念帮忙webpack识别它不能识别的模块loader 是一个函数，当webpack解析资源时，会调用相应的loader去处理；loader接收到文件内容作为参数，处理后返回内容出去loader 接收三个参数content：文件内容map：sourcemapmeta：别的loader传递的数据针对每个文件类型，loader支持以数组的形式配置多个，在webpack转换文件类型时，会按照顺序链式调用每一个loader，前一个loader返回的内容会作为下一个loader的入参执行顺序相同优先级：从下到上，从右到左enforce: pre > normal > inline > post分类同步loader异步loader需要调用async方法得到callback会等异步操作执行完，再执行下一个loaderRaw loaderPitching Loaderloader apithis.async异步回调loader，返回this.callbackthis.callback可以同步或者异步调用并返回多个结果的函数this.getOptions(schema)获取loader的optionsthis.emitFile产生一个文件this.utils.contextify返回一个相对路径this.utils.absolutify返回一个绝对路径如何编写 Loader手写clean-log-loader// loaders/clean-log-loader.jsmodule.exports = function cleanLogLoader(content) {  // 将console.log替换为空  return content.replace(/console\\.log\\(.*\\);?/g, \"\");};手写babel-loader作用：编译js代码，将ES6+语法便于成ES5-语法下载依赖npm i @babel/core @babel/preset-env -Dloaders/babel-loader/index.jsconst schema = require(\"./schema.json\");const babel = require(\"@babel/core\");module.exports = function (content) {  const options = this.getOptions(schema);  // 使用异步loader  const callback = this.async();  // 使用babel对js代码进行编译  babel.transform(content, options, function (err, result) {    callback(err, result.code);  });};loaders/banner-loader/schema.json{  \"type\": \"object\",  \"properties\": {    \"presets\": {      \"type\": \"array\"    }  },  \"additionalProperties\": true}Plugin 原理基础概念通过插件可以加入自定义的构建行为，增强 webpack 构建能力工作原理webpack在编译代码过程中，会触发一系列的Tapable钩子事件，插件所做的，就是找到对应的钩子，往上面挂上自己的任务，也就是注册事件。所以，在webpack构建过程中，插件注册的事件就会随着钩子的触发而执行。webpack内部的钩子钩子钩子的本质就是：事件。为了方便我们直接介入和控制编译过程，webpack 把编译过程中触发的各类关键事件封装成事件接口暴露出来。这些接口被称做：hooks（钩子）。开发插件，离不开这些钩子。TapableTapable 为 webpack 提供了统一的插件接口（钩子）类型定义，它是 webpack 的核心功能库。webpack 中目前有十种 hookstapable 还统一暴露了三个方法给插件，用于注入不同类型的自定义构建行为tap：可以注册同步钩子和异步钩子tapAsync：回调方式注册异步钩子tapPromise：Promise 方式注册异步钩子Plugin 构建对象Compilercompiler 对象中保存着完整的 Webpack 环境配置每次启动 webpack 构建时它都是一个独一无二，仅会创建一次的对象这个对象会在首次启动 Webpack 时创建，我们可以通过 compiler 对象上访问到 Webapck 的主环境配置，比如 loader 、 plugin 等等配置信息。主要属性compiler.options 可以访问本次启动 webpack 时候所有的配置文件，包括但不限于 loaders 、 entry 、 output 、 plugin 等等完整配置信息compiler.inputFileSystem 和 compiler.outputFileSystem 可以进行文件操作，相当于 Nodejs 中 fs。compiler.hooks 可以注册 tapable 的不同种类 Hook，从而可以在 compiler 生命周期中植入不同的逻辑。Compilationcompilation 对象代表一次资源的构建，compilation 实例能够访问所有的模块和它们的依赖。一个 compilation 对象会对构建依赖图中所有模块，进行编译。 在编译阶段，模块会被加载(load)、封存(seal)、优化(optimize)、 分块(chunk)、哈希(hash)和重新创建(restore)。主要属性compilation.modules 可以访问所有模块，打包的每一个文件都是一个模块compilation.chunks chunk 即是多个 modules 组成而来的一个代码块。入口文件引入的资源组成一个 chunk，通过代码分割的模块又是另外的 chunkcompilation.assets 可以访问本次打包生成所有文件的结果compilation.hooks 可以注册 tapable 的不同种类 Hook，用于在 compilation 编译模块阶段进行逻辑添加以及修改生命周期​实现原理1. webpack 读取配置时，会new plugin实例，执行插件的constructor方法2. webpack 创建 compiler 对象3. 遍历所有插件，调用插件的apply 方法4. 执行剩下的编译流程 (触发各个hooks事件)如何编写 Plugincompiler 暴露了和 Webpack 整个生命周期相关的钩子compilation 暴露了与模块和依赖有关的粒度更小的事件钩子插件需要在其原型上绑定apply方法，才能访问 compiler 实例传给每个插件的 compiler 和 compilation对象都是同一个引用，若在一个插件中修改了它们身上的属性，会影响后面的插件找出合适的事件点去完成想要的功能emit 事件发生时，可以读取到最终输出的资源、代码块、模块及其依赖，并进行修改(emit 事件是修改 Webpack 输出资源的最后时机)watch-run 当依赖的文件发生变化时会触发异步的事件需要在插件处理完任务时调用回调函数通知 Webpack 进入下一个流程，不然会卡住开发一个插件作用：给打包输出文件添加注释开发思路需要打包输出前添加注释：需要使用 compiler.hooks.emit 钩子, 它是打包输出前触发如何获取打包输出的资源？compilation.assets 可以获取所有即将输出的资源文件实现// plugins/banner-webpack-plugin.jsclass BannerWebpackPlugin {  constructor(options = {}) {    this.options = options;  }  apply(compiler) {    // 需要处理文件    const extensions = [\"js\", \"css\"];    // emit是异步串行钩子    compiler.hooks.emit.tapAsync(\"BannerWebpackPlugin\", (compilation, callback) => {      // compilation.assets包含所有即将输出的资源      // 通过过滤只保留需要处理的文件      const assetPaths = Object.keys(compilation.assets).filter((path) => {        const splitted = path.split(\".\");        return extensions.includes(splitted[splitted.length - 1]);      });      assetPaths.forEach((assetPath) => {        const asset = compilation.assets[assetPath];        const source = `/** Author: ${this.options.author}*/\\n${asset.source()}`;        // 覆盖资源        compilation.assets[assetPath] = {          // 资源内容          source() {            return source;          },          // 资源大小          size() {            return source.length;          },        };      });      callback();    });  }}module.exports = BannerWebpackPlugin;TreeShaking 原理treeShaking 也叫摇树优化，是一种通过移除多于代码，来优化打包体积的，生产环境默认开启可以在代码不运行的状态下，分析出不需要的代码；实现方式是利用了ES6模块的规范ES6 Module引入进行静态分析，所以编译时能正确判断到底加载了哪些模块判断哪些模块和变量没有被使用或者引用，进而删除对应代码HMR 热更新实现原理概念HMR是webpack的热更新功能，这个机制可以做到不用刷新浏览器就能将更新后的模块替换掉旧的模块。可以提高开发效率。原理1. webpack在构建bundle时，往每个bundle中加入一段 HMR runtime 的js 和一段监听Websocket消息的js2. 文件修改会触发webpack重新构建3. 服务器(webpack dev server)与浏览器维护了一个Websocket，当本地资源发送变化时，WDS会向浏览器推送更新，并带上构建时的hash。4. 浏览器通过jsonp拉取更新的模块文件，jsonp回调触发模块热替换，实现chunk的增量更新拿到增加更新后的处理，由 HotModulePlugin 来完成，提供了相关 API 以供开发者针对自身场景进行处理，像react-hot-loader 和 vue-loader 都是借助这些 API 实现 HMR。Babel 原理解析：将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程转换：对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作生产新的 AST生成：将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generatorWebpack 核心库 Tapabel对比vitewebpack每次编译都需要重新构建vite使用浏览器原生支持的ESM规范来执行代码，开发阶段不需要编译vite会从文件入口出发，遇到import语句，将对应的模块通过http请求加载到浏览器中项目越大，vite开发时的优势越明显grunt、gulpGrunt、Gulp是基于任务运行的⼯具，和Webpack是完全不同的两类工具它们会自动执行指定的任务，就像流水线，把资源放上去然后通过不同插件进行加工，它们包含活跃的社区，丰富的插件，能方便的打造各种工作流。现在主流的方式是用npm  script代替Grunt、Gulp来打造任务流。rollup、parcelRollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除无用的代码，可以最大程度上降低代码体积。但是 rollup没有webpack如此多的的如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适合库的开发。parcel适用于简单的实验性项目，使用门槛低，但是生态差、报错信息不够全面","graphicsBBox":{"x":1205.3662109375,"y":1849.375,"width":286.125,"height":220}}