{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"id":"631f5383-2a9e-479d-bec6-078a5321b663","x":495.3662298828126,"y":445.5,"html":"Vite","type":"mindmap","defaultContentStyle":{"color":"rgb(38, 38, 38)"},"border":{"fill":"#F5F5F5","shape":"rect","stroke":"transparent","stroke-width":2},"children":[{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#FAEDF6","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"id":"f8e7dfa2-9db9-4b5b-ae27-29ea367e4e82","children":[{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"d1f8f62c-2905-4d9b-85c7-5932274ca870","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"82d164b4-9e9c-4a9c-98ab-c8baff8dfd7e","children":[],"html":"前端构建工具，下一代前端工具链，为开发提供极速响应","zIndex":15},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"4d29a448-5420-476c-9486-8d2f9e19b399","children":[],"html":"Vite 提供一个开发服务器和一套构建指令","zIndex":16},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3f813e95-526a-4657-b26f-9a5ba196501a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f62cdfe5-a44c-44b1-b706-d3985e7c6c4c","children":[],"html":"服务启动快：开发环境使用原生ESM文件，不需要打包","zIndex":18},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9917eddd-96f5-4d57-a480-fb89240bcc86","children":[],"html":"热重载快","zIndex":19},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"61697057-f16b-4c62-aa19-bd414261d94c","children":[],"html":"对TS、JSX、CSS等支持开箱即用，内置HMR","zIndex":20},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5316d51a-a038-4669-a85d-e5fb0ae7946f","children":[],"html":"优化的构建","zIndex":21}],"html":"特点","zIndex":17}],"html":"Vite 是什么","collapsed":true,"zIndex":14},{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"c4775187-c9bd-4dd9-9917-ef48fb623ac0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6abd5bfe-2814-4ba1-8a25-34fc9d50b2f6","children":[],"html":"通过JS的原生机制，实现高效的模块化开发","zIndex":23},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"78db5157-aa59-4813-bfd9-363d92c1e1f4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6d31f911-91c9-4d20-b366-2c5f503fc865","children":[],"html":"问题：基于打包器的方式启动开发服务器，需要构建整个应用，才能启动服务。","height":55.00000185546878,"width":510.9999810546874,"zIndex":25},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d1449a8d-97b4-456b-a8e8-de7ded7dbd46","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ff680f29-2cae-4b27-a5a8-f4289561d111","children":[],"html":"将模块分为依赖和源码两类","zIndex":27},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b44ebf72-19c6-4932-a586-9b563260b26d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4b6a96d3-d08f-4658-a7b6-fa1f2d217199","children":[],"html":"依赖一般是开发时不会变动的JS，如node_modules中的包","layout":{"quadrant":1},"zIndex":29},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"94237165-6c48-413b-a7e1-7e706f90d2c5","children":[],"html":"使用esbuild与构建依赖。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。","zIndex":30}],"html":"依赖","zIndex":28},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"66d8c8b5-bc7f-4525-86fc-55c59ca8a42f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"044911ad-07b3-49d9-95bf-8b43464651d8","children":[],"html":"写在src下的代码，一般需要转换，如jsx，vue文件，经常被编辑，但是不需要全部同时被加载","zIndex":32},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8a0d528e-2198-4427-a1e3-952296ed4f5c","children":[],"html":"Vite 以原生ESM方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。","zIndex":33}],"html":"源码","zIndex":31}],"html":"Vite 如何改进","zIndex":26}],"html":"开发服务器启动慢","zIndex":24},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"cae78782-280d-4e6c-9e73-9f04cadb9c57","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9cbdd338-f798-4965-8451-9ceab50b4cfb","children":[],"html":"问题：基于打包器启动时，重新构建整个包效率低，项目越大越慢","zIndex":35},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b8a85f27-1127-4a9f-8ffc-f00e89b23f49","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"07f40fdf-0375-49c7-98cb-49ff21b62802","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8479963c-3486-445b-a3b6-afb943479771","children":[],"html":"当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活","zIndex":38}],"html":"在原生ESM上执行HMR","zIndex":37},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a2491f51-59ca-4dc0-af92-250d8277da90","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7f52b9cb-82de-4e6a-a2c7-9ad285a5bba0","children":[],"html":"源码模块的请求会根据 304 Not Modified 进行协商缓存","zIndex":40},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6860957f-24a8-4518-ae2d-f6575b4d74f7","children":[],"html":"依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存","zIndex":41}],"html":"同时利用 HTTP 头来加速整个页面的重新加载","zIndex":39}],"html":"Vite 如何改进","zIndex":36}],"html":"更新慢","zIndex":34}],"html":"为什么选择 Vite","collapsed":true,"zIndex":22},{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"f4cb4153-2796-4990-9846-92ed11bc4e6f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"2d2251c4-14cc-42e2-9e2f-3ba332eb9bd8","children":[],"html":"生产环境使用 rollup 打包","zIndex":43},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"932c0c6d-36c9-42b1-921b-877ca8a874c5","children":[],"html":"由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下","zIndex":44},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"adc5948a-0b9d-422e-97d1-9459463cf015","children":[],"html":"生产环境将需要代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）才能获得更好的性能","zIndex":45},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c1523f2a-95e1-432e-b855-a2ca7b1cdcda","children":[],"html":"为什么不用 esbuild 打包：esbuild在代码分割和css处理方面功能还未完善","zIndex":46}],"html":"为什么生产环境需要打包","layout":{"quadrant":1},"collapsed":true,"zIndex":42},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"e5e5b629-0312-4c55-939b-b9b3408ee59a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"00c4a782-5de7-4c40-8527-5d6963b6c2ac","children":[],"html":"利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进行加载。","zIndex":48}],"html":"no-bundle 是什么","layout":{"quadrant":1},"collapsed":true,"zIndex":47},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"rgba(0, 0, 0, 0)","stroke":"transparent"},"id":"807bac61-2ecc-4fd8-a440-1e58e050bd70","children":[{"border":{"shape":"rect","stroke-width":1,"stroke":"transparent","fill":"#FFFFFF"},"id":"54aa6b4c-1ac7-45e6-ac84-b9f7644e3c09","children":[],"html":"读取到main.tsx内容，Vite对文件内容进行编译，例如：把ts编译成浏览器能识别的内容","zIndex":50},{"border":{"shape":"rect","stroke-width":1,"stroke":"transparent","fill":"#FFFFFF"},"id":"c882e2eb-5c6d-4bb4-9df6-8804422d7364","children":[],"html":"一个 import 语句即代表了一个 HTTP 请求。浏览器解析到import语句，VDS会发起请求，VDS读取本地文件，返回浏览器可以解析的代码，直到所有资源都加载完成。","zIndex":51}],"html":"Vite Dev Server 做了什么","treeEdge":{"stroke":"#69B1E4","stroke-width":2},"collapsed":true,"zIndex":49}],"html":"基础","collapsed":true,"zIndex":1},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#EFE8FA","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"id":"45d81735-88ef-4ac9-81a8-b9bb0a15d8ee","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"id":"78afa559-c533-421f-8034-231ea100ed1b","children":[],"html":"从零搭建步骤","layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"zIndex":52},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"id":"6ed4d8df-0620-4ba5-92f0-067f4ae4ee2d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fafb674c-d08b-48b8-b6e8-eb69076eff7d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9a852074-e78d-4b8d-be29-0dba7d6442c5","children":[],"html":"开发体验差，比如原生css不支持选择器嵌套","zIndex":55},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"68c59c42-f74f-43ee-ae00-cb7621221eb5","children":[],"html":"样式污染","zIndex":56},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"de7de9a4-5fa5-4192-87e4-f010ce0424ad","children":[],"html":"浏览器兼容","zIndex":57},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"50497d13-cfaf-4c06-9c44-383ddd670d7b","children":[],"html":"打包后代码体积大","zIndex":58}],"layout":{"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"html":"CSS工程化解决了什么问题","zIndex":54},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"be8e1186-de88-4580-b582-cfebedaa8938","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"47b5a996-5f8d-4d57-9ec0-efb4b5c80680","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f5b84d5f-b29b-4c42-8ac7-901a3d70f2b4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a0f8473c-8e96-41b6-abe5-0ef7998e9291","children":[],"html":"样式可以嵌套","zIndex":62},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8ef9acf5-710d-411b-9af6-a099fd75e66a","children":[],"html":"可以定义变量、写条件判断和循环，增强灵活性","zIndex":63},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"339f3b21-0441-45a6-8572-456136740d4b","children":[],"html":"解决原生CSS的开发体验问题","zIndex":64}],"html":"Sass，less，stylus","zIndex":61}],"html":"CSS 预处理器","zIndex":60},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"58ac6d3b-260d-4ffa-94ee-e17dabb5a189","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fd9410e2-2b13-4eb0-8fc8-56bcff1f34b2","children":[],"html":"能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下样式污染的问题。","height":55.50000185546844,"width":508.4999810546883,"zIndex":66}],"html":"CSS Modules","zIndex":65},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b51e01df-b4f5-4b2d-b2c8-672a912e0f94","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"0d8ccaf1-4dbd-4c44-9941-07ecd3617a5f","children":[],"html":"解析和处理CSS代码","zIndex":68},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8dd2880b-4ab9-4c78-bd57-861faa2dcdec","children":[],"html":"px转换为rem","zIndex":69},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"48fe5515-c8d9-43ec-a8fb-a97311517a7e","children":[],"html":"根据目标浏览器添加前缀 --moz--","zIndex":70}],"html":"CSS后处理器PostCSS","zIndex":67},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"825fb545-6547-4e17-b485-4aa5c114f950","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4db09f49-3cb8-4243-a3b1-be00b45fa583","children":[],"html":"包括emotion、styled-components等","zIndex":72},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e5ec4804-ba59-48d3-91ad-02d1a8f6755b","children":[],"html":"包含css预处理器和css modules的优点，使用灵活","zIndex":73},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b68f86e6-b9c1-4e3a-8522-496d0f2bbe5c","children":[],"html":"解决开发体验和全局样式污染问题","zIndex":74}],"html":"CSS in JS 方案","zIndex":71},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"24f033bf-d0f9-444d-ab4e-209898e10514","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"daf15851-f277-42eb-8096-dfbc930779fd","children":[],"html":"Tailwindcss、Windi CSS","zIndex":76},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1b5a9f23-8f44-4fef-bcc0-04b3294132c3","children":[],"html":"通过类名来制定样式，提高开发效率","zIndex":77}],"html":"CSS 原子化框架","zIndex":75}],"html":"工程化方案","zIndex":59},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a34a3c25-a237-4151-bd3c-142b2ebd6e83","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e1ba6e31-c6b5-4d06-a697-4959bd38d38a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"bf705c09-5452-4f87-97ce-d57605853160","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c1f8212d-51a8-4a1e-b727-8d1947e1bbe4","children":[],"html":"// vite.config.ts<div>import { normalizePath } from 'vite';</div><div>// 如果类型报错，需要安装 @types/node: pnpm i @types/node -D</div><div>import path from 'path';</div><div>// 全局 scss 文件的路径</div><div>// 用 normalizePath 解决 window 下的路径问题</div><div><span style=\"font-weight:bold;\">const variablePath = normalizePath(path.resolve('./src/variable.scss'));</span></div><div>export default defineConfig({</div><div>&nbsp; // css 相关的配置</div><div>&nbsp; css: {</div><div>&nbsp; &nbsp; preprocessorOptions: {</div><div>&nbsp; &nbsp; &nbsp; scss: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // additionalData 的内容会在每个 scss 文件的开头自动注入</div><div>&nbsp; &nbsp; &nbsp; &nbsp; additionalData: `@import \"${variablePath}\";`</div><div>&nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div><div>&nbsp; }</div><div>})</div>","zIndex":81}],"html":"自动引入css变量文件","zIndex":80}],"html":"内置CSS预处理器，零配置","zIndex":79},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fd54ceb3-acc2-407b-a3da-41943e20b807","children":[],"html":"内置对.module样式文件的支持","zIndex":82},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e53f6609-abbf-4240-b1f2-4d5a601d2558","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"43674d68-e3f8-4d6b-b591-e133552ce68d","children":[],"html":"可以通过 postcss.config.js 来配置 postcss ，不过在 Vite 配置文件中已经提供了 PostCSS 的配置入口","zIndex":84},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a0dc9dd8-87fc-4a23-968c-faae0cfbfd41","children":[],"html":"pnpm i autoprefixer -D","zIndex":85},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"06a58a48-d44a-4854-9904-1dcfa2a4e21c","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"2b404710-d32f-4967-9781-784a50796e51","children":[],"html":"// vite.config.ts 增加如下的配置<div>import autoprefixer from 'autoprefixer';</div><div>export default {</div><div>&nbsp; css: {</div><div>&nbsp; &nbsp; // 进行 PostCSS 配置</div><div>&nbsp; &nbsp; postcss: {</div><div>&nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; autoprefixer({</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 指定目标浏览器</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; overrideBrowserslist: ['Chrome &gt; 40', 'ff &gt; 31', 'ie 11']</div><div>&nbsp; &nbsp; &nbsp; &nbsp; })</div><div>&nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; }</div><div>&nbsp; }</div><div>}</div>","zIndex":87}],"html":"解决兼容，增加样式前缀","zIndex":86},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3ecb786b-dab3-4af2-9b4f-e466ad79ffb6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8aa98ca1-6d83-404b-8631-94ca69564929","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fdade0e3-4f3b-440f-8afc-4504ecc5278b","children":[],"html":"适配移动端时常用","zIndex":90}],"html":"postcss-pxtorem","zIndex":89},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4620b788-2781-46a5-812e-bf30de76e459","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e5b6221c-2d11-4647-8c32-f0a8d29511e1","children":[],"html":"可以编写最新的css语法，处理兼容问题","zIndex":92}],"html":"postcss-preset-env","zIndex":91},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c83b9d32-0699-489a-b15c-0074c705258b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"843d6d5e-eded-4d1c-a68d-360b17c39a9d","children":[],"html":"压缩css代码，可以提取公共样式进行复用，缩短常见的属性值等","zIndex":94}],"html":"cssnano","zIndex":93}],"html":"常用PostCSS插件","zIndex":88}],"html":"PostCSS","zIndex":83},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"239c1844-00b4-408c-ab9d-dbbc94818046","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"02a762f7-7e00-44aa-a4cd-49fd2235ec93","children":[],"html":"对于 CSS In JS 方案，在构建侧我们需要考虑选择器命名问题、DCE(Dead Code Elimination 即无用代码删除)、代码压缩、生成 SourceMap、服务端渲染(SSR)等问题","zIndex":96},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f3605aa4-d27b-4863-8e42-2ef000b4be48","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"8a7a2470-1e52-45f5-90ef-8d0380f4c3b2","children":[],"html":"// vite.config.ts<div>import { defineConfig } from 'vite'</div><div>import react from '@vitejs/plugin-react'</div><div><br></div><div>// https://vitejs.dev/config/</div><div>export default defineConfig({</div><div>&nbsp; plugins: [</div><div>&nbsp; &nbsp; react({</div><div>&nbsp; &nbsp; &nbsp; babel: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // 加入 babel 插件</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // 以下插件包都需要提前安装</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // 当然，通过这个配置你也可以添加其它的 Babel 插件</div><div>&nbsp; &nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 适配 styled-component</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"babel-plugin-styled-components\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 适配 emotion</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; \"@emotion/babel-plugin\"</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; // 注意: 对于 emotion，需要单独加上这个配置</div><div>&nbsp; &nbsp; &nbsp; // 通过 `@emotion/react` 包编译 emotion 中的特殊 jsx 语法</div><div>&nbsp; &nbsp; &nbsp; jsxImportSource: \"@emotion/react\"</div><div>&nbsp; &nbsp; })</div><div>&nbsp; ]</div><div>})</div>","zIndex":98}],"html":"styled-components和emotion已经提供了对应的 babel 插件来解决这些问题，我们在 Vite 中要做的就是集成这些 babel 插件","zIndex":97}],"html":"CSS in JS","zIndex":95},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f57a920f-3db6-4b2e-81cd-0ec8b7330094","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"717afc01-bdaa-4240-89de-d2537c3149c7","children":[],"html":"Tailwind CSS 在 v3 版本也引入 JIT(即时编译) 的功能，解决了开发环境下 CSS 产物体积庞大的问题","zIndex":100},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"109bf883-c670-47c2-b888-b9d6fc00f8ae","children":[],"html":"pnpm install -D tailwindcss postcss autoprefixer","zIndex":101},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1ad56726-74d8-44bc-af88-2c2029864607","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"20f8a0d5-7623-490e-8bc7-cbe483f6127c","children":[],"html":"// tailwind.config.js<div>module.exports = {</div><div>&nbsp; content: [</div><div>&nbsp; &nbsp; \"./index.html\",</div><div>&nbsp; &nbsp; \"./src/**/*.{vue,js,ts,jsx,tsx}\",</div><div>&nbsp; ],</div><div>&nbsp; theme: {</div><div>&nbsp; &nbsp; extend: {},</div><div>&nbsp; },</div><div>&nbsp; plugins: [],</div><div>}</div><div><br></div><div>// postcss.config.js</div><div>// 从中你可以看到，Tailwind CSS 的编译能力是通过 PostCSS 插件实现的</div><div>// 而 Vite 本身内置了 PostCSS，因此可以通过 PostCSS 配置接入 Tailwind CSS&nbsp;</div><div>// 注意: Vite 配置文件中如果有 PostCSS 配置的情况下会覆盖掉 post.config.js 的内容!</div><div>module.exports = {</div><div>&nbsp; plugins: {</div><div>&nbsp; &nbsp; tailwindcss: {},</div><div>&nbsp; &nbsp; autoprefixer: {},</div><div>&nbsp; },</div><div>}</div>","zIndex":103}],"html":"新建两个配置文件tailwind.config.js和postcss.config.js","zIndex":102},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"108fdef5-d3fe-425e-bf72-e8c5efced7c7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b590d825-b4b7-4521-b199-245e016eec7e","children":[],"html":"@tailwind base;<div>@tailwind components;</div><div>@tailwind utilities;</div>","zIndex":105}],"html":"在项目的入口 CSS 中引入必要的样板代码","zIndex":104},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"28f3a405-3151-4086-908c-a2549ae568b6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e3cdd49f-050f-46aa-a7f6-06152119c96e","children":[],"html":"&lt;p className=\"bg-red-400\"&gt;Hello Vite + React!&lt;/p&gt;","zIndex":107}],"html":"使用","zIndex":106}],"html":"CSS 原子化框架","zIndex":99}],"html":"Vite 的样式方案配置","zIndex":78}],"html":"CSS工程化方案","layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"collapsed":true,"zIndex":53},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"fcfa86c9-c0fa-43bb-9425-53906e2008af","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"75450e06-719d-491d-81f3-afe944b0e8aa","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"0ef64213-b74e-4756-8970-fbf598e89dc0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4f51e9df-3337-499a-ac64-c65a59c8bdc1","children":[],"html":"pnpm i eslint -D","zIndex":111},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"90fca961-5683-48d8-bd53-bcdc7abe276e","children":[],"html":"npx eslint --init","zIndex":112},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5b07dae6-ed0c-4153-929d-2452e370453e","children":[],"html":"接着 ESLint 会帮我们自动生成.eslintrc.js配置文件","zIndex":113},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"dcc85949-9fb7-4bb8-a310-3453eddd4190","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5a668797-40db-4008-8a09-6d039692ade8","children":[],"html":"pnpm i eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest -D","zIndex":115}],"html":"安装依赖","zIndex":114}],"html":"初始化","zIndex":110},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1d38ceee-2cc3-4dae-a759-fa893a74bb3f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"76becb24-32fa-4123-a439-05c371ad3041","children":[],"html":"parser - 解析器","zIndex":117},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6d5e4837-0ce7-4034-994d-c0c570b730a9","children":[],"html":"parserOptions - 解析器选项","zIndex":118},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"19f58a3c-cff8-4345-9994-cbe384379022","children":[],"html":"rules - 具体代码规则","zIndex":119},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ea4b6bdb-2f28-41e3-97f5-a4adb4c18d15","children":[],"html":"plugins","zIndex":120},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a3c6d43c-0d30-4a20-bcf5-e10f08674594","children":[],"html":"extends - 继承配置","zIndex":121},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c55c07c4-af31-444b-8651-144eeedb4a35","children":[],"html":"env 和 globals","zIndex":122}],"html":"核心配置","zIndex":116},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f82a42e9-28a1-48d2-a046-d9bd4bf00b25","children":[],"html":"与 Prettier 强强联合","zIndex":123},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"24ecd89d-5251-4df0-b63a-3ba6b4f1c6fc","children":[],"zIndex":124,"html":"在 Vite 中接入 ESLint"}],"html":"JS规范工具：ESlint","collapsed":true,"zIndex":109},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a76b332a-f867-4f74-bd5f-0b3f16c722a2","children":[],"html":"样式规范工具","zIndex":125},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"df81b54c-8bd6-4c58-a366-7a7958b0243d","children":[],"html":"Husky+lint-staged 的Git提交工作流集成","zIndex":126}],"html":"代码规范：Lint工具链","collapsed":true,"zIndex":108},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"621c6b32-2ba2-4001-a78f-e8ee31f6ba3c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"623c7a92-81e8-4781-b2d7-0f277b7cc9a1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"38238acc-f28a-457f-b12f-6203c8c25850","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3a82ee8d-5806-4625-a64b-fbc708c6cc0b","children":[],"html":"alias 别名配置不仅在 JavaScript 的 import 语句中生效，在 CSS 代码的 @import 和 url导入语句中也同样生效","zIndex":130},{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f0e8ed17-e37e-4e50-b400-0cb41e815351","children":[],"html":"// vite.config.ts<div>import path from 'path';</div><div>{</div><div>&nbsp; resolve: {</div><div>&nbsp; &nbsp; // 别名配置</div><div>&nbsp; &nbsp; alias: {</div><div>&nbsp; &nbsp; &nbsp; '@assets': path.join(__dirname, 'src/assets')</div><div>&nbsp; &nbsp; }</div><div>&nbsp; }</div><div>}</div>","layout":{"quadrant":1},"zIndex":131}],"html":"配置别名","zIndex":129},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"48e9fd57-0755-4c5c-80fb-da9cc9b61e20","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e07d0d9f-1ef6-418e-949b-e976f1552c7f","children":[],"html":"<div><span style>import logoSrc from '@assets/imgs/vite.png';</span><br></div><div>export function Header() {</div><div>&nbsp; return (</div><div>&nbsp; &nbsp; &lt;img className=\"m-auto mb-4\" src={logoSrc} alt=\"\" /&gt;</div><div>&nbsp; );</div><div>}</div>","zIndex":133}],"html":"使用","zIndex":132},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6c51ba1a-3b44-4327-a91e-7617af5e6c3f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"0e210319-672c-4fb1-b3af-3af2eb7486c8","children":[],"html":"将svg当做一个组件来引入","zIndex":135},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"569adf7f-8409-48c8-b320-871b4f37cca1","children":[],"html":"Vue3 项目中可以引入 vite-svg-loader","zIndex":136},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1f2c737e-075a-4a72-9735-95c8b84e8be8","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"13f80c2d-3de6-4c44-99ed-19c1c601be5f","children":[],"html":"// vite.config.ts<div>import svgr from 'vite-plugin-svgr';</div><div>{</div><div>&nbsp; plugins: [</div><div>&nbsp; &nbsp; svgr()</div><div>&nbsp; ]</div><div>}</div>","zIndex":138},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5ac45621-498e-49d5-8de9-9fbe478b3cfd","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"71bb59ff-dfca-4409-bb44-01e68e676ff6","children":[],"html":"{<div>&nbsp; \"compilerOptions\": {</div><div>&nbsp; &nbsp; // 省略其它配置</div><div>&nbsp; &nbsp; \"types\": [\"vite-plugin-svgr/client\"]</div><div>&nbsp; }</div><div>}</div>","zIndex":140}],"html":"要在 tsconfig.json 添加如下配置，否则会有类型错误","zIndex":139},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5ecedb4a-e519-46a0-8da8-7de263435b7b","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"dc0dc0d0-0f79-484a-b3a0-bf8dfd3ad2af","children":[],"html":"import { ReactComponent as ReactLogo } from '@assets/icons/logo.svg';<div>export function Header() {</div><div>&nbsp; return (</div><div>&nbsp; &nbsp; &nbsp;&lt;ReactLogo /&gt;</div><div>&nbsp; )</div><div>}</div>","width":523.8997279566411,"zIndex":142}],"html":"使用 svg 组件","zIndex":141}],"html":"React 项目使用 vite-plugin-svgr插件","zIndex":137}],"html":"SVG 组件方式加载","zIndex":134}],"html":"图片加载","zIndex":128},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b92987f8-78c4-408c-bead-627e13b4dd14","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a4262cb9-1078-4d92-b61b-a8bfc60a1bc8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e68d86ce-4b60-49b9-9693-ceb5bf970b41","children":[],"html":"import { version } from '../../../package.json'","zIndex":145}],"html":"Vite 中已经内置了对于 JSON 文件的解析，底层使用@rollup/pluginutils 的 dataToEsm 方法将 JSON 对象转换为一个包含各种具名导出的 ES 模块","zIndex":144}],"html":"JSON加载","zIndex":143},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7ca0eac0-f411-491c-b9de-6ecb5513bd09","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fb2ab117-b81b-4ce4-b50d-a0076a65a5ee","children":[],"html":"引入的时候注意加上?worker后缀，相当于告诉 Vite 这是一个 Web Worker 脚本文件","zIndex":147}],"html":"Web Worker脚本","zIndex":146},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"a85fa984-ee8d-493e-9363-40705807c3af","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b567e96f-eda9-481e-9843-9f1840da212d","children":[],"html":"?url: 表示获取资源的路径，这在只想获取文件路径而不是内容的场景将会很有用","zIndex":149},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f9e84229-8c98-480f-9841-44d98bb1609b","children":[],"html":"?raw: 表示获取资源的字符串内容，如果你只想拿到资源的原始内容，可以使用这个后缀。","zIndex":150},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"297dce4f-cbb6-411d-bbd6-9627670cfbc8","children":[],"html":"?inline: 表示资源强制内联，而不是打包成单独的文件。","zIndex":151}],"html":"特殊资源后缀","zIndex":148},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"905c9286-5c33-4aa2-bfa4-b85f54fb638a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e594c3de-7665-4406-bb39-c8403fe59e86","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"96d8d4bd-ee20-4c87-9c9c-85f0b6b62252","children":[],"html":"// vite.config.ts<div>{</div><div>&nbsp; base: isProduction ? CDN_URL: '/'</div><div>}</div>","zIndex":154},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ea5404f6-2366-4f55-8d6c-6446b3a14808","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"cdce7e1a-09b2-4599-833b-8a0115778978","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"94794518-900f-413b-bfd6-9aaf2dfd414f","children":[],"html":"VITE_IMG_BASE_URL=https://my-image-cdn.com","zIndex":157}],"html":"在项目根目录新增.env文件","zIndex":156},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ba1f2f45-dec2-4026-b153-d709f5ac92e9","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"758d427e-8446-4d97-9448-9008cc002726","children":[],"html":"/// &lt;reference types=\"vite/client\" /&gt;<div><br></div><div>interface ImportMetaEnv {</div><div>&nbsp; readonly VITE_APP_TITLE: string;</div><div>&nbsp; // 自定义的环境变量</div><div>&nbsp; readonly VITE_IMG_BASE_URL: string;</div><div>}</div><div><br></div><div>interface ImportMeta {</div><div>&nbsp; readonly env: ImportMetaEnv;</div><div>}</div><div><br></div>","zIndex":159}],"html":"进入 src/vite-env.d.ts增加类型声明","zIndex":158},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"79019097-2a54-41c2-b824-2a0c3ec96489","children":[{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"71986185-f477-4aff-8095-380e3bb4c854","children":[],"html":"&lt;img src={new URL('./logo.png', import.meta.env.VITE_IMG_BASE_URL).href} /&gt;","height":62.65653346389854,"width":551.9438327248736,"zIndex":161}],"html":"使用","zIndex":160}],"html":"只有图片资源使用CDN域名","zIndex":155}],"html":"自定义部署域名","zIndex":153},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b263200e-eafb-4325-955a-4f6673e5808e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b5fad5c3-e928-4585-9605-b65f41129b7c","children":[],"html":"小的资源，内联到代码中，减少不必要的网络请求，优化网络性能","zIndex":163},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7e7091c4-47ef-4ff5-8ffb-fca7c9a53e5e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"915ff5eb-4278-48c5-91c0-08fa5d9d9beb","children":[],"html":"如果静态资源体积 &gt;= 4KB，则提取成单独的文件","zIndex":165},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b42e4c25-c06a-4082-a2ad-b07f40971f7b","children":[],"html":"如果静态资源体积 &lt; 4KB，则作为 base64 格式的字符串内联","zIndex":166},{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"16a494b1-e4b6-484e-a64f-682dd767cd14","children":[],"html":"// vite.config.ts<div>{</div><div>&nbsp; build: {</div><div>&nbsp; &nbsp; // 8 KB</div><div>&nbsp; &nbsp; assetsInlineLimit: 8 * 1024</div><div>&nbsp; }</div><div>}</div>","zIndex":167}],"html":"Vite内置方案","zIndex":164}],"html":"单文件 or 内联","zIndex":162},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"46f4e786-c8b8-45ec-b3d6-508e930564b0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"971c3d4e-1639-4b1b-b46d-893eb31ae7c3","children":[],"html":"pnpm i vite-plugin-imagemin -D","zIndex":169},{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d956ec31-9240-4f50-b465-3bed235e766c","children":[],"html":"//vite.config.ts<div>import viteImagemin from 'vite-plugin-imagemin';</div><div><br></div><div>{</div><div>&nbsp; plugins: [</div><div>&nbsp; &nbsp; // 忽略前面的插件</div><div>&nbsp; &nbsp; viteImagemin({</div><div>&nbsp; &nbsp; &nbsp; // 无损压缩配置，无损压缩下图片质量不会变差</div><div>&nbsp; &nbsp; &nbsp; optipng: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; optimizationLevel: 7</div><div>&nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; // 有损压缩配置，有损压缩下图片质量可能会变差</div><div>&nbsp; &nbsp; &nbsp; pngquant: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; quality: [0.8, 0.9],</div><div>&nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; // svg 优化</div><div>&nbsp; &nbsp; &nbsp; svgo: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; plugins: [</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: 'removeViewBox'</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; name: 'removeEmptyAttrs',</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; active: false</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; ]</div><div>&nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; })</div><div>&nbsp; ]</div><div>}</div>","width":460.6790621003124,"zIndex":170}],"html":"图片压缩","zIndex":168},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"69857e43-0c26-421e-9d66-fe763592bdb8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"92ac45d0-717c-4c51-8153-6f4cbce37235","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"528e3cdb-0b4b-4f19-93f5-3efcd5323c10","children":[],"html":"按需加载：const icons = import.meta.glob('../../assets/icons/logo-*.svg');","zIndex":173},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1fd31b41-4991-48e2-a1f0-e62ef3f8ee88","children":[],"html":"同步导入：const icons =&nbsp; import.meta.glob('*', { eager: true })&nbsp;","zIndex":174}],"html":"Vite 批量导入语法糖","zIndex":172},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"24512ba6-d08b-4b49-a963-144309e716bf","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"5abd071e-1070-490e-bde0-d61820d91878","children":[],"html":"pnpm i vite-plugin-svg-icons -D","zIndex":176},{"border":{"shape":"rect","stroke":"#a287e1","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"df2e05a2-293a-4b59-9bef-6fe5186ff24c","children":[],"html":"// vite.config.ts<div>import { createSvgIconsPlugin } from 'vite-plugin-svg-icons';</div><div><br></div><div>{</div><div>&nbsp; plugins: [</div><div>&nbsp; &nbsp; // 省略其它插件</div><div>&nbsp; &nbsp; createSvgIconsPlugin({</div><div>&nbsp; &nbsp; &nbsp; iconDirs: [path.join(__dirname, 'src/assets/icons')]</div><div>&nbsp; &nbsp; })</div><div>&nbsp; ]</div><div>}</div>","zIndex":177}],"html":"雪碧图","zIndex":175}],"html":"雪碧图优化","zIndex":171}],"html":"生产环境处理","collapsed":true,"zIndex":152}],"html":"静态资源处理","collapsed":true,"zIndex":127}],"html":"项目搭建","collapsed":true,"zIndex":3},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#FCF6E1","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"id":"d81e7b37-e744-456b-a28c-2806ab51c686","children":[{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"6b15e80a-d752-4bac-ad99-ca4c26ca0d35","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dd638cee-078d-4b39-ae0a-a60d5fcb788f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ca083e90-542e-45ee-a234-4d28284b5e6b","children":[],"html":"1. 将其他格式(如 UMD 和 CommonJS)的产物转换为 ESM 格式，使其在浏览器通过 &lt;script type=\"module\"&gt;&lt;script&gt;的方式正常加载","zIndex":180},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6209988a-b7f0-42d6-aa79-f5fad452e8c9","children":[],"html":"2. 打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量，避免页面加载性能劣化。","zIndex":181},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8b0ab7b4-6b72-4cfc-95da-cd471a920222","children":[],"html":"而这两件事情全部由性能优异的 Esbuild (基于 Golang 开发)完成，而不是传统的 Webpack/Rollup，所以也不会有明显的打包性能问题，反而是 Vite 项目启动飞快(秒级启动)的一个核心原因。","zIndex":182}],"html":"对第三方依赖进行预构建","collapsed":true,"zIndex":179}],"html":"为什么需要预构建","collapsed":true,"zIndex":178},{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"fc6abf80-f8e7-43ac-a68d-90f88855b1d3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"76dd71b1-ab1b-4a66-a221-2ca96a3f7e63","children":[],"html":"自动开启","zIndex":184},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7d1e18cc-6315-4f5f-afa7-3ed9090fe1f7","children":[],"html":"手动开启","zIndex":185}],"html":"如何开启预构建","collapsed":true,"zIndex":183},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1efce6dc-58e8-45f6-ade4-065d4697a93a","children":[],"html":"自定义配置详解","zIndex":186},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4887cdad-d3db-4bef-bc44-2cdb430f0a34","children":[],"html":"问题：第三方库出现问题怎么办","zIndex":187}],"html":"预构建","collapsed":true,"zIndex":5},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E9F7E9","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#77C386"},"id":"ec67febc-7344-410b-ab37-b24d4a13cfc7","children":[{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"44b2d081-d11a-4bc1-b9cf-c2a2aa5520ca","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5176d77a-e3d3-4c66-897a-644461c1f236","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a61450a2-3a36-44bf-a7fb-6cec48fcf925","children":[],"html":"<span style=\"font-weight:bold;\">对于第三方依赖，需要在应用启动前进行打包并且转换为 ESM 格式</span>","zIndex":190},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b385a07c-13bb-487a-8f02-f764b0817ec8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"30a9b21a-7e19-4232-bb21-a38d8834e971","children":[],"html":"不支持降级到 ES5 的代码。这意味着在低端浏览器代码会跑不起来","zIndex":192},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3069b966-ff8e-4200-9fde-72b0508b4ea0","children":[],"html":"不支持 const enum 等语法。这意味着单独使用这些语法在 esbuild 中会直接抛错","zIndex":193},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4720d40b-1bd8-4abe-92a6-cd3a158af467","children":[],"html":"不提供操作打包产物的接口，像 Rollup 中灵活处理打包产物的能力(如renderChunk钩子)在 Esbuild 当中完全没有。","zIndex":194},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"eb2919f6-7d72-4eaf-aeed-195c54a0ffb5","children":[],"html":"不支持自定义 Code Splitting 策略。传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 Esbuild 并未提供，从而降级了拆包优化的灵活性。","zIndex":195}],"html":"esbuild缺点","zIndex":191}],"html":"依赖预构建","collapsed":true,"zIndex":189},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dce51b82-aad9-4c75-907c-f2f7bb19a3ed","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9da20809-ed5d-4771-b654-dfae1a6ad06f","children":[],"html":"<span style=\"font-weight:bold;\">在 TS(X)/JS(X) 单文件编译上面，Vite 也使用 Esbuild 进行语法转译，也就是将 Esbuild 作为 Transformer 来用。</span>","zIndex":197},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"44ce35e1-21b5-49aa-b60c-e6524810883c","children":[],"html":"Esbuild 转译 TS 或者 JSX 的能力通过 Vite 插件提供，这个 Vite 插件在开发环境和生产环境都会执行","zIndex":198},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3ec99479-f45d-426c-8579-07478cff0b7b","children":[],"html":"<span style=\"font-weight:bold;\">Vite 已经将 Esbuild 的 Transformer 能力用到了生产环境</span>。尽管如此，对于低端浏览器场景，Vite 仍然可以做到语法和 Polyfill 安全","zIndex":199},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cca5e213-4134-461b-baf5-f2693706111d","children":[],"html":"这部分能力用来替换原先 Babel 或者 TSC 的功能，因为无论是 Babel 还是 TSC都有性能问题，大家对这两个工具普遍的认知都是: 慢，太慢了。","zIndex":200},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c24a11be-dec7-4f14-a626-c6df0469cad7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"66dc60c3-f469-40aa-b984-1485a123d14e","children":[],"html":" TS 中的类型检查问题。这是因为 Esbuild 并没有实现 TS 的类型系统，在编译 TS(或者 TSX) 文件时仅仅抹掉了类型相关的代码，暂时没有能力实现类型检查","zIndex":202},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"12cd7704-ac62-43e9-a975-9c9075f4b96f","children":[],"html":"vite build之前会先执行tsc命令，也就是借助 TS 官方的编译器进行类型检查","zIndex":203},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"69d05101-2d6a-473f-80fd-d01c90fec743","children":[],"html":"要解决类型问题，最好使用 TS 的编辑器插件。在开发阶段就能早早把问题暴露出来并解决","zIndex":204}],"html":"缺点","zIndex":201}],"html":"单文件编译：作为TS和JSX的编译工具","collapsed":true,"zIndex":196},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2f3e7426-6be0-4032-975f-e9781e807b60","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"589157f1-839e-4edd-9e19-92804c26aeb8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"268c61f7-3bf5-49bc-ac04-dfcfcdb883b4","children":[],"html":"Esbuild 可以<span style=\"font-weight:bold;\">共享 AST</span> 以及<span style=\"font-weight:bold;\">原生语言编写</span>的 Minifier 在性能上能够甩开传统工具的好几十倍。","zIndex":207},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"13468b1c-3207-4595-930c-a8733c078a73","children":[],"html":"压缩一个大小为3.2 MB的库，Terser 需要耗费8798 ms，而 Esbuild 仅仅需要361 ms，压缩效率较 Terser 提升了二三十倍","zIndex":208}],"html":"Vite 从 2.6 版本开始，默认使用 Esbuild 来进行生产环境的代码压缩，包括 JS 代码和 CSS 代码。","zIndex":206},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d810d796-4273-4acd-9fef-2d49cadd33ad","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ba6a997c-a49d-46ec-b774-89ea25ccb908","children":[],"html":"压缩这项工作涉及大量 AST 操作，并且在传统的构建流程中，AST 在各个工具之间无法共享，比如 Terser 就无法与 Babel 共享同一个 AST，造成了很多重复解析的过程","zIndex":210},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ae8704bd-02a4-45ed-93a9-06c5075ef928","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6ce3c85a-e654-43cd-b7e4-9500eb00b421","children":[],"html":"将 Go 语言（也称为 Golang）描述为“原生语言”通常是指它的编译器和运行时系统都是<span style=\"font-weight:bold;\">直接编译到本地机器代码的，而不是依赖于虚拟机或解释器</span>。这意味着 Go 代码在编译时会被转换成机器代码，然后直接在目标系统上运行，而无需额外的运行时环境。","zIndex":212}],"html":"JS 本身属于解释性 + JIT（即时编译） 的语言，对于压缩这种 CPU 密集型的工作，其性能远远比不上 Golang 这种原生语言","zIndex":211}],"html":"传统的方式都是使用 Terser 这种 JS 开发的压缩器来实现，在 Webpack 或者 Rollup 中作为一个 Plugin 来完成代码打包后的压缩混淆的工作。但 Terser 其实很慢，主要有 2 个原因。","zIndex":209}],"html":"代码压缩","collapsed":true,"zIndex":205}],"html":"性能利器：ESbuild","zIndex":188},{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"e40e8d58-5c6a-4d93-9e19-17a45b022a01","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e23054f5-98b3-4f33-9b8e-1309809bbf31","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"510f7ebb-b4ac-4776-a723-798b198c58ed","children":[],"html":"CSS 代码分割。如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的缓存复用率","zIndex":215},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e383d95c-d648-4521-93d0-36f1067dbaf2","children":[],"html":"自动预加载。Vite 会自动为入口 chunk 的依赖自动生成预加载标签&lt;link rel=\"modulepreload\"&gt;","zIndex":216},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d626377b-0347-405a-a4da-71a5c4a74ec3","children":[],"html":"异步 Chunk 加载优化。","zIndex":217}],"html":"生成环境bundle优化","collapsed":true,"zIndex":214},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c4a97024-aa2d-47eb-9b50-b3551bfdaf80","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2b2a92ce-f55d-4845-8e72-2900610ec6eb","children":[],"html":"在开发阶段，自己实现了一个 Plugin Container，用来模拟 Rollup 调度各个 Vite 插件的执行逻辑，而 Vite 的插件写法完全兼容 Rollup，因此在生产环境中将所有的 Vite 插件传入 Rollup 也没有问题","zIndex":219}],"html":"兼容插件机制","collapsed":true,"zIndex":218}],"html":"构建基石：Rollup","zIndex":213}],"html":"双引擎架构","icons":{"flag":3},"collapsed":true,"zIndex":7},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#e1effa"},"treeEdge":{"stroke-width":2,"stroke":"#69B1E4"},"defaultContentStyle":{"color":"#262626"},"id":"730b58d4-ee46-4c7d-b137-f56036afdf3b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"11f10da4-1c4b-4f35-ba96-f32c20b6a7dd","children":[],"html":"ESbuild是基于Golang开发的一款打包工具","layout":{"quadrant":1},"zIndex":220},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4405a335-b4ac-415c-af01-830be2f8aa3a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8a63d6d2-50cb-4c03-87a4-5b17810db8b9","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b9d7acf4-972b-41c0-a4b9-7583778d6a69","children":[],"html":"构建逻辑代码直接被编译为原生机器码，而不用像 JS 一样先代码解析为字节码，然后转换为机器码，大大节省了程序运行时间","zIndex":223}],"html":"1. 使用golong开发","zIndex":222},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2f0f24e3-0ba1-4647-8e68-feaa256a6f5b","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bd90c89e-9d8e-4c7f-8739-357b06879b30","children":[],"html":"内部打包算法充分利用多核 CPU 优势，所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势","zIndex":225}],"html":"2. 多核并行","zIndex":224},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8dce7700-bf24-4d2a-9754-2744cd6da09f","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b9517d97-d586-4d23-8333-8ffe39ac5824","children":[],"html":"几乎没有使用任何第三方库，所有逻辑自己编写，大到 AST 解析，小到字符串的操作，保证极致的代码性能","zIndex":227}],"html":"3. 从零造轮子","zIndex":226},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"06f2d43d-1706-4128-93c8-0e6c9d42f965","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2cadcd28-8a52-4d84-b648-cd50dd33f5d3","children":[],"html":"Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据（如 string -&gt; TS -&gt; JS -&gt; string)，造成内存的大量浪费","zIndex":229}],"html":"4. 高效的内存利用","zIndex":228}],"html":"为什么ESbuild性能高","collapsed":true,"zIndex":221},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3cd6b5da-4a26-47eb-96c7-ee8bdc17b2cf","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ebe6db8f-7baa-4f9d-81ab-17f5d7501a68","children":[],"html":"pnpm i esbuild@0.14.18","zIndex":231}],"html":"安装","zIndex":230},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"63deb1c6-ee7a-420a-a34d-9b58a46637bf","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2a42a481-5568-4cb1-8c7d-5891409b5da8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6cd89366-7bed-4ee7-8067-493a0c07d69a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"685487d5-a410-476c-97b2-1278b4c25c20","children":[],"html":"build","zIndex":235},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dace975a-363e-4630-8042-c7be185d72bc","children":[],"html":"buildSync","zIndex":236},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b55ac08d-cddc-45ba-a204-eef8fbdcb161","children":[],"html":"serve","zIndex":237}],"html":"Build API","zIndex":234}],"html":"项目打包","layout":{"quadrant":1},"zIndex":233},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"97be4bda-af96-4657-a2bc-47e0cde33855","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a3ab019c-6950-453c-8409-50d47579ee73","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b50c6044-1a1c-4a26-9e83-e988f59fb68c","children":[],"html":"transformSync","zIndex":240},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"67beca31-136c-46f4-8be2-5ffe3c59a276","children":[],"html":"transform","zIndex":241}],"html":"Transform API","zIndex":239}],"html":"单文件转译","layout":{"quadrant":1},"zIndex":238}],"html":"API","zIndex":232},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4bff6a93-5e5b-4099-8f0d-856e24a4e7b0","children":[],"html":"ESbuild插件开发","layout":{"quadrant":1},"zIndex":242}],"html":"Esbuild 功能使用和插件开发","layout":{"quadrant":1},"collapsed":true,"zIndex":9},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#E8EEFC","stroke":"transparent"},"id":"95d80b16-dfea-454f-add4-ff77720cf3af","children":[{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"6b54a4c9-0c34-425b-a2d5-7b6b5efcbcf5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d8d8de7e-2f9e-427f-86c8-625a2f67fe0b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3e9c137d-71aa-48e9-9431-9d2c9202bdf5","children":[],"html":"多产物配置","zIndex":245},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dfa5e12c-f217-4d02-b2c3-e3b481eef019","children":[],"html":"多入口配置","zIndex":246},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4bb39e08-0995-464f-acda-53ae807c6eea","children":[{"border":{"shape":"rect","stroke":"#6f81db","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"da5a5179-6ec4-4082-b5df-6b35cc9101f8","children":[],"html":"output: {<div>&nbsp; // 产物输出目录</div><div>&nbsp; dir: path.resolve(__dirname, 'dist'),</div><div>&nbsp; // 以下三个配置项都可以使用这些占位符:</div><div>&nbsp; // 1. [name]: 去除文件后缀后的文件名</div><div>&nbsp; // 2. [hash]: 根据文件名和文件内容生成的 hash 值</div><div>&nbsp; // 3. [format]: 产物模块格式，如 es、cjs</div><div>&nbsp; // 4. [extname]: 产物后缀名(带`.`)</div><div>&nbsp; // 入口模块的输出文件名</div><div>&nbsp; entryFileNames: `[name].js`,</div><div>&nbsp; // 非入口模块(如动态 import)的输出文件名</div><div>&nbsp; chunkFileNames: 'chunk-[hash].js',</div><div>&nbsp; // 静态资源文件输出文件名</div><div>&nbsp; assetFileNames: 'assets/[name]-[hash][extname]',</div><div>&nbsp; // 产物输出格式，包括`amd`、`cjs`、`es`、`iife`、`umd`、`system`</div><div>&nbsp; format: 'cjs',</div><div>&nbsp; // 是否生成 sourcemap 文件</div><div>&nbsp; sourcemap: true,</div><div>&nbsp; // 如果是打包出 iife/umd 格式，需要对外暴露出一个全局变量，通过 name 配置变量名</div><div>&nbsp; name: 'MyBundle',</div><div>&nbsp; // 全局变量声明</div><div>&nbsp; globals: {</div><div>&nbsp; &nbsp; // 项目中可以直接用`$`代替`jquery`</div><div>&nbsp; &nbsp; jquery: '$'</div><div>&nbsp; }</div><div>}</div>","height":659.0822868127731,"width":608.8291902186447,"zIndex":248}],"html":"自定义output配置","collapsed":true,"zIndex":247},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"48512e46-e3cb-4d3f-8cc2-e1aa0a11f986","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3b1d0583-ef27-4b94-b5c9-5c91faf9fbaa","children":[],"html":"不想通过rollup打包的第三方包","layout":{"quadrant":1},"zIndex":250},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5e4cd469-f8ef-4be0-b937-1cb9e0b2870c","children":[],"html":"external: ['react', 'react-dom']","zIndex":251}],"html":"依赖external","zIndex":249},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6a5cd34e-3b1d-4fe1-9a33-18021c0fafe7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d36c353c-7a86-471b-aa34-b9bf74106335","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b083bed0-018e-496a-9be1-30d7b83aa8d3","children":[],"html":"为了允许我们加载第三方依赖，否则像import React from 'react' 的依赖导入语句将不会被 Rollup 识别","zIndex":254}],"html":"@rollup/plugin-node-resolve","zIndex":253},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6a5b3d12-54c6-47a9-8815-e46f01cd98db","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9d03eacc-d2e2-42ba-8e51-eaf819686fd9","children":[],"html":"作用是将 CommonJS 格式的代码转换为 ESM 格式","zIndex":256}],"html":"@rollup/plugin-commonjs","zIndex":255},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a119a3b3-2e20-452e-a97c-d20aeaf89f76","children":[],"html":"@rollup/plugin-json： 支持.json的加载，并配合rollup的Tree Shaking机制去掉未使用的部分，进行按需打包。","zIndex":257},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b0ac0039-d144-479c-9b0b-16058e4868f4","children":[],"html":"@rollup/plugin-babel：在 Rollup 中使用 Babel 进行 JS 代码的语法转译。","zIndex":258},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5343c68a-2adb-40a5-9480-2a107ba35736","children":[],"html":"@rollup/plugin-typescript: 支持使用 TypeScript 开发。","zIndex":259},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"deea27d6-985e-449b-96b6-512af2b2185a","children":[],"html":"@rollup/plugin-alias：支持别名配置。","zIndex":260},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f8acbaaa-d7b6-454c-99e6-b354e930b49d","children":[],"html":"@rollup/plugin-replace：在 Rollup 进行变量字符串的替换。","zIndex":261},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bc631ac3-388f-4856-9125-9f74225e83d2","children":[],"html":"rollup-plugin-visualizer: 对 Rollup 打包产物进行分析，自动生成产物体积可视化分析图。","zIndex":262}],"html":"接入插件能力","zIndex":252}],"html":"常规配置","collapsed":true,"zIndex":244},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"72d17dc5-edeb-470a-ba13-45f90489a0df","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6a40ff76-34c0-4c98-aab1-386631af102d","children":[],"html":"如果需要定制rollup的打包过程，需要用到JavaScript API的方式来打包","zIndex":264},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"96d8f652-2613-443f-9c9e-182a5e9d1bb1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"599cc429-9d2e-4510-bd74-4461e84e46d5","children":[],"html":"rollup.rollup","zIndex":266},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c050931d-5d52-40a5-9209-fc77f1f1b2bf","children":[],"html":"rollup.watch","zIndex":267}],"html":"API","zIndex":265},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3b9472f4-5a06-4ae8-828d-64835ec1ec46","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"94b04f42-96b5-454b-bf40-0391a1a78851","children":[],"html":"新建build.js","zIndex":269},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"95501299-9691-4dc1-bfbf-15af1f3c4a5f","children":[],"html":"通过 rollup.rollup方法，传入 inputOptions，生成 bundle 对象","zIndex":270},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"32dce0bf-ab11-40e2-82b1-b5cffd1fdc0c","children":[],"html":"调用 bundle 对象的 generate 和 write 方法，传入outputOptions，分别完成产物和生成和磁盘写入。","zIndex":271},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"da0bc594-2b5a-4d9f-8c51-d58d7cf8ff6c","children":[],"html":"调用 bundle 对象的 close 方法来结束打包。","zIndex":272},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"01b76ed1-d13d-419d-9609-4723cddffa18","children":[],"html":"node build.js","zIndex":273}],"html":"使用方法","zIndex":268}],"html":"JS API 方式调用","collapsed":true,"zIndex":263}],"html":"Rollup打包基本概念及使用","zIndex":243},{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"cc54be37-8eae-462f-876f-363a764ba2bf","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"584dcb15-b343-44c0-b691-6587a550120b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"48cce176-08c2-4fa9-b3a6-8f22799717b9","children":[],"html":"Rollup 会先进入到 Build 阶段，解析各模块的内容及依赖关系","zIndex":276},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"86559a65-8592-401c-ab7c-7a7dc0318063","children":[],"html":"然后进入Output阶段，完成打包及输出的过程","zIndex":277}],"html":"构建过程","zIndex":275}],"html":"Rollup插件机制","zIndex":274}],"html":"Vite 构建基石：Rollup","treeEdge":{"stroke":"#6F81DB","stroke-width":2},"collapsed":true,"zIndex":11},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#ece7f9"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"9581d844-5f89-4e1a-b29e-c28a19452cda","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1d3ebd6a-c667-493f-b7f5-ee2992e4e02b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9f23cfde-e8d2-4844-a1fa-815673a75dfb","children":[],"html":"// myPlugin.js<div>export function myVitePlugin(options) {</div><div>&nbsp; console.log(options)</div><div>&nbsp; return {</div><div>&nbsp; &nbsp; name: 'vite-plugin-xxx',</div><div>&nbsp; &nbsp; load(id) {</div><div>&nbsp; &nbsp; &nbsp; // 在钩子逻辑中可以通过闭包访问外部的 options 传参</div><div>&nbsp; &nbsp; }</div><div>&nbsp; }</div><div>}</div><div>// 使用方式</div><div>// vite.config.ts</div><div>import { myVitePlugin } from './myVitePlugin';</div><div>export default {</div><div>&nbsp; plugins: [myVitePlugin({ /* 给插件传参 */ })]</div><div>}</div>","zIndex":279}],"html":"示例","zIndex":278},{"border":{"shape":"rect","stroke":"transparent","fill":"#ece7f9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0e94d1f2-8cc6-4e7d-8e8b-1f801a89af68","children":[],"html":"插件 Hook&nbsp;","zIndex":280}],"html":"如何开发Vite插件","collapsed":true,"icons":{"flag":5},"zIndex":12},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#ece7f9"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"4fcf5def-afc4-4b57-bdc2-2ec9cbc62a2c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"86d6488f-34af-4776-b686-7c5074bbf21e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2b7439a1-7c74-412c-b269-2e0897f05881","children":[],"html":"1. 页面打开只加载必要内容，提升页面性能","zIndex":282},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e03dad71-7d8a-4d52-87dd-f763bc233411","children":[],"html":"2. 提升缓存命中率，实现文件的缓存复用，降低页面加载的网络开销","zIndex":283}],"html":"拆包解决了什么问题","zIndex":281},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"46630db9-040a-4460-a49b-01677a7d9431","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0777a578-c4b6-4064-bbd0-483faf7fa35d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"64c18a1f-38ad-448c-92c9-4bffe424acc5","children":[],"html":"实现了 CSS 代码分割与业务代码、第三方库代码、动态 import 模块代码三者的分离","zIndex":286}],"html":"优点","zIndex":285},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"060bc9cb-0ca1-4b26-8b6c-57059ec48dd7","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a206ab32-81c5-4dc7-8ef7-bc7dc1292448","children":[],"html":"第三方库的打包产物容易变得比较臃肿，需要通过manualChunks自定义拆包","zIndex":288}],"html":"缺点","zIndex":287}],"html":"Vite 默认拆包策略","zIndex":284},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a88e83b5-a640-4304-9cef-ce537a92867a","children":[{"border":{"shape":"rect","stroke":"#a287e1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6c058047-9745-4dc3-a625-87bb59b7c02d","children":[],"html":"// vite.config.ts<div>{</div><div>&nbsp; build: {</div><div>&nbsp; &nbsp; rollupOptions: {</div><div>&nbsp; &nbsp; &nbsp; output: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // manualChunks 配置</div><div>&nbsp; &nbsp; &nbsp; &nbsp; manualChunks: {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将 React 相关库打包成单独的 chunk 中</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'react-vendor': ['react', 'react-dom'],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将 Lodash 库的代码单独打包</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'lodash': ['lodash-es'],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // 将组件库的代码打包</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'library': ['antd', '@arco-design/web-react'],</div><div>&nbsp; &nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; &nbsp; },</div><div>&nbsp; &nbsp; }</div><div>&nbsp; },</div><div>}</div>","height":422.5092758578842,"width":373.2765753751246,"zIndex":290}],"html":"自定义拆包策略","collapsed":true,"zIndex":289}],"html":"代码分割","collapsed":true,"zIndex":10},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#e2e6f8"},"treeEdge":{"stroke-width":2,"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"ff04c983-ad43-4d50-8743-a9a1390df323","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ba23486b-8be3-459c-b6e5-e2a422e65602","children":[],"html":"问题：低版本浏览器，需要兼容到IE 11、iOS 9以及Android 4.4的场景中遇到Promise 或者ES新版本对象数组方法，会发生报错，页面白屏的现象。这是语法降级和Polyfill缺失的问题","zIndex":291},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"db098e72-fba5-4401-9cdf-103a8302d19c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b3d9978f-91d0-4b44-82b9-7585088cc228","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"782b3e5c-9517-491e-b4fd-d0eab01dc744","children":[],"html":"作用是在代码编译阶段进行语法降级及添加 polyfill 代码的引用语句，如:<div>import \"core-js/modules/es6.set.js\"</div>","zIndex":294}],"html":"编译时工具。代表工具有@babel/preset-env和@babel/plugin-transform-runtime","zIndex":293},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"32a2d899-9e1c-4078-9813-8afd2ab74dd4","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"348cd0de-d6e1-4b94-9e2a-496309a34772","children":[],"html":"运行时基础库是根据 ESMAScript官方语言规范提供各种Polyfill实现代码","zIndex":296}],"html":"运行时基础库。代表库包括core-js和regenerator-runtime","zIndex":295}],"html":"语法兼容问题解决","zIndex":292},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6de26b3b-ad3f-4cc1-a52e-aae935be0f9b","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"618ab938-fa8d-48c1-bb97-0b345431332c","children":[],"html":"Vite 官方已经为我们封装好了一个开箱即用的方案: <span style=\"font-weight:bold;\">@vitejs/plugin-legacy</span>，我们可以基于它来解决项目语法的浏览器兼容问题","zIndex":298},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c0809822-5448-4874-867b-d0fa659b4a8c","children":[],"html":"这个插件内部同样使用 @babel/preset-env 以及 core-js等一系列基础库来进行语法降级和 Polyfill 注入","zIndex":299}],"html":"Vite 的解决方案","zIndex":297}],"html":"语法降级与Polyfill","collapsed":true,"zIndex":8},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#e2f3f3"},"treeEdge":{"stroke-width":2,"stroke":"#6EC4C4"},"defaultContentStyle":{"color":"#262626"},"id":"2dcd9b78-d43c-40e2-a447-9946c34440a4","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e544438e-e7a0-4a2c-8af4-2191be9d7944","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a1dbe327-41dc-4304-990d-ec4ff51982f7","children":[],"html":"首屏加载速度慢，页面渲染依赖JS的下载和执行","zIndex":301},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2a9e65d7-d758-4430-aa3c-0842c11b06ff","children":[],"html":"对SEO不友好","zIndex":302}],"html":"CSR 客户端渲染有什么问题","zIndex":300},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6430a67d-49bb-4a15-88c7-92b0a7faddb9","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"91b3040e-1f3e-4d49-b45c-680cc8aa7c6a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2c416e39-8d60-47df-83f4-b1f7f9734801","children":[],"html":"降低首屏渲染时间","zIndex":305},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"60dacab2-2e1f-4f81-875f-6d8ad0e90e28","children":[],"html":"利于SEO","zIndex":306}],"html":"服务端生成好完整的 HTML 内容，直接返回给浏览器，浏览器能够根据 HTML 渲染出完整的首屏内容，而不需要依赖 JS 的加载","zIndex":304},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"29277e8e-d599-4504-b976-bee763b992a1","children":[],"html":"SSR 中只能生成页面的内容和结构，并不能完成事件绑定，因此需要在浏览器中执行 CSR 的 JS 脚本，完成事件绑定，让页面拥有交互的能力，这个过程被称作<span style=\"font-weight:bold;\">hydrate(翻译为注水或者激活)</span>。同时，像这样服务端渲染 + 客户端 hydrate 的应用也被称为<span style=\"font-weight:bold;\">同构应用</span>","zIndex":307}],"html":"SSR 是什么","zIndex":303},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4d4b10cd-352a-43f3-b7ae-23a2cea42da6","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"52c5e6f2-56d3-446d-aa80-e763e0d4bc52","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f2dc0d55-6f9b-4419-98e1-7838c6ecd26e","children":[],"html":"构建时：保证前端代码编译后在服务端可以正常执行","zIndex":310},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"aee21eaa-cb53-4f01-88ba-31ebb78a898a","children":[],"html":"运行时：服务端需要渲染前端组件，生成并组装应用的HTML","zIndex":311}],"html":"服务端(Nodejs)如何提前渲染html内容","zIndex":309},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f01db4a1-9c39-4cae-a6fd-3c755bede9a7","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6c26897c-d37d-4378-ac21-98ece753178d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bb7c50a7-49b1-4813-b19e-f3cc9f47df75","children":[],"html":"在原有的构建过程之外，需要加入SSR 构建的过程 ，具体来说，我们需要另外生成一份 CommonJS 格式的产物，使之能在 Node.js 正常加载。当然，随着 Node.js 本身对 ESM 的支持越来越成熟，我们也可以复用前端 ESM 格式的代码","zIndex":314}],"html":"1. 解决模块加载问题","zIndex":313},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0d6bf0cf-d7e7-471d-851c-b6eee6da224e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cbd2dc66-bec4-43f0-ab45-fdfcf44a1258","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"90e45424-d40f-4964-970e-fffb81055cf3","children":[],"html":"import styles from './index.module.css'<div>// 这里的 styles 是一个对象，如{ \"container\": \"xxx\" }，而不是 CSS 代码</div><div>console.log(styles)</div>","zIndex":317}],"html":"直接引入一行 css 在服务端其实是无法执行的，因为 Node.js 并不能解析 CSS 的内容。但 CSS Modules 的情况除外，如下所示:","zIndex":316}],"html":"2. 移除样式代码的引入","zIndex":315},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a21b6886-51f5-417b-adce-792b746e0e13","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1804da96-4faf-45af-b82c-1efd09ec2bcc","children":[],"html":"对于某些第三方依赖我们并不需要使用构建后的版本，而是直接从 node_modules 中读取，比如 react-dom，这样在 SSR 构建的过程中将不会构建这些依赖，从而极大程度上加速 SSR 的构建。","zIndex":319}],"html":"3. 依赖外部化(external)","zIndex":318}],"html":"构建时","zIndex":312},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7fecc6fe-faad-455c-96ed-c964d167ef73","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"28b3bb48-f951-45d3-b081-82bec423bc18","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1f1828dc-38dd-452b-8e36-8323ec4f0703","children":[],"html":"在这个阶段，我们需要确定 SSR 构建产物的入口，即组件的入口在哪里，并加载对应的模块。","zIndex":322}],"html":"1. 加载 SSR 入口模块","zIndex":321},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c3c8c351-8bbf-4b2d-89ec-3d31a031091d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f5ba5035-40d4-4ee9-acc2-1eb316808405","children":[],"html":"这时候 Node 侧会通过查询数据库或者网络请求来获取应用所需的数据。","zIndex":324}],"html":"2. 进行数据预取","zIndex":323},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1b1343d3-57b8-4714-ad47-8c8b69aba6c0","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"214d61f1-130b-481a-abb5-9f5bd560b0c1","children":[],"html":"这个阶段为 SSR 的核心，主要将第 1 步中加载的组件渲染成 HTML 字符串或者 Stream 流。","zIndex":326}],"html":"3. 渲染组件","zIndex":325},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c8378417-9657-47d6-8e5e-3b214ef38533","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f18b0b54-a822-4761-b0ad-39cb9f88b211","children":[],"html":"在组件渲染完成之后，我们需要拼接完整的 HTML 字符串，并将其作为响应返回给浏览器。","zIndex":328},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"050c3b1f-605f-43e4-8316-583d70e12236","children":[],"html":"通过 react-dom/server 的 renderToString 方法实现","zIndex":329}],"html":"4. HTML拼接","zIndex":327}],"html":"运行时","zIndex":320}],"html":"SSR 生命周期","zIndex":308},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"638fe268-bb1d-4575-b5f5-374bd0ce9f45","children":[],"html":"基于Vite 搭建SSR项目","zIndex":330}],"html":"预渲染与SSR","collapsed":true,"zIndex":6},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#f9f1df"},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"defaultContentStyle":{"color":"#262626"},"id":"a93be05b-fe64-4471-bd91-02125e0fc479","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2be21076-3e75-40cc-9cac-d4500871c037","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5e0193a9-c67f-4d5f-97ac-4b8aa03fc350","children":[],"html":"公共组件、公共工具函数、公共第三方依赖等如何更好的复用","zIndex":332}],"html":"场景","zIndex":331},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dfba1798-bd14-4ccf-b71d-5a07ace649df","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f278f25b-1c90-45f3-9dd5-eb1e88faff9e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d39cf23d-c6d4-49e0-9147-4b8a168621ca","children":[],"html":"可以解决复用问题，但是存在新的问题","zIndex":335},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f7d952f0-a8f3-4cac-a6ac-63804e2df8e2","children":[],"html":"每次改动需要发版，所有相关的应用需要安装新的依赖，流程复杂","zIndex":336},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5754536d-5e9c-459a-aa77-33dadb2e365e","children":[],"html":"引入了公共库之后，公共库的代码都需要打包到项目最后的产物后，导致产物体积偏大，构建速度相对较慢。","zIndex":337}],"html":"1. 发布 npm 包","zIndex":334},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b1eb1345-0e67-4145-90cf-2bbb88ec3927","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d97e318e-d418-4f97-b1bc-0fbe85377bc0","children":[],"html":"通过 git submodule 的方式，我们可以将代码封装成一个公共的 Git 仓库，然后复用到不同的应用中，但也需要经历如下的步骤","zIndex":339},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9a2dda0f-c5f9-41ad-87f3-3589a3f2e9c4","children":[],"html":"1. 公共库 lib1 改动，提交到 Git 远程仓库；","zIndex":340},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"37c6648c-a847-4c68-a821-9ed4fa99f017","children":[],"html":"2. 所有的应用通过git submodule命令更新子仓库代码，并进行联调。","zIndex":341},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3c32bfd7-650e-4e2f-b2a7-82083e1b067c","children":[],"html":"和npm方式差别不大","zIndex":342}],"html":"2. Git Submodule","zIndex":338},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2741d056-a5d2-49c2-ba3e-92be40f66fc3","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3a40f929-a0f4-4466-8d2b-163c1e4eb486","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"be00a622-9e0c-438a-938e-405efb2e964e","children":[],"html":"并不是所有的依赖都有 UMD 格式的产物，因此这种方案不能覆盖所有的第三方 npm 包。","zIndex":345}],"html":"兼容性问题","zIndex":344},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a5952de2-30c4-4b03-be6d-b1692a4a8815","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"01ac782e-9198-4d60-88bf-7f3b3bf34224","children":[],"html":"我们通常需要考虑间接依赖的问题，如对于 antd 组件库，它本身也依赖了 react 和 moment，那么react和moment 也需要 external，并且在 HTML 中引用这些包，同时也要严格保证引用的顺序，比如说moment如果放在了antd后面，代码可能无法运行。而第三方包背后的间接依赖数量一般很庞大，如果逐个处理，对于开发者来说简直就是噩梦。","zIndex":347}],"html":"依赖顺序问题","zIndex":346},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"da5289a9-0397-454e-b379-4cff3176a70c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8c525e67-973a-4cc5-bc3a-38b5fbd44fb0","children":[],"html":"由于依赖包被声明external之后，应用在引用其 CDN 地址时，会全量引用依赖的代码，这种情况下就没有办法通过 Tree Shaking 来去除无用代码了，会导致应用的性能有所下降。","zIndex":349}],"html":"产物体积问题","zIndex":348}],"html":"3. 依赖外部化 + CDN","zIndex":343},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4ce96d88-c486-40cc-ba50-0359db42e37f","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a9ea69cb-da13-44ae-b727-ef2689e829b9","children":[],"html":"作为一种新的项目管理方式，Monorepo 也可以很好地解决模块复用的问题。","zIndex":351},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"df132c1b-f0d3-490a-8611-d40c51ca3538","children":[],"html":"在 Monorepo 架构下，多个项目可以放在同一个 Git 仓库中，各个互相依赖的子项目通过软链的方式进行调试，代码复用显得非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到。","zIndex":352},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e99fb7d6-7d6b-425d-b503-d7d343cfa608","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"41f00a4a-8ff0-4e69-925e-0ea89e7a6824","children":[],"html":"所有的应用代码必须放到同一个仓库。如果是旧有项目，并且每个应用使用一个 Git 仓库的情况，那么使用 Monorepo 之后项目架构调整会比较大，也就是说改造成本会相对比较高。","zIndex":354},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"90b241b1-0c5a-4d48-b14c-e8dd739cdc46","children":[],"html":"Monorepo 本身也存在一些天然的局限性，如项目数量多起来之后依赖安装时间会很久、项目整体构建时间会变长等等","zIndex":355},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e5e93630-e474-4597-b08b-07a83a12e599","children":[],"html":"项目构建问题。跟 发 npm 包的方案一样，所有的公共代码都需要进入项目的构建流程中，产物体积还是会偏大。","zIndex":356}],"html":"问题","zIndex":353}],"html":"4. Monorepo","zIndex":350}],"html":"解决方法","collapsed":true,"zIndex":333},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dd466e4d-8df8-4f98-9617-e6add5e2f613","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9e4aa926-ec02-4d74-86f2-b664326ed900","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c41c90e1-f912-421a-a18c-9959c352f7d0","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5a59d634-0c09-4f1e-9ed6-201a7edfa58b","children":[],"html":"本地模块","zIndex":360},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"03b1b5fe-ca18-405c-8cc9-d9bb52185150","children":[],"html":"远程模块","zIndex":361},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"af6e9290-03fa-404a-b424-bf75c881bb87","children":[],"html":"本地模块即为普通模块，是当前构建流程中的一部分，而远程模块不属于当前构建流程，在本地模块的运行时进行导入，同时本地模块和远程模块可以共享某些依赖的代码","zIndex":362},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e0fc0e37-affd-46c5-916e-555c1872c9e6","children":[],"html":"在模块联邦中，每个模块既可以是本地模块，导入其它的远程模块，又可以作为远程模块，被其他的模块导入","zIndex":363},{"start":0,"end":1,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\"><span style></span></div>","defaultContentStyle":{"color":"#262626"},"id":"7ce1466a-b1d0-4730-b1ff-8893c8b5b8dc","children":[],"height":158.1375087078727,"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1713862824180-4a89d407-b8d1-4b34-a386-3fa09a192de5.png","naturalWidth":1158,"naturalHeight":516,"uploadInfo":{"hash":"39d3cedf0689f9ddded9ee311b2b35f468e59f3e3cd931c6e3999499e46a473c","fileName":"yuque_diagram (8).png","fileType":"image/png","fileSize":114002,"localTempSrc":"blob:https://www.yuque.com/2a822c25-6448-426f-9649-698eaa42941e","state":-2},"width":233.26676240275128,"height":103.94270241780627},"width":249.26676240275128,"zIndex":364}],"html":"两种模块","zIndex":359},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d13ea098-570f-4f24-8da9-7669cb8200b5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"af1ffc80-d7f0-41b1-9d98-1092d5f6d685","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c50c67e7-3e62-43cb-8ef4-e2185a340562","children":[],"html":"这里所指的模块粒度可大可小，包括第三方 npm 依赖、业务组件、工具函数，甚至可以是整个前端应用！而整个前端应用能够共享产物，代表着各个应用单独开发、测试、部署，这也是一种微前端的实现。","zIndex":367}],"html":"实现任意粒度的模块共享","zIndex":366},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"86afa95b-254b-4e87-bf4d-94f0189d8fcb","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e094edda-b5af-4912-961e-d9c6fc5d1063","children":[],"html":"远程模块可以从本地模块运行时被拉取，而不用参与本地模块的构建，可以加速构建过程，同时也能减小构建产物。","zIndex":369}],"html":"优化构建产物体积","zIndex":368},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fb556dde-af8f-4415-82d0-115a18d98428","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"48ff4d6e-5c1b-40bb-bf4a-7e242a791352","children":[],"html":"远程模块导入的粒度可以很小，如果你只想使用 app1 模块的add函数，只需要在 app1 的构建配置中导出这个函数，然后在本地模块中按照诸如import('app1/add')的方式导入即可，这样就很好地实现了模块按需加载。","zIndex":371}],"html":"运行时按需加载","zIndex":370},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ecab8412-9203-4528-91d8-0fbbd5801cba","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3a91a7e7-7b3d-4e6c-b8ab-5aad17c40d05","children":[],"html":"通过模块联邦中的共享依赖机制，我们可以很方便地实现在模块间公用依赖代码，从而避免以往的external + CDN 引入方案的各种问题。","zIndex":373}],"html":"第三方依赖共享","zIndex":372},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"52bf9ad1-0f98-4ecf-af3e-226886c1ea83","children":[],"html":"模块联邦近乎完美地解决了以往模块共享的问题，甚至能够实现应用级别的共享，进而达到微前端的效果","zIndex":374}],"html":"优势","zIndex":365}],"html":"核心概念","zIndex":358},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"24b8b11b-4dc4-49c8-a554-caaf66ac0843","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ff70b760-f682-496d-ac03-65b574b1197d","children":[],"html":"社区中已经提供了一个比较成熟的 Vite 模块联邦方案: vite-plugin-federation，这个方案基于 Vite(或者 Rollup) 实现了完整的模块联邦能力。","zIndex":376},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d888fbc1-a833-4cc7-84fe-12f9f034d2e5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5728704c-b209-4f40-b7b9-a45a36012875","children":[],"html":"1. 远程模块通过exposes 注册导出的模块，本地模块通过 remotes 注册远程模块地址。","zIndex":378},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"40ac3234-f995-46a6-8c18-4ac469aae153","children":[],"html":"2. 远程模块进行构建，并部署到云端。","zIndex":379},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"53be0f35-da61-4aaa-b729-01d168ef7d7f","children":[],"html":"3. 本地通过import '远程模块名称/xxx'的方式来引入远程模块，实现运行时加载。","zIndex":380},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b3e8d304-365d-495c-94f0-5ae1cd7ddd3d","children":[],"html":"在模块联邦中的配置中，exposes 和remotes参数其实并不冲突，也就是说一个模块既可以作为本地模块，又可以作为远程模块。","zIndex":381}],"html":"使用流程","zIndex":377}],"html":"应用实战","zIndex":375},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0c87c85c-c38f-4507-aef3-3b0a046880dc","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ef235aed-cc4f-4b06-9a00-0f327528a337","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"66db8d63-ea33-4b82-9dbf-3fc88151a829","children":[],"html":"Host模块: 即本地模块，用来消费远程模块。","zIndex":384},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"aff870b7-26ce-4e5e-9101-a8a9e237bfe0","children":[],"html":"Remote模块: 即远程模块，用来生产一些模块，并暴露运行时容器供本地模块消费。","zIndex":385},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"15a7fec6-be05-4a92-8670-dc2294133dba","children":[],"html":"Shared依赖: 即共享依赖，用来在本地模块和远程模块中实现第三方依赖的共享。","zIndex":386}],"html":"三大要素","zIndex":383}],"html":"实现原理","zIndex":382}],"html":"模块联邦","collapsed":true,"zIndex":357}],"html":"模块联邦：如何实现跨应用代码共享","collapsed":true,"zIndex":4},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#e4f3e7"},"treeEdge":{"stroke-width":2,"stroke":"#77C386"},"defaultContentStyle":{"color":"#262626"},"id":"1627dfb7-e521-438b-aee4-b57e678959b1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"baa032e2-7408-4179-9851-2aaf99c0e553","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fa315fe8-0404-467f-a5a9-35d83fd05f01","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"98bec317-7306-4902-9bc7-ae170297d315","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"035890a4-eae6-42e1-89ed-10f62623f727","children":[],"html":"同一个 TCP 管道中同一时刻只能处理一个 HTTP 请求，也就是说如果当前请求没有处理完，其它的请求都处于阻塞状态","zIndex":390},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4ae07d89-c282-4550-a8af-7a79b51df053","children":[],"html":"浏览器对于同一域名下的并发请求数量都有限制，比如 Chrome 中只允许 6 个请求并发（这个数量不允许用户配置），也就是说请求数量超过 6 个时，多出来的请求只能排队、等待发送。","zIndex":391}],"html":"在 HTTP 1.1 协议中，队头阻塞和请求排队问题很容易成为网络层的性能瓶颈","zIndex":389},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"26afec7f-3bf4-45bf-bc7d-e8adbd267eb8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5e2dc7dc-1dc3-4357-b23b-77a207f3269e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"54688ae0-e024-4ecf-826f-fded1de5522b","children":[],"html":"将数据分为多个二进制帧，多个请求和响应的数据帧在同一个 TCP 通道进行传输，解决了之前的队头阻塞问题。而与此同时，在 HTTP2 协议下，浏览器不再有同域名的并发请求数量限制，因此请求排队问题也得到了解决","zIndex":394}],"html":"多路复用","zIndex":393},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d08ab7ea-6990-4ad3-8ef1-d9beef8d3bd4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"07025bd0-ca21-498c-a4cb-9c1f951123ac","children":[],"html":"即服务端推送能力。可以让某些资源能够提前到达浏览器，比如对于一个 html 的请求，通过 HTTP 2 我们可以同时将相应的 js 和 css 资源推送到浏览器，省去了后续请求的开销。","zIndex":396}],"html":"Server Push","zIndex":395}],"html":"HTTP2如何解决","zIndex":392}],"html":"HTTP2","zIndex":388},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"35bc9ffb-0716-4f21-8dfa-61f43da78344","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"318bd917-7859-4833-83ec-d2427e9158c6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ebd98ee5-0722-4159-a502-07c84d49a0e6","children":[],"html":"&lt;!-- href 为需要预解析的域名 --&gt;<div>&lt;link rel=\"dns-prefetch\" href=\"https://fonts.googleapis.com/\"&gt;&nbsp;</div>","zIndex":399}],"html":"浏览器在向跨域的服务器发送请求时，首先会进行 DNS 解析，将服务器域名解析为对应的 IP 地址。我们通过 dns-prefetch 技术将这一过程提前，降低 DNS 解析的延迟时间","zIndex":398},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a41d57ed-3388-4e64-97c6-8a4ae29e3e8a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1d492a76-280e-4af0-a217-1b9a498c14f7","children":[],"html":"&lt;link rel=\"preconnect\" href=\"https://fonts.gstatic.com/\" crossorigin&gt;<div>&lt;link rel=\"dns-prefetch\" href=\"https://fonts.gstatic.com/\"&gt;</div>","zIndex":401}],"html":"一般情况下 dns-prefetch会与preconnect 搭配使用，前者用来解析 DNS，而后者用来会建立与服务器的连接，建立 TCP 通道及进行 TLS 握手，进一步降低请求延迟。使用方式如下所示:","zIndex":400}],"html":"DNS预解析","zIndex":397},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"82bd6f6d-1ef9-4044-a03e-0a332a8658ac","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1a930651-8cb1-43d6-ab25-94f6e7c745c3","children":[],"html":"&lt;link rel=\"preload\" href=\"style.css\" as=\"style\"&gt;<div>&lt;link rel=\"preload\" href=\"main.js\" as=\"script\"&gt;</div>","zIndex":403},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"992c3432-7c78-40e5-a642-fb8affb86e5b","children":[],"html":"与普通 script 标签不同的是，对于原生 ESM 模块，浏览器提供了modulepreload来进行预加载:&lt;link rel=\"modulepreload\" href=\"/src/app.js\" /&gt;","zIndex":404},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8d1f78d8-7639-4146-90ba-ba5774ece1fc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"09277899-316a-44ca-bc17-95719b1d622f","children":[],"html":"&lt;link rel=\"prefetch\" href=\"https://B.com/index.js\" as=\"script\"&gt;","zIndex":406}],"html":"Prefetch 也是一个比较常用的优化方式，它相当于告诉浏览器空闲的时候去预加载其它页面的资源，比如对于 A 页面中插入了这样的 link 标签:","zIndex":405}],"html":"Preload/Prefetch","zIndex":402}],"html":"网络优化","zIndex":387},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"02678ef9-2776-444c-8766-92b1963bcb31","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"923a5f71-0248-48e2-bdf5-8be79c7cdc15","children":[],"html":"包括构建产物分析、资源压缩、产物拆包、按需加载等优化方式。","zIndex":408},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"80c4208c-d2e0-4675-a8a1-3476aa8c5df5","children":[],"html":"产物分析报告：rollup-plugin-visualizer","zIndex":409},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2bb7f64a-9d26-4f11-9f9e-3d918232a0de","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9d3db376-c0cb-4a7e-b1bb-f4362f14b05a","children":[],"html":"import loadable from \"@loadable/component\";<div>const Foo = loadable(() =&gt; import(\"./routes/Foo\"));</div>","zIndex":411}],"html":"按需加载：路由组件进行动态引入，比如在 React 应用中使用 @loadable/component 进行组件异步加载","zIndex":410}],"html":"资源优化","zIndex":407},{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6e7fe1d7-6814-4aa4-9813-7fe45224efee","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#e4f3e7","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"42725a37-5336-45a5-9a52-294a46c81c57","children":[],"html":"服务端渲染(SSR)和静态站点生成(SSG)","zIndex":413}],"html":"预渲染优化","zIndex":412}],"html":"Vite 项目性能优化","icons":{"flag":0},"layout":{"quadrant":1},"collapsed":true,"zIndex":2},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#e2e6f8"},"treeEdge":{"stroke-width":2,"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"a7404bf4-2334-4475-b2d1-9374a7761fe8","children":[],"html":"HMR原理","layout":{"quadrant":1},"zIndex":0}],"layout":{"type":"standard","direction":[1,0]},"zIndex":13}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[36.4052734375,8,1],"width":1601,"height":949},"viewportOption":"adapt","text":"Vite基础Vite 是什么前端构建工具，下一代前端工具链，为开发提供极速响应Vite 提供一个开发服务器和一套构建指令特点服务启动快：开发环境使用原生ESM文件，不需要打包热重载快对TS、JSX、CSS等支持开箱即用，内置HMR优化的构建为什么选择 Vite通过JS的原生机制，实现高效的模块化开发开发服务器启动慢问题：基于打包器的方式启动开发服务器，需要构建整个应用，才能启动服务。Vite 如何改进将模块分为依赖和源码两类依赖依赖一般是开发时不会变动的JS，如node_modules中的包使用esbuild与构建依赖。esbuild 使用 Go 编写，并且比以 JavaScript 编写的打包器预构建依赖快 10-100 倍。源码写在src下的代码，一般需要转换，如jsx，vue文件，经常被编辑，但是不需要全部同时被加载Vite 以原生ESM方式提供源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。更新慢问题：基于打包器启动时，重新构建整个包效率低，项目越大越慢Vite 如何改进在原生ESM上执行HMR当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失活同时利用 HTTP 头来加速整个页面的重新加载源码模块的请求会根据 304 Not Modified 进行协商缓存依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存为什么生产环境需要打包生产环境使用 rollup 打包由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下生产环境将需要代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）才能获得更好的性能为什么不用 esbuild 打包：esbuild在代码分割和css处理方面功能还未完善no-bundle 是什么利用浏览器原生 ES 模块的支持，实现开发阶段的 Dev Server，进行模块的按需加载，而不是先整体打包再进行加载。Vite Dev Server 做了什么读取到main.tsx内容，Vite对文件内容进行编译，例如：把ts编译成浏览器能识别的内容一个 import 语句即代表了一个 HTTP 请求。浏览器解析到import语句，VDS会发起请求，VDS读取本地文件，返回浏览器可以解析的代码，直到所有资源都加载完成。项目搭建从零搭建步骤CSS工程化方案CSS工程化解决了什么问题开发体验差，比如原生css不支持选择器嵌套样式污染浏览器兼容打包后代码体积大工程化方案CSS 预处理器Sass，less，stylus样式可以嵌套可以定义变量、写条件判断和循环，增强灵活性解决原生CSS的开发体验问题CSS Modules能将 CSS 类名处理成哈希值，这样就可以避免同名的情况下样式污染的问题。CSS后处理器PostCSS解析和处理CSS代码px转换为rem根据目标浏览器添加前缀 --moz--CSS in JS 方案包括emotion、styled-components等包含css预处理器和css modules的优点，使用灵活解决开发体验和全局样式污染问题CSS 原子化框架Tailwindcss、Windi CSS通过类名来制定样式，提高开发效率Vite 的样式方案配置内置CSS预处理器，零配置自动引入css变量文件// vite.config.tsimport { normalizePath } from 'vite';// 如果类型报错，需要安装 @types/node: pnpm i @types/node -Dimport path from 'path';// 全局 scss 文件的路径// 用 normalizePath 解决 window 下的路径问题const variablePath = normalizePath(path.resolve('./src/variable.scss'));export default defineConfig({  // css 相关的配置  css: {    preprocessorOptions: {      scss: {        // additionalData 的内容会在每个 scss 文件的开头自动注入        additionalData: `@import \"${variablePath}\";`      }    }  }})内置对.module样式文件的支持PostCSS可以通过 postcss.config.js 来配置 postcss ，不过在 Vite 配置文件中已经提供了 PostCSS 的配置入口pnpm i autoprefixer -D解决兼容，增加样式前缀// vite.config.ts 增加如下的配置import autoprefixer from 'autoprefixer';export default {  css: {    // 进行 PostCSS 配置    postcss: {      plugins: [        autoprefixer({          // 指定目标浏览器          overrideBrowserslist: ['Chrome > 40', 'ff > 31', 'ie 11']        })      ]    }  }}常用PostCSS插件postcss-pxtorem适配移动端时常用postcss-preset-env可以编写最新的css语法，处理兼容问题cssnano压缩css代码，可以提取公共样式进行复用，缩短常见的属性值等CSS in JS对于 CSS In JS 方案，在构建侧我们需要考虑选择器命名问题、DCE(Dead Code Elimination 即无用代码删除)、代码压缩、生成 SourceMap、服务端渲染(SSR)等问题styled-components和emotion已经提供了对应的 babel 插件来解决这些问题，我们在 Vite 中要做的就是集成这些 babel 插件// vite.config.tsimport { defineConfig } from 'vite'import react from '@vitejs/plugin-react'// https://vitejs.dev/config/export default defineConfig({  plugins: [    react({      babel: {        // 加入 babel 插件        // 以下插件包都需要提前安装        // 当然，通过这个配置你也可以添加其它的 Babel 插件        plugins: [          // 适配 styled-component          \"babel-plugin-styled-components\"          // 适配 emotion          \"@emotion/babel-plugin\"        ]      },      // 注意: 对于 emotion，需要单独加上这个配置      // 通过 `@emotion/react` 包编译 emotion 中的特殊 jsx 语法      jsxImportSource: \"@emotion/react\"    })  ]})CSS 原子化框架Tailwind CSS 在 v3 版本也引入 JIT(即时编译) 的功能，解决了开发环境下 CSS 产物体积庞大的问题pnpm install -D tailwindcss postcss autoprefixer新建两个配置文件tailwind.config.js和postcss.config.js// tailwind.config.jsmodule.exports = {  content: [    \"./index.html\",    \"./src/**/*.{vue,js,ts,jsx,tsx}\",  ],  theme: {    extend: {},  },  plugins: [],}// postcss.config.js// 从中你可以看到，Tailwind CSS 的编译能力是通过 PostCSS 插件实现的// 而 Vite 本身内置了 PostCSS，因此可以通过 PostCSS 配置接入 Tailwind CSS // 注意: Vite 配置文件中如果有 PostCSS 配置的情况下会覆盖掉 post.config.js 的内容!module.exports = {  plugins: {    tailwindcss: {},    autoprefixer: {},  },}在项目的入口 CSS 中引入必要的样板代码@tailwind base;@tailwind components;@tailwind utilities;使用<p className=\"bg-red-400\">Hello Vite + React!</p>代码规范：Lint工具链JS规范工具：ESlint初始化pnpm i eslint -Dnpx eslint --init接着 ESLint 会帮我们自动生成.eslintrc.js配置文件安装依赖pnpm i eslint-plugin-react@latest @typescript-eslint/eslint-plugin@latest @typescript-eslint/parser@latest -D核心配置parser - 解析器parserOptions - 解析器选项rules - 具体代码规则pluginsextends - 继承配置env 和 globals与 Prettier 强强联合在 Vite 中接入 ESLint样式规范工具Husky+lint-staged 的Git提交工作流集成静态资源处理图片加载配置别名alias 别名配置不仅在 JavaScript 的 import 语句中生效，在 CSS 代码的 @import 和 url导入语句中也同样生效// vite.config.tsimport path from 'path';{  resolve: {    // 别名配置    alias: {      '@assets': path.join(__dirname, 'src/assets')    }  }}使用import logoSrc from '@assets/imgs/vite.png';export function Header() {  return (    <img className=\"m-auto mb-4\" src={logoSrc} alt=\"\" />  );}SVG 组件方式加载将svg当做一个组件来引入Vue3 项目中可以引入 vite-svg-loaderReact 项目使用 vite-plugin-svgr插件// vite.config.tsimport svgr from 'vite-plugin-svgr';{  plugins: [    svgr()  ]}要在 tsconfig.json 添加如下配置，否则会有类型错误{  \"compilerOptions\": {    // 省略其它配置    \"types\": [\"vite-plugin-svgr/client\"]  }}使用 svg 组件import { ReactComponent as ReactLogo } from '@assets/icons/logo.svg';export function Header() {  return (     <ReactLogo />  )}JSON加载Vite 中已经内置了对于 JSON 文件的解析，底层使用@rollup/pluginutils 的 dataToEsm 方法将 JSON 对象转换为一个包含各种具名导出的 ES 模块import { version } from '../../../package.json'Web Worker脚本引入的时候注意加上?worker后缀，相当于告诉 Vite 这是一个 Web Worker 脚本文件特殊资源后缀?url: 表示获取资源的路径，这在只想获取文件路径而不是内容的场景将会很有用?raw: 表示获取资源的字符串内容，如果你只想拿到资源的原始内容，可以使用这个后缀。?inline: 表示资源强制内联，而不是打包成单独的文件。生产环境处理自定义部署域名// vite.config.ts{  base: isProduction ? CDN_URL: '/'}只有图片资源使用CDN域名在项目根目录新增.env文件VITE_IMG_BASE_URL=https://my-image-cdn.com进入 src/vite-env.d.ts增加类型声明/// <reference types=\"vite/client\" />interface ImportMetaEnv {  readonly VITE_APP_TITLE: string;  // 自定义的环境变量  readonly VITE_IMG_BASE_URL: string;}interface ImportMeta {  readonly env: ImportMetaEnv;}使用<img src={new URL('./logo.png', import.meta.env.VITE_IMG_BASE_URL).href} />单文件 or 内联小的资源，内联到代码中，减少不必要的网络请求，优化网络性能Vite内置方案如果静态资源体积 >= 4KB，则提取成单独的文件如果静态资源体积 < 4KB，则作为 base64 格式的字符串内联// vite.config.ts{  build: {    // 8 KB    assetsInlineLimit: 8 * 1024  }}图片压缩pnpm i vite-plugin-imagemin -D//vite.config.tsimport viteImagemin from 'vite-plugin-imagemin';{  plugins: [    // 忽略前面的插件    viteImagemin({      // 无损压缩配置，无损压缩下图片质量不会变差      optipng: {        optimizationLevel: 7      },      // 有损压缩配置，有损压缩下图片质量可能会变差      pngquant: {        quality: [0.8, 0.9],      },      // svg 优化      svgo: {        plugins: [          {            name: 'removeViewBox'          },          {            name: 'removeEmptyAttrs',            active: false          }        ]      }    })  ]}雪碧图优化Vite 批量导入语法糖按需加载：const icons = import.meta.glob('../../assets/icons/logo-*.svg');同步导入：const icons =  import.meta.glob('*', { eager: true }) 雪碧图pnpm i vite-plugin-svg-icons -D// vite.config.tsimport { createSvgIconsPlugin } from 'vite-plugin-svg-icons';{  plugins: [    // 省略其它插件    createSvgIconsPlugin({      iconDirs: [path.join(__dirname, 'src/assets/icons')]    })  ]}预构建为什么需要预构建对第三方依赖进行预构建1. 将其他格式(如 UMD 和 CommonJS)的产物转换为 ESM 格式，使其在浏览器通过 <script type=\"module\"><script>的方式正常加载2. 打包第三方库的代码，将各个第三方库分散的文件合并到一起，减少 HTTP 请求数量，避免页面加载性能劣化。而这两件事情全部由性能优异的 Esbuild (基于 Golang 开发)完成，而不是传统的 Webpack/Rollup，所以也不会有明显的打包性能问题，反而是 Vite 项目启动飞快(秒级启动)的一个核心原因。如何开启预构建自动开启手动开启自定义配置详解问题：第三方库出现问题怎么办双引擎架构性能利器：ESbuild依赖预构建对于第三方依赖，需要在应用启动前进行打包并且转换为 ESM 格式esbuild缺点不支持降级到 ES5 的代码。这意味着在低端浏览器代码会跑不起来不支持 const enum 等语法。这意味着单独使用这些语法在 esbuild 中会直接抛错不提供操作打包产物的接口，像 Rollup 中灵活处理打包产物的能力(如renderChunk钩子)在 Esbuild 当中完全没有。不支持自定义 Code Splitting 策略。传统的 Webpack 和 Rollup 都提供了自定义拆包策略的 API，而 Esbuild 并未提供，从而降级了拆包优化的灵活性。单文件编译：作为TS和JSX的编译工具在 TS(X)/JS(X) 单文件编译上面，Vite 也使用 Esbuild 进行语法转译，也就是将 Esbuild 作为 Transformer 来用。Esbuild 转译 TS 或者 JSX 的能力通过 Vite 插件提供，这个 Vite 插件在开发环境和生产环境都会执行Vite 已经将 Esbuild 的 Transformer 能力用到了生产环境。尽管如此，对于低端浏览器场景，Vite 仍然可以做到语法和 Polyfill 安全这部分能力用来替换原先 Babel 或者 TSC 的功能，因为无论是 Babel 还是 TSC都有性能问题，大家对这两个工具普遍的认知都是: 慢，太慢了。缺点TS 中的类型检查问题。这是因为 Esbuild 并没有实现 TS 的类型系统，在编译 TS(或者 TSX) 文件时仅仅抹掉了类型相关的代码，暂时没有能力实现类型检查vite build之前会先执行tsc命令，也就是借助 TS 官方的编译器进行类型检查要解决类型问题，最好使用 TS 的编辑器插件。在开发阶段就能早早把问题暴露出来并解决代码压缩Vite 从 2.6 版本开始，默认使用 Esbuild 来进行生产环境的代码压缩，包括 JS 代码和 CSS 代码。Esbuild 可以共享 AST 以及原生语言编写的 Minifier 在性能上能够甩开传统工具的好几十倍。压缩一个大小为3.2 MB的库，Terser 需要耗费8798 ms，而 Esbuild 仅仅需要361 ms，压缩效率较 Terser 提升了二三十倍传统的方式都是使用 Terser 这种 JS 开发的压缩器来实现，在 Webpack 或者 Rollup 中作为一个 Plugin 来完成代码打包后的压缩混淆的工作。但 Terser 其实很慢，主要有 2 个原因。压缩这项工作涉及大量 AST 操作，并且在传统的构建流程中，AST 在各个工具之间无法共享，比如 Terser 就无法与 Babel 共享同一个 AST，造成了很多重复解析的过程JS 本身属于解释性 + JIT（即时编译） 的语言，对于压缩这种 CPU 密集型的工作，其性能远远比不上 Golang 这种原生语言将 Go 语言（也称为 Golang）描述为“原生语言”通常是指它的编译器和运行时系统都是直接编译到本地机器代码的，而不是依赖于虚拟机或解释器。这意味着 Go 代码在编译时会被转换成机器代码，然后直接在目标系统上运行，而无需额外的运行时环境。构建基石：Rollup生成环境bundle优化CSS 代码分割。如果某个异步模块中引入了一些 CSS 代码，Vite 就会自动将这些 CSS 抽取出来生成单独的文件，提高线上产物的缓存复用率自动预加载。Vite 会自动为入口 chunk 的依赖自动生成预加载标签<link rel=\"modulepreload\">异步 Chunk 加载优化。兼容插件机制在开发阶段，自己实现了一个 Plugin Container，用来模拟 Rollup 调度各个 Vite 插件的执行逻辑，而 Vite 的插件写法完全兼容 Rollup，因此在生产环境中将所有的 Vite 插件传入 Rollup 也没有问题Esbuild 功能使用和插件开发ESbuild是基于Golang开发的一款打包工具为什么ESbuild性能高1. 使用golong开发构建逻辑代码直接被编译为原生机器码，而不用像 JS 一样先代码解析为字节码，然后转换为机器码，大大节省了程序运行时间2. 多核并行内部打包算法充分利用多核 CPU 优势，所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势3. 从零造轮子几乎没有使用任何第三方库，所有逻辑自己编写，大到 AST 解析，小到字符串的操作，保证极致的代码性能4. 高效的内存利用Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据（如 string -> TS -> JS -> string)，造成内存的大量浪费安装pnpm i esbuild@0.14.18API项目打包Build APIbuildbuildSyncserve单文件转译Transform APItransformSynctransformESbuild插件开发Vite 构建基石：RollupRollup打包基本概念及使用常规配置多产物配置多入口配置自定义output配置output: {  // 产物输出目录  dir: path.resolve(__dirname, 'dist'),  // 以下三个配置项都可以使用这些占位符:  // 1. [name]: 去除文件后缀后的文件名  // 2. [hash]: 根据文件名和文件内容生成的 hash 值  // 3. [format]: 产物模块格式，如 es、cjs  // 4. [extname]: 产物后缀名(带`.`)  // 入口模块的输出文件名  entryFileNames: `[name].js`,  // 非入口模块(如动态 import)的输出文件名  chunkFileNames: 'chunk-[hash].js',  // 静态资源文件输出文件名  assetFileNames: 'assets/[name]-[hash][extname]',  // 产物输出格式，包括`amd`、`cjs`、`es`、`iife`、`umd`、`system`  format: 'cjs',  // 是否生成 sourcemap 文件  sourcemap: true,  // 如果是打包出 iife/umd 格式，需要对外暴露出一个全局变量，通过 name 配置变量名  name: 'MyBundle',  // 全局变量声明  globals: {    // 项目中可以直接用`$`代替`jquery`    jquery: '$'  }}依赖external不想通过rollup打包的第三方包external: ['react', 'react-dom']接入插件能力@rollup/plugin-node-resolve为了允许我们加载第三方依赖，否则像import React from 'react' 的依赖导入语句将不会被 Rollup 识别@rollup/plugin-commonjs作用是将 CommonJS 格式的代码转换为 ESM 格式@rollup/plugin-json： 支持.json的加载，并配合rollup的Tree Shaking机制去掉未使用的部分，进行按需打包。@rollup/plugin-babel：在 Rollup 中使用 Babel 进行 JS 代码的语法转译。@rollup/plugin-typescript: 支持使用 TypeScript 开发。@rollup/plugin-alias：支持别名配置。@rollup/plugin-replace：在 Rollup 进行变量字符串的替换。rollup-plugin-visualizer: 对 Rollup 打包产物进行分析，自动生成产物体积可视化分析图。JS API 方式调用如果需要定制rollup的打包过程，需要用到JavaScript API的方式来打包APIrollup.rolluprollup.watch使用方法新建build.js通过 rollup.rollup方法，传入 inputOptions，生成 bundle 对象调用 bundle 对象的 generate 和 write 方法，传入outputOptions，分别完成产物和生成和磁盘写入。调用 bundle 对象的 close 方法来结束打包。node build.jsRollup插件机制构建过程Rollup 会先进入到 Build 阶段，解析各模块的内容及依赖关系然后进入Output阶段，完成打包及输出的过程如何开发Vite插件示例// myPlugin.jsexport function myVitePlugin(options) {  console.log(options)  return {    name: 'vite-plugin-xxx',    load(id) {      // 在钩子逻辑中可以通过闭包访问外部的 options 传参    }  }}// 使用方式// vite.config.tsimport { myVitePlugin } from './myVitePlugin';export default {  plugins: [myVitePlugin({ /* 给插件传参 */ })]}插件 Hook 代码分割拆包解决了什么问题1. 页面打开只加载必要内容，提升页面性能2. 提升缓存命中率，实现文件的缓存复用，降低页面加载的网络开销Vite 默认拆包策略优点实现了 CSS 代码分割与业务代码、第三方库代码、动态 import 模块代码三者的分离缺点第三方库的打包产物容易变得比较臃肿，需要通过manualChunks自定义拆包自定义拆包策略// vite.config.ts{  build: {    rollupOptions: {      output: {        // manualChunks 配置        manualChunks: {          // 将 React 相关库打包成单独的 chunk 中          'react-vendor': ['react', 'react-dom'],          // 将 Lodash 库的代码单独打包          'lodash': ['lodash-es'],          // 将组件库的代码打包          'library': ['antd', '@arco-design/web-react'],        },      },    }  },}语法降级与Polyfill问题：低版本浏览器，需要兼容到IE 11、iOS 9以及Android 4.4的场景中遇到Promise 或者ES新版本对象数组方法，会发生报错，页面白屏的现象。这是语法降级和Polyfill缺失的问题语法兼容问题解决编译时工具。代表工具有@babel/preset-env和@babel/plugin-transform-runtime作用是在代码编译阶段进行语法降级及添加 polyfill 代码的引用语句，如:import \"core-js/modules/es6.set.js\"运行时基础库。代表库包括core-js和regenerator-runtime运行时基础库是根据 ESMAScript官方语言规范提供各种Polyfill实现代码Vite 的解决方案Vite 官方已经为我们封装好了一个开箱即用的方案: @vitejs/plugin-legacy，我们可以基于它来解决项目语法的浏览器兼容问题这个插件内部同样使用 @babel/preset-env 以及 core-js等一系列基础库来进行语法降级和 Polyfill 注入预渲染与SSRCSR 客户端渲染有什么问题首屏加载速度慢，页面渲染依赖JS的下载和执行对SEO不友好SSR 是什么服务端生成好完整的 HTML 内容，直接返回给浏览器，浏览器能够根据 HTML 渲染出完整的首屏内容，而不需要依赖 JS 的加载降低首屏渲染时间利于SEOSSR 中只能生成页面的内容和结构，并不能完成事件绑定，因此需要在浏览器中执行 CSR 的 JS 脚本，完成事件绑定，让页面拥有交互的能力，这个过程被称作hydrate(翻译为注水或者激活)。同时，像这样服务端渲染 + 客户端 hydrate 的应用也被称为同构应用SSR 生命周期服务端(Nodejs)如何提前渲染html内容构建时：保证前端代码编译后在服务端可以正常执行运行时：服务端需要渲染前端组件，生成并组装应用的HTML构建时1. 解决模块加载问题在原有的构建过程之外，需要加入SSR 构建的过程 ，具体来说，我们需要另外生成一份 CommonJS 格式的产物，使之能在 Node.js 正常加载。当然，随着 Node.js 本身对 ESM 的支持越来越成熟，我们也可以复用前端 ESM 格式的代码2. 移除样式代码的引入直接引入一行 css 在服务端其实是无法执行的，因为 Node.js 并不能解析 CSS 的内容。但 CSS Modules 的情况除外，如下所示:import styles from './index.module.css'// 这里的 styles 是一个对象，如{ \"container\": \"xxx\" }，而不是 CSS 代码console.log(styles)3. 依赖外部化(external)对于某些第三方依赖我们并不需要使用构建后的版本，而是直接从 node_modules 中读取，比如 react-dom，这样在 SSR 构建的过程中将不会构建这些依赖，从而极大程度上加速 SSR 的构建。运行时1. 加载 SSR 入口模块在这个阶段，我们需要确定 SSR 构建产物的入口，即组件的入口在哪里，并加载对应的模块。2. 进行数据预取这时候 Node 侧会通过查询数据库或者网络请求来获取应用所需的数据。3. 渲染组件这个阶段为 SSR 的核心，主要将第 1 步中加载的组件渲染成 HTML 字符串或者 Stream 流。4. HTML拼接在组件渲染完成之后，我们需要拼接完整的 HTML 字符串，并将其作为响应返回给浏览器。通过 react-dom/server 的 renderToString 方法实现基于Vite 搭建SSR项目模块联邦：如何实现跨应用代码共享场景公共组件、公共工具函数、公共第三方依赖等如何更好的复用解决方法1. 发布 npm 包可以解决复用问题，但是存在新的问题每次改动需要发版，所有相关的应用需要安装新的依赖，流程复杂引入了公共库之后，公共库的代码都需要打包到项目最后的产物后，导致产物体积偏大，构建速度相对较慢。2. Git Submodule通过 git submodule 的方式，我们可以将代码封装成一个公共的 Git 仓库，然后复用到不同的应用中，但也需要经历如下的步骤1. 公共库 lib1 改动，提交到 Git 远程仓库；2. 所有的应用通过git submodule命令更新子仓库代码，并进行联调。和npm方式差别不大3. 依赖外部化 + CDN兼容性问题并不是所有的依赖都有 UMD 格式的产物，因此这种方案不能覆盖所有的第三方 npm 包。依赖顺序问题我们通常需要考虑间接依赖的问题，如对于 antd 组件库，它本身也依赖了 react 和 moment，那么react和moment 也需要 external，并且在 HTML 中引用这些包，同时也要严格保证引用的顺序，比如说moment如果放在了antd后面，代码可能无法运行。而第三方包背后的间接依赖数量一般很庞大，如果逐个处理，对于开发者来说简直就是噩梦。产物体积问题由于依赖包被声明external之后，应用在引用其 CDN 地址时，会全量引用依赖的代码，这种情况下就没有办法通过 Tree Shaking 来去除无用代码了，会导致应用的性能有所下降。4. Monorepo作为一种新的项目管理方式，Monorepo 也可以很好地解决模块复用的问题。在 Monorepo 架构下，多个项目可以放在同一个 Git 仓库中，各个互相依赖的子项目通过软链的方式进行调试，代码复用显得非常方便，如果有依赖的代码变动，那么用到这个依赖的项目当中会立马感知到。问题所有的应用代码必须放到同一个仓库。如果是旧有项目，并且每个应用使用一个 Git 仓库的情况，那么使用 Monorepo 之后项目架构调整会比较大，也就是说改造成本会相对比较高。Monorepo 本身也存在一些天然的局限性，如项目数量多起来之后依赖安装时间会很久、项目整体构建时间会变长等等项目构建问题。跟 发 npm 包的方案一样，所有的公共代码都需要进入项目的构建流程中，产物体积还是会偏大。模块联邦核心概念两种模块本地模块远程模块本地模块即为普通模块，是当前构建流程中的一部分，而远程模块不属于当前构建流程，在本地模块的运行时进行导入，同时本地模块和远程模块可以共享某些依赖的代码在模块联邦中，每个模块既可以是本地模块，导入其它的远程模块，又可以作为远程模块，被其他的模块导入优势实现任意粒度的模块共享这里所指的模块粒度可大可小，包括第三方 npm 依赖、业务组件、工具函数，甚至可以是整个前端应用！而整个前端应用能够共享产物，代表着各个应用单独开发、测试、部署，这也是一种微前端的实现。优化构建产物体积远程模块可以从本地模块运行时被拉取，而不用参与本地模块的构建，可以加速构建过程，同时也能减小构建产物。运行时按需加载远程模块导入的粒度可以很小，如果你只想使用 app1 模块的add函数，只需要在 app1 的构建配置中导出这个函数，然后在本地模块中按照诸如import('app1/add')的方式导入即可，这样就很好地实现了模块按需加载。第三方依赖共享通过模块联邦中的共享依赖机制，我们可以很方便地实现在模块间公用依赖代码，从而避免以往的external + CDN 引入方案的各种问题。模块联邦近乎完美地解决了以往模块共享的问题，甚至能够实现应用级别的共享，进而达到微前端的效果应用实战社区中已经提供了一个比较成熟的 Vite 模块联邦方案: vite-plugin-federation，这个方案基于 Vite(或者 Rollup) 实现了完整的模块联邦能力。使用流程1. 远程模块通过exposes 注册导出的模块，本地模块通过 remotes 注册远程模块地址。2. 远程模块进行构建，并部署到云端。3. 本地通过import '远程模块名称/xxx'的方式来引入远程模块，实现运行时加载。在模块联邦中的配置中，exposes 和remotes参数其实并不冲突，也就是说一个模块既可以作为本地模块，又可以作为远程模块。实现原理三大要素Host模块: 即本地模块，用来消费远程模块。Remote模块: 即远程模块，用来生产一些模块，并暴露运行时容器供本地模块消费。Shared依赖: 即共享依赖，用来在本地模块和远程模块中实现第三方依赖的共享。Vite 项目性能优化网络优化HTTP2在 HTTP 1.1 协议中，队头阻塞和请求排队问题很容易成为网络层的性能瓶颈同一个 TCP 管道中同一时刻只能处理一个 HTTP 请求，也就是说如果当前请求没有处理完，其它的请求都处于阻塞状态浏览器对于同一域名下的并发请求数量都有限制，比如 Chrome 中只允许 6 个请求并发（这个数量不允许用户配置），也就是说请求数量超过 6 个时，多出来的请求只能排队、等待发送。HTTP2如何解决多路复用将数据分为多个二进制帧，多个请求和响应的数据帧在同一个 TCP 通道进行传输，解决了之前的队头阻塞问题。而与此同时，在 HTTP2 协议下，浏览器不再有同域名的并发请求数量限制，因此请求排队问题也得到了解决Server Push即服务端推送能力。可以让某些资源能够提前到达浏览器，比如对于一个 html 的请求，通过 HTTP 2 我们可以同时将相应的 js 和 css 资源推送到浏览器，省去了后续请求的开销。DNS预解析浏览器在向跨域的服务器发送请求时，首先会进行 DNS 解析，将服务器域名解析为对应的 IP 地址。我们通过 dns-prefetch 技术将这一过程提前，降低 DNS 解析的延迟时间<!-- href 为需要预解析的域名 --><link rel=\"dns-prefetch\" href=\"https://fonts.googleapis.com/\"> 一般情况下 dns-prefetch会与preconnect 搭配使用，前者用来解析 DNS，而后者用来会建立与服务器的连接，建立 TCP 通道及进行 TLS 握手，进一步降低请求延迟。使用方式如下所示:<link rel=\"preconnect\" href=\"https://fonts.gstatic.com/\" crossorigin><link rel=\"dns-prefetch\" href=\"https://fonts.gstatic.com/\">Preload/Prefetch<link rel=\"preload\" href=\"style.css\" as=\"style\"><link rel=\"preload\" href=\"main.js\" as=\"script\">与普通 script 标签不同的是，对于原生 ESM 模块，浏览器提供了modulepreload来进行预加载:<link rel=\"modulepreload\" href=\"/src/app.js\" />Prefetch 也是一个比较常用的优化方式，它相当于告诉浏览器空闲的时候去预加载其它页面的资源，比如对于 A 页面中插入了这样的 link 标签:<link rel=\"prefetch\" href=\"https://B.com/index.js\" as=\"script\">资源优化包括构建产物分析、资源压缩、产物拆包、按需加载等优化方式。产物分析报告：rollup-plugin-visualizer按需加载：路由组件进行动态引入，比如在 React 应用中使用 @loadable/component 进行组件异步加载import loadable from \"@loadable/component\";const Foo = loadable(() => import(\"./routes/Foo\"));预渲染优化服务端渲染(SSR)和静态站点生成(SSG)HMR原理","graphicsBBox":{"x":495.3662414550781,"y":83,"width":410.0780944824219,"height":769}}