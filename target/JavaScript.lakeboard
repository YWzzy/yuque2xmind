{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"id":"9b13689e-96fe-4441-bf75-6e4fe3947be5","x":896.3662298828126,"y":1010.25,"html":"JavaScript","type":"mindmap","defaultContentStyle":{"color":"rgb(38, 38, 38)"},"border":{"fill":"#F5F5F5","shape":"rect","stroke":"transparent","stroke-width":2},"children":[{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#FCF6E1","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"id":"ce8a41cb-95e5-47ff-a289-fd07c07fcad9","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4d4c6183-b8e8-4ee4-b575-e6dc5e5901c2","children":[],"html":"JS事件循环是JS执行机制，负责管理事件队列和调用栈","zIndex":2},{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8a5b10be-071e-4580-a03c-940c87abf5e1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2b7faedd-47f9-4e0f-9c9e-b2249c351c1b","children":[],"html":"1. JS代码在执行过程中，会创建对应的执行上下文栈并压入执行栈中","zIndex":9},{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5db80ace-2317-4d53-bd6d-4370c222d166","children":[],"html":"2. 如果遇到异步任务就暂时挂起，交给其他线程去处理异步任务，当异步任务处理完成之后，会将回调结果加入到事件队列中","zIndex":12},{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fc47214c-8b59-4d7e-b5d3-0b34f4782a9b","children":[],"html":"3. 当执行栈中所有任务执行完毕后，就是主线程处于闲置状态时，才会从事件队列中取出排在首位的事件回调结果，并把回调加入执行栈中执行其中的代码。如此往复，这个过程就是事件循环。","zIndex":10},{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0e1a4d9b-aadc-41ec-9bc8-81751b726dbd","children":[],"html":"4. 事件队列分为宏任务队列和微任务队列。当执行栈为空时，会先查看微任务队列，如果存在事件则依次执行微任务队列中的事件回调，直到微任务队列为空；不存在再去宏任务队列中处理","zIndex":8},{"start":0,"end":3,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\"><span style></span></div>","defaultContentStyle":{"color":"#262626"},"id":"db5e555c-5437-434d-9780-47dd565bb298","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1715307082139-1e5428f0-682d-4e16-b98e-be83f8029298.png","naturalWidth":615,"naturalHeight":168,"uploadInfo":{"hash":"18ef1f22056e5c2f0dbf949b682b9c63f82cc4710ab5fe2cede8a060271844f7","fileName":"image.png","fileType":"image/png","fileSize":48567,"localTempSrc":"blob:https://www.yuque.com/3756e78a-4a90-474f-81c9-6bb06d6a7cfb","state":-2},"firstInsertRatio":0.5,"width":307.5,"height":84},"zIndex":11}],"html":"执行过程","zIndex":13},{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b4c547a4-2c09-4838-be7e-fff81daad75a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8c60603b-5b8d-4a89-b6e4-57954da77a03","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"aa553ab0-b841-420e-b394-a6e8025ce100","children":[],"html":"script脚本执行，setTimeout，setInterval，setImmediate，I/O，用户交互操作、UI渲染","zIndex":5}],"html":"宏任务队列","zIndex":6},{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6ebd9cba-3f24-4316-b991-c70ae8080f78","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"18f4a06d-5cbc-434e-9828-b22b27081bd7","children":[],"html":"promise.then、promise.catch、new MutatiobObserver、process.nextTick","zIndex":3}],"html":"微任务队列","zIndex":4}],"html":"事件队列","zIndex":7},{"border":{"shape":"rect","stroke":"transparent","fill":"#FCF6E1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d9787ba1-32fd-4dec-91fa-41443c361553","children":[],"html":"Node.js事件循环","zIndex":1}],"html":"事件循环","icons":{"flag":2},"zIndex":14},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E9F7E9","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#77C386"},"id":"dc3eef15-a579-4da6-862a-b930f0bc5e5d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f1819224-aa07-49de-a3f9-4889b52ab41d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b3100b63-1f3d-4c65-84d0-eb7486e0f3c8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3f0cb0ce-1c0c-4438-a0a3-01026ac963a8","children":[],"html":"1. 即使创建它的上下文被销毁了，它依然存在。（比如从父函数中返回）","zIndex":25},{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"91cb8f59-a858-4beb-85cd-96046b76f70c","children":[],"html":"2. 在代码中引用了自由变量（在函数中使用的既不是函数参数也不是函数局部变量的变量称作自由变量）","zIndex":26}],"html":"闭包是指引用了其他函数作用域中变量的函数，通常是在嵌套函数中实现的。满足这两个条件的函数就是闭包：","zIndex":24}],"html":"概念","zIndex":23},{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"eaaec033-816f-4e94-a389-dcdb722e5a03","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7a4b37d1-aca5-463a-8d73-c9d38ee008ee","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f69005c3-8fb9-4333-98da-9464afcfd456","children":[],"html":"<span style=\"font-weight:bold;\">模块化</span>开发：CommonJS、ESModule 都有使用闭包","layout":{"quadrant":1},"zIndex":29},{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0ba679b9-1395-4098-8349-a486477eb034","children":[],"html":"vue 中的data函数","layout":{"quadrant":1},"zIndex":30}],"html":"保护：闭包执行时形成一个私有作用域","layout":{"quadrant":1},"zIndex":28},{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"50b777c3-0914-4120-b996-34bc0d7223a2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cf557573-4a24-47ac-925a-fab323cfd103","children":[],"html":"一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的。","zIndex":32}],"html":"保存：延长变量的生命周期。","zIndex":31}],"html":"优点","zIndex":27},{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c822d3c9-1d49-47bb-8df7-2b0f241b1acc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0e35d8e0-9c7b-4142-83b7-2c4b71d633c0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4d9cb333-b5dd-4eaa-bfa9-2df2dcbe0688","children":[],"html":"应该对使用完的变量及时置为null，例如dom的引用，定时器的清理","zIndex":35},{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1d6db5e7-d441-4b70-8a9f-4185340ad94e","children":[],"html":"<span style=\"font-weight:bold;\">垃圾回收机制</span>","zIndex":36}],"html":"一个函数返回另一个函数被外部接收，没有被垃圾回收机制回收掉，造成内存泄漏","zIndex":34}],"html":"缺点","zIndex":33},{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9b989b82-38bf-4774-a6b6-c8f510e201c3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"475536f0-ba35-4162-99b7-8483a0202a68","children":[],"html":"<span style=\"font-weight:bold;\">react hooks</span>","zIndex":38},{"border":{"shape":"rect","stroke":"transparent","fill":"#E9F7E9","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"caca635c-c219-4e33-adf0-6c7e017a2174","children":[],"zIndex":39,"html":"<span style=\"font-weight:bold;\">防抖节流函数</span>"}],"html":"应用","zIndex":37}],"html":"闭包","icons":{"flag":3},"collapsed":true,"zIndex":21},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#c9e7cf"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"b0b3a14d-580a-4907-81e7-4074a6d7af4e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"38f3488b-5951-43ea-8415-516dd6b5309c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e519ddbf-fddc-46f8-bdf9-1f411b26e6f7","children":[],"html":"定时器没有被清除","zIndex":41},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"817cf08d-6e3d-421c-a855-1a55ea327347","children":[],"html":"获取DOM元素的引用，元素被删除，但是引用还保留","zIndex":42},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7b74bb3c-007f-4fcf-94f8-c7c385608910","children":[],"html":"不合理使用闭包，导致变量一直被留在内存中","zIndex":43}],"html":"造成内存泄漏的操作","zIndex":40},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"156c2a56-955d-4276-9728-af648e690287","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c2d42f3b-7312-4d6a-a781-3199322d6914","children":[],"html":"可以使用 Chrome DevTools 来识别内存图和一些内存泄漏，主要关注两个方面：1. 使用性能分析器可视化内存消耗；2. 识别分离的 DOM 节点","zIndex":45},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"33880260-c709-4b1f-a1be-3436e0140049","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"178f8678-7b9e-4137-b111-f4aa36107c91","children":[],"html":"在chrome的performance面板，如果对页面做某些操作时，看到JavaScript Heap出现蓝色的峰值，并逐渐增加，说明存在内存泄漏的问题","zIndex":47}],"html":"使用性能分析器可视化内存消耗","zIndex":46},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"123c3795-f903-4238-932f-12de40ea9edb","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5c33ac36-b442-4b2c-959d-df39716504f6","children":[],"html":"当一个节点从 DOM 树中移除时，它被称为分离，但一些 JavaScript 代码仍然在引用它。","zIndex":49},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0ccdca45-bf30-4866-a667-8c3a53b59d3b","children":[],"html":"我们可以使用 heap snapshot 来检查分离的DOM节点，可以在Chrome DevTools 的Memory面板中打开Heap snapshots选项","zIndex":50},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"396a1b4f-5b12-4274-b3ff-a2c03fecdda2","children":[],"html":"点击Take snapshot按钮，我们可以在中间的搜索栏目输入Detached来过滤结果以找到分离的DOM节点","zIndex":51}],"html":"识别分离的 DOM 节点","zIndex":48}],"html":"如何检查内存泄漏","layout":{"quadrant":1},"zIndex":44},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"34cc818b-30ca-43aa-ba7a-f09ed1031969","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e8ee19a0-0eab-4643-a1a7-ca52d1e21a49","children":[],"html":"堆内存","zIndex":53},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9faa2199-b0e2-410a-934b-0f4c7d08cc88","children":[],"html":"引用计数和标记清除","zIndex":54}],"html":"在V8中，垃圾回收是一个用于自动管理内存，防止内存泄漏的机制。<div>内存管理基础：</div>","zIndex":52},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a557fa9a-4967-40b9-bc4c-795850e094db","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9f30a2a2-8585-403d-aedb-9393d5cfe5f0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"36b9bf02-2c24-40e3-96e3-cfef6d73c191","children":[],"html":"根据对象的存活时间，将内存的垃圾回收进行不同的分代，采用不同的回收算法","zIndex":57}],"html":"分代收集","layout":{"quadrant":1},"zIndex":56},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8a1efcf3-84a4-4989-acc7-b64aeb5aff9f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"12583c37-dea1-479a-91ab-970d02760d7e","children":[],"html":"采用空间换时间的scavenge算法：整个空间分为两块，变量仅存在其中一块，回收的时候将存活变量复制到另一块空间，不存活的回收掉，周而复始轮流操作","zIndex":59}],"html":"新生代垃圾回收","zIndex":58},{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"97afc8bd-3402-43f0-a7fb-b77f7fd520d4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#c9e7cf","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2ca99a67-fda8-4248-ada1-45aa679c0e58","children":[],"html":"采用标记整理和标记清除。标记清除：遍历所有对象标记可以访问到的存活对象，然后将不存活的进行垃圾回收。回收完后避免内存的断层不连续，需要通过标记整理将存活的对象往内存一端进行移动，移动完成后再清理边界内存","zIndex":61}],"html":"老生代垃圾回收","zIndex":60}],"html":"V8的垃圾回收机制","zIndex":55}],"html":"垃圾回收","icons":{"flag":0},"layout":{"quadrant":1},"collapsed":true,"zIndex":20},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#E8EEFC","stroke":"transparent"},"id":"aaf2e4ef-02c8-49d8-9aad-17d5af1f7bf2","children":[],"html":"异步","treeEdge":{"stroke":"#6F81DB","stroke-width":2},"icons":{"flag":4},"zIndex":19},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#f4cece"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"f65051c1-e3d1-4ba4-8437-8363152ff4c2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"11a8aa04-39fc-4a4a-8710-312e92d3d88a","children":[],"html":"模块概述","zIndex":62},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ac89cc69-cd4c-40d2-80ae-4abeac184f06","children":[],"html":"IIFE","zIndex":63},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6df2091f-cbf4-46a7-95c5-359362a142f3","children":[],"html":"CommonJS","zIndex":64},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"02e88ffa-c90e-45cf-b847-a129c518e036","children":[],"html":"AMD","zIndex":65},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ebc33d67-e0c4-4348-98c6-c6b81a219559","children":[],"html":"CMD","zIndex":66},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e2960eb8-25cc-4e51-be56-9b5108b1ad85","children":[],"html":"UMD","zIndex":67},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1247fde4-8dd6-468f-b172-e64fc252eb48","children":[],"html":"ES Module","zIndex":68},{"border":{"shape":"rect","stroke":"transparent","fill":"#fae6e6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"98e4e0d8-ff9e-47d3-bbf4-503026ba9511","children":[],"html":"ES Module 和 CommonJS 的区别","zIndex":69}],"html":"模块化","layout":{"quadrant":1},"icons":{"flag":2},"collapsed":true,"zIndex":18},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#d9dffc"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"a35f3c2d-530c-4cbe-af2b-76cddb2f502a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#d9dffc","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"23f01939-b582-4d28-a78d-984c1bf86888","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#d9dffc","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6bd3222b-82aa-480d-98f3-440f93b9103c","children":[],"html":"块级作用域","zIndex":71},{"border":{"shape":"rect","stroke":"transparent","fill":"#d9dffc","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b307a5d1-040d-4178-a1e4-49defef9f6ea","children":[],"html":"箭头函数","zIndex":72},{"border":{"shape":"rect","stroke":"transparent","fill":"#d9dffc","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f7d83ced-c2f6-4b19-97db-a47671e4fb46","children":[],"html":"模板字符串","zIndex":73},{"border":{"shape":"rect","stroke":"transparent","fill":"#d9dffc","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"72af0c58-5681-4e7c-b82b-b81953962778","children":[],"html":"解构赋值","zIndex":74},{"border":{"shape":"rect","stroke":"transparent","fill":"#d9dffc","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a2f4d222-1307-4eb4-b1dd-fe1619559ac5","children":[],"html":"类和继承","zIndex":75},{"border":{"shape":"rect","stroke":"transparent","fill":"#d9dffc","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6b0ab809-3788-45d9-8f7f-8e166b640f05","children":[],"html":"Promise和 async/await","zIndex":76}],"html":"ES6 (ECMAScript 2015)","zIndex":70}],"html":"ES6+","collapsed":true,"zIndex":17},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E6F4FC","stroke":"transparent"},"id":"d5d95684-e3af-4606-afcd-35612057856f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6a2e3d12-209a-408c-973b-26e53e46b3e5","children":[],"html":"js事件流是指浏览器处理事件的方式，描述事件在页面元素中传播的顺序","zIndex":77},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"69d2c59f-d73b-4cbb-bf7d-9412acab322c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a3927ab5-60cf-419b-9ebd-c9622dab1f2e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b7b0a5ea-b3e3-416b-ae64-f3cd0cbaf84f","children":[],"html":"事件从最外层元素开始向下传递，直到目标元素","zIndex":80}],"html":"捕获阶段","zIndex":79},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"14eb21b5-ee94-4291-88f1-ac82459af60c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"717ee56b-ce45-43c0-b21a-98966b889ad4","children":[],"html":"事件在目标元素上触发","zIndex":82}],"html":"目标阶段","zIndex":81},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e03a77fb-9976-4cbe-a7d1-56f21627ee86","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"80f0157a-c596-4494-bbfb-4a7ff0eaa1e7","children":[],"html":"事件从目标元素开始向上冒泡，直达最外层元素","zIndex":84}],"html":"冒泡阶段","zIndex":83},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d27d835b-05da-4ae3-84a3-8e20fd04eddd","children":[],"html":"所有事件都要经历捕获阶段和目标阶段，但有些事件会跳过冒泡阶段，比如元素获得焦点 focus 和失去焦点 blur 不会冒泡","zIndex":85}],"html":"事件流分为三个阶段","zIndex":78},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d6a04bb9-07a7-47a0-ab6d-5025a17b9369","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e25528da-6351-4db6-a274-e1604ae26b8b","children":[],"html":"event.stopPropagation：阻止事件传播","zIndex":87},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"92a42ec7-39e5-409d-aaa3-f000e7fc8d68","children":[],"html":"event.preventDerfault：取消事件默认行为","zIndex":88}],"html":"阻止事件传播","zIndex":86},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a71ee206-ebdb-4810-b0fe-740ab083ed2a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d28a78a6-33bd-4b1d-8929-f17e77bc83ff","children":[],"html":"这个方法用于绑定捕获和冒泡事件","zIndex":90},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"831dd8eb-6064-49e0-b8cc-09277f8cdda2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f7c7e9bc-3e32-4278-b51f-c9c5a47284be","children":[],"html":"useCapture是一个可选的参数，用于指定事件是使用捕获还是冒泡阶段进行处理。","zIndex":92},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b88fc70f-c2d1-4435-ab80-163bcf5b5dcf","children":[],"html":"当useCapture为false或未提供时，事件将在冒泡阶段进行处理；当useCapture为true时，事件将在捕获阶段进行处理。<span style></span>","zIndex":93},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"22a99891-bf14-4897-81d8-a488dc53d23e","children":[],"html":"设置useCapture的作用是更改事件作用的时机，方便拦截/不被拦截","zIndex":94},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bfa2a9a4-1f1b-4e8c-8038-0bf9d5f6d264","children":[],"html":"useCapture使用场景","zIndex":95}],"html":"用法：element.addEventListener(event, handler, useCapture);","zIndex":91}],"html":"addEventLisener","zIndex":89},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1c19c4a9-12d5-4e2f-b007-4fa14162983b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c8e204aa-f34d-4c1c-9a38-9b60d6cd72c3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"abd90aed-6bb9-4a9b-a805-385fa4376216","children":[],"html":"事件冒泡过程中会上传到父节点，父节点通过事件对象获取到目标节点","zIndex":98},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"476b0720-f7b3-440c-94c0-81e44b446f23","children":[],"html":"因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子节点的事件，这就是事件委托，也叫事件代理。","zIndex":99}],"html":"本质是利用了浏览器的事件冒泡机制","zIndex":97},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6652ee92-371e-4f11-8ea5-4f84ae890ce2","children":[],"html":"实现：e.target可以用来实现事件委托，原理是通过事件冒泡给父元素添加事件监听，e.target指向引发触发事件的元素","zIndex":100},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cd9352f4-1a9a-4903-ac18-7e8c50f1724e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"62e8db36-e090-4d92-a43e-5d4cbe5b57e2","children":[],"html":"e.target 指向触发事件监听的对象","zIndex":102},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cb43c266-fe4a-4395-aa0e-06200e03476a","children":[],"html":"e.currentTarget 指向添加监听事件的对象","zIndex":103}],"html":"e.target和e.currentTarget的区别","zIndex":101},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1dcfdf4e-3c22-45eb-b0e5-3390487c597e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7be86575-794d-4065-9c89-8fd6502fafc1","children":[],"html":"优点：不需要为每一个子元素绑定事件，减少了内存的消耗，同时可以实现动态绑定","zIndex":105},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0d80da16-a76a-4d03-b70a-7b81824dbe83","children":[],"html":"局限：比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。","zIndex":106},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"16969b05-f528-4a21-9a56-c3e11b806528","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b2dfb761-2fba-4aab-8be1-4530dc419a2b","children":[],"html":"绑定的层级多深，绑定次数过多","zIndex":108}],"html":"缺点：可能影响页面性能","zIndex":107}],"html":"优缺点","zIndex":104}],"html":"事件委托","zIndex":96}],"html":"事件流","treeEdge":{"stroke":"#69B1E4","stroke-width":2},"collapsed":true,"zIndex":16},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#EFE8FA","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"id":"9e60b471-f7d8-422b-93af-f0c708670dc3","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#EFE8FA","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"64c9e1b3-81e7-49fe-b8b6-487634f8f1f9","children":[],"html":"js作用域","zIndex":109},{"border":{"shape":"rect","stroke":"transparent","fill":"#EFE8FA","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f153e7fd-0319-4546-ad95-94f00e8c2700","children":[],"html":"var、let、const","zIndex":110}],"html":"作用域","collapsed":true,"zIndex":15},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#c3e0f4"},"treeEdge":{"stroke-width":2,"stroke":"#6EC4C4"},"defaultContentStyle":{"color":"#262626"},"id":"3f33277f-0351-4661-a71f-974b0cefac27","children":[{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#FAEDF6","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"id":"51937c7c-138f-4b34-a899-f7286e3d13e4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bb97e790-031c-4688-9f82-ccc43b089e5e","children":[],"html":"原型链","zIndex":112},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a3d03703-1fb8-499f-a9ed-3727256798c3","children":[],"html":"instanceof 原理","zIndex":113},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"11ddd90f-9854-4e79-bd2a-e7dc3c8466fa","children":[],"html":"new 原理","zIndex":114}],"html":"原型和原型链","collapsed":true,"zIndex":111},{"border":{"shape":"rect","stroke":"transparent","fill":"#c3e0f4","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b827e3da-cf5a-44c4-b8ad-a7f7e18dfe23","children":[],"html":"this指向","layout":{"quadrant":1},"zIndex":115},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#c3e0f4"},"treeEdge":{"stroke-width":2,"stroke":"#69B1E4"},"defaultContentStyle":{"color":"#262626"},"id":"1ad7449f-8601-461c-931a-cd3ca21dd114","children":[],"html":"数据类型","layout":{"quadrant":1},"zIndex":116},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#c3e0f4"},"treeEdge":{"stroke-width":2,"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"5ae92817-6c82-4d4d-accb-bade189924f1","children":[],"html":"数组方法","layout":{"quadrant":1},"zIndex":117},{"border":{"shape":"rect","stroke":"transparent","fill":"#c3e0f4","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e7483869-3120-45e0-830d-7f996f8d275f","children":[],"html":"对象方法","zIndex":118},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#c3e0f4"},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6a00308c-078c-4bb3-840a-5f5582a14ee7","children":[],"html":"字符串方法","layout":{"quadrant":1},"zIndex":119},{"border":{"shape":"rect","stroke":"transparent","fill":"#c3e0f4","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e37d2ece-01e3-4c94-94ce-bdb8b705de92","children":[],"html":"0.1+0.2为什么不等于0.3","zIndex":120},{"border":{"shape":"rect","stroke":"transparent","fill":"#c3e0f4","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"001550ee-1973-4ab1-afed-0a214c21cbe3","children":[],"html":"apply/call/bind的作用、区别和代码实现","zIndex":121}],"html":"基础","layout":{"quadrant":1},"collapsed":true,"zIndex":0}],"layout":{"type":"standard","direction":[1,0]},"zIndex":22}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[563.3662109375,619.5,1],"width":1601,"height":949},"viewportOption":"adapt","text":"JavaScript事件循环JS事件循环是JS执行机制，负责管理事件队列和调用栈执行过程1. JS代码在执行过程中，会创建对应的执行上下文栈并压入执行栈中2. 如果遇到异步任务就暂时挂起，交给其他线程去处理异步任务，当异步任务处理完成之后，会将回调结果加入到事件队列中3. 当执行栈中所有任务执行完毕后，就是主线程处于闲置状态时，才会从事件队列中取出排在首位的事件回调结果，并把回调加入执行栈中执行其中的代码。如此往复，这个过程就是事件循环。4. 事件队列分为宏任务队列和微任务队列。当执行栈为空时，会先查看微任务队列，如果存在事件则依次执行微任务队列中的事件回调，直到微任务队列为空；不存在再去宏任务队列中处理事件队列宏任务队列script脚本执行，setTimeout，setInterval，setImmediate，I/O，用户交互操作、UI渲染微任务队列promise.then、promise.catch、new MutatiobObserver、process.nextTickNode.js事件循环闭包概念闭包是指引用了其他函数作用域中变量的函数，通常是在嵌套函数中实现的。满足这两个条件的函数就是闭包：1. 即使创建它的上下文被销毁了，它依然存在。（比如从父函数中返回）2. 在代码中引用了自由变量（在函数中使用的既不是函数参数也不是函数局部变量的变量称作自由变量）优点保护：闭包执行时形成一个私有作用域模块化开发：CommonJS、ESModule 都有使用闭包vue 中的data函数保存：延长变量的生命周期。一般函数的词法环境在函数返回后就被销毁，但是闭包会保存对创建时所在词法环境的引用，即便创建时所在的执行上下文被销毁，但创建时所在词法环境依然存在，以达到延长变量的生命周期的目的。缺点一个函数返回另一个函数被外部接收，没有被垃圾回收机制回收掉，造成内存泄漏应该对使用完的变量及时置为null，例如dom的引用，定时器的清理垃圾回收机制应用react hooks防抖节流函数垃圾回收造成内存泄漏的操作定时器没有被清除获取DOM元素的引用，元素被删除，但是引用还保留不合理使用闭包，导致变量一直被留在内存中如何检查内存泄漏可以使用 Chrome DevTools 来识别内存图和一些内存泄漏，主要关注两个方面：1. 使用性能分析器可视化内存消耗；2. 识别分离的 DOM 节点使用性能分析器可视化内存消耗在chrome的performance面板，如果对页面做某些操作时，看到JavaScript Heap出现蓝色的峰值，并逐渐增加，说明存在内存泄漏的问题识别分离的 DOM 节点当一个节点从 DOM 树中移除时，它被称为分离，但一些 JavaScript 代码仍然在引用它。我们可以使用 heap snapshot 来检查分离的DOM节点，可以在Chrome DevTools 的Memory面板中打开Heap snapshots选项点击Take snapshot按钮，我们可以在中间的搜索栏目输入Detached来过滤结果以找到分离的DOM节点在V8中，垃圾回收是一个用于自动管理内存，防止内存泄漏的机制。内存管理基础：堆内存引用计数和标记清除V8的垃圾回收机制分代收集根据对象的存活时间，将内存的垃圾回收进行不同的分代，采用不同的回收算法新生代垃圾回收采用空间换时间的scavenge算法：整个空间分为两块，变量仅存在其中一块，回收的时候将存活变量复制到另一块空间，不存活的回收掉，周而复始轮流操作老生代垃圾回收采用标记整理和标记清除。标记清除：遍历所有对象标记可以访问到的存活对象，然后将不存活的进行垃圾回收。回收完后避免内存的断层不连续，需要通过标记整理将存活的对象往内存一端进行移动，移动完成后再清理边界内存异步模块化模块概述IIFECommonJSAMDCMDUMDES ModuleES Module 和 CommonJS 的区别ES6+ES6 (ECMAScript 2015)块级作用域箭头函数模板字符串解构赋值类和继承Promise和 async/await事件流js事件流是指浏览器处理事件的方式，描述事件在页面元素中传播的顺序事件流分为三个阶段捕获阶段事件从最外层元素开始向下传递，直到目标元素目标阶段事件在目标元素上触发冒泡阶段事件从目标元素开始向上冒泡，直达最外层元素所有事件都要经历捕获阶段和目标阶段，但有些事件会跳过冒泡阶段，比如元素获得焦点 focus 和失去焦点 blur 不会冒泡阻止事件传播event.stopPropagation：阻止事件传播event.preventDerfault：取消事件默认行为addEventLisener这个方法用于绑定捕获和冒泡事件用法：element.addEventListener(event, handler, useCapture);useCapture是一个可选的参数，用于指定事件是使用捕获还是冒泡阶段进行处理。当useCapture为false或未提供时，事件将在冒泡阶段进行处理；当useCapture为true时，事件将在捕获阶段进行处理。设置useCapture的作用是更改事件作用的时机，方便拦截/不被拦截useCapture使用场景事件委托本质是利用了浏览器的事件冒泡机制事件冒泡过程中会上传到父节点，父节点通过事件对象获取到目标节点因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子节点的事件，这就是事件委托，也叫事件代理。实现：e.target可以用来实现事件委托，原理是通过事件冒泡给父元素添加事件监听，e.target指向引发触发事件的元素e.target和e.currentTarget的区别e.target 指向触发事件监听的对象e.currentTarget 指向添加监听事件的对象优缺点优点：不需要为每一个子元素绑定事件，减少了内存的消耗，同时可以实现动态绑定局限：比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。缺点：可能影响页面性能绑定的层级多深，绑定次数过多作用域js作用域var、let、const基础原型和原型链原型链instanceof 原理new 原理this指向数据类型数组方法对象方法字符串方法0.1+0.2为什么不等于0.3apply/call/bind的作用、区别和代码实现","graphicsBBox":{"x":896.3662109375,"y":355,"width":1320,"height":1078}}