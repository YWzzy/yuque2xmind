{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"id":"77458f99-587b-4e15-b7e2-cb43cb8cd1c1","x":998.3662298828126,"y":1602,"html":"React","type":"mindmap","defaultContentStyle":{"color":"rgb(38, 38, 38)"},"border":{"fill":"#F5F5F5","shape":"rect","stroke":"transparent","stroke-width":2},"children":[{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#FAEDF6","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"id":"3a0abd06-0a09-43ca-abc7-e41dd2427e56","children":[{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"aa4c6a1b-450e-472d-af48-be56a42d083d","children":[],"html":"React需要合成事件（SyntheticEvent）是为了解决浏览器兼容性问题，提供了一种跨浏览器的事件处理机制。在React中，合成事件是在浏览器原生事件（native event）的基础上构建的，提供了与原生事件相似的API和属性。","zIndex":39},{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"97bb45af-a785-475c-8a73-754006eeffef","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"58e7c294-13d3-4f10-af8b-81dc0651ed2c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"30daecfb-ed13-445a-9a02-bcd182887699","children":[],"html":"React合成事件能够屏蔽不同浏览器之间的事件差异，使得开发者可以编写统一的事件处理代码，而不需要考虑浏览器兼容性问题。","zIndex":42}],"html":"跨浏览器兼容","zIndex":41},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"a9ae302d-1ddc-46a7-8091-ed067603acba","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3a896a4b-cba4-4c8b-85ee-ccc31c86afe3","children":[],"html":"使用了事件池技术，通过复用事件对象来减少内存分配和垃圾回收的开销","zIndex":44}],"html":"性能优化","zIndex":43},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"2d068e15-e118-4230-81d3-a7f8f1a60f70","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"98a59cc0-7b8b-43ec-8282-3ace834b3143","children":[],"html":"React合成事件支持事件冒泡和捕获，可以在一个组件中注册多个事件处理函数，避免了事件处理函数之间的相互影响。","zIndex":46}],"html":"合成嵌套","zIndex":45},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e2d0917b-78ad-45bb-889b-af9625f4ceb4","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"4232be44-3452-4765-a523-c71957adbbde","children":[],"html":"React合成事件支持事件委托，可以在父组件中注册事件处理函数，处理子组件的事件。","zIndex":48}],"html":"支持事件委托","zIndex":47}],"html":"合成事件特点","zIndex":40},{"border":{"shape":"rect","stroke-width":1,"fill":"#FFFFFF","stroke":"transparent"},"id":"0c8b363c-68c4-4665-898e-28f62daba941","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"accd4986-8537-4116-95d8-6ae580fabbd0","children":[],"html":"总之，React合成事件是为了提供一种跨浏览器的事件处理机制，同时也为了提高性能和扩展事件处理的功能。","zIndex":50}],"html":"总结收敛","zIndex":49}],"html":"合成事件","collapsed":true,"zIndex":1},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E6F4FC","stroke":"transparent"},"id":"f6d0c735-fdc3-489f-96bc-3805e3397f15","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"bffd52eb-be30-4878-ae2f-74d231f13a5c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1d037efa-c465-4b25-ba7e-ce75f4bd6198","children":[],"html":"CM 本身并不是一个功能，而是一个底层设计，<span style>在 React 17 中就可以通过一些试验性的api开启 CM</span>","zIndex":52},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"878e1925-f34b-4a8b-9863-352eab8b1c99","children":[],"html":"React 17 和 React 18 的区别就是：从同步不可中断更新变成了异步可中断更新。","zIndex":53},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ac41f405-f285-4007-b7c3-0e5ff944fddd","children":[],"html":"并发模式可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整，该模式通过使渲染可中断来修复阻塞渲染限制。在 Concurrent 模式中，React 可以同时更新多个状态。","zIndex":54},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1},"defaultContentStyle":{"color":"#262626"},"id":"e06196ed-2801-4d40-86ee-51719495aec1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fc66f9cb-53be-4628-8942-e18824bf2ee9","children":[],"html":"只有使用<span style=\"font-weight:bold;\">并发特性</span>，才能开始并发更新","zIndex":56}],"html":"开启并发模式并不是开启并发更新","icons":{"flag":4},"zIndex":55},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"859eaeb0-9140-46ba-91e4-cd30c5c3f008","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3f6fd4b9-565f-47ea-9852-0ddb5c6b401a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"29671740-411c-4127-9e3a-0d9b4ffb04de","children":[],"html":"主要为了能在大量的任务下也能保持 UI 响应。这个新的 API 可以通过将特定更新标记为“过渡”来显著改善用户交互，简单来说，就是被&nbsp;startTransition&nbsp;回调包裹的&nbsp;setState&nbsp;触发的渲染被标记为不紧急渲染，这些渲染可能被其他紧急渲染所抢占。","zIndex":59}],"html":"startTransition","collapsed":true,"zIndex":58},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"d91b81cf-aa75-47ba-a221-14053120708e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1824a8af-8411-4b75-954f-e69cf4ec5533","children":[{"border":{"shape":"rect","stroke":"#69b1e4","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"3b2e7273-7940-4c7f-8686-718534c39f25","children":[],"html":"import React, { useState, useEffect, useDeferredValue } from 'react';<div><br></div><div>const App: React.FC = () =&gt; {</div><div>&nbsp; const [list, setList] = useState&lt;any[]&gt;([]);</div><div>&nbsp; useEffect(() =&gt; {</div><div>&nbsp; &nbsp; setList(new Array(10000).fill(null));</div><div>&nbsp; }, []);</div><div>&nbsp; // 使用了并发特性，开启并发更新</div><div>&nbsp; const deferredList = useDeferredValue(list);</div><div>&nbsp; return (</div><div>&nbsp; &nbsp; &lt;&gt;</div><div>&nbsp; &nbsp; &nbsp; {deferredList.map((_, i) =&gt; (</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &lt;div key={i}&gt;{i}&lt;/div&gt;</div><div>&nbsp; &nbsp; &nbsp; ))}</div><div>&nbsp; &nbsp; &lt;/&gt;</div><div>&nbsp; );</div><div>};</div><div><br></div><div>export default App;</div>","height":467.3875018554688,"width":497.8212310546878,"zIndex":62}],"html":"返回一个延迟响应的值，可以让一个state 延迟生效，只有当前没有紧急更新时，该值才会变为最新值。useDeferredValue 和 startTransition 一样，都是标记了一次非紧急更新。","zIndex":61},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e9291677-8165-443a-bb80-b5800dc12e0e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"9cff84d7-4868-4c6c-b8da-dbcd2cf52cab","children":[],"html":"相同：useDeferredValue 本质上和内部实现与 useTransition 一样，都是标记成了延迟更新任务。","zIndex":64},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"bf51a4a0-6404-47c4-a555-93a36ed069a7","children":[],"html":"不同：useTransition 是把更新任务变成了延迟更新任务，而 useDeferredValue 是产生一个新的值，这个值作为延时状态。（一个用来包装方法，一个用来包装值）","zIndex":65}],"html":"与&nbsp;startTransition 对比","zIndex":63}],"html":"useDeferredValue","collapsed":true,"zIndex":60},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e2e96636-652b-4e08-821f-fb0af90abedc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"c9f70a4a-b2ac-4dea-8ce5-911f5b2bd623","children":[],"html":"一次性渲染10000个标签的时候，页面会阻塞大约0.5秒，造成卡顿，但是如果开启了并发更新，就不会存在这样的问题","zIndex":67},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"6b44f278-cb5b-40ef-b75f-0ae7bf1470bc","children":[],"html":"我们的任务被拆分到每一帧不同的 task 中，JS脚本执行时间大体在5ms左右，这样浏览器就有剩余时间执行样式布局和样式绘制，减少掉帧的可能性","zIndex":68}],"html":"使用场景","collapsed":true,"zIndex":66}],"html":"并发特性","zIndex":57}],"html":"Concurrent Mode（并发模式）","icons":{"flag":0},"zIndex":51},{"border":{"shape":"rect","stroke-width":1,"stroke":"transparent","fill":"#FFFFFF"},"id":"d1892066-8dde-41a4-8bdb-0d3f40cd80af","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"415e25cf-3673-4ad9-a7e4-09db3890aaa9","children":[{"border":{"shape":"rect","stroke":"#69b1e4","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"08f1b6d8-689c-499b-96a8-46db82af9aa1","children":[],"html":"// React 17<div>import React from 'react';</div><div>import ReactDOM from 'react-dom';</div><div>import App from './App';</div><div>const root = document.getElementById('root')!;</div><div>ReactDOM.render(&lt;App /&gt;, root);</div><div><br></div><div>// React 18</div><div>import React from 'react';</div><div>import ReactDOM from 'react-dom/client';</div><div>import App from './App';</div><div>const root = document.getElementById('root');</div><div>ReactDOM.createRoot(root).render(&lt;App /&gt;);</div>","width":370.99998105468694,"zIndex":71}],"html":"为了更好的管理root节点，React 18 引入了一个新的 root API，新的 root API 还支持 new concurrent renderer（并发模式的渲染），它允许你进入concurrent mode（并发模式）。","zIndex":70}],"html":"Render API","collapsed":true,"zIndex":69},{"border":{"shape":"rect","stroke-width":1,"stroke":"transparent","fill":"#FFFFFF"},"id":"2f28144f-99a9-4c81-8020-834088b4c283","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f8d57d00-45a3-4af2-894f-cac34eee648b","children":[],"html":"批处理是指为了获得更好的性能，在数据层，将多个状态更新批量处理，合并成一次更新","zIndex":73}],"html":"setState 自动批处理","collapsed":true,"zIndex":72},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e2547628-69fd-45a4-b516-8caa49e92b23","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"56ebb483-2d82-40b4-adde-baff6d9f4cbb","children":[],"html":"批处理是一个破坏性改动，如果你想退出批量更新，你可以使用 flushSync","zIndex":75}],"html":"flushSync","collapsed":true,"zIndex":74},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b43bd0b8-031a-484d-af22-2d33e166a585","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"f4919093-1ed7-4ca4-bd4c-8f429b3188a1","children":[],"html":"在 React 17 中，如果你需要返回一个空组件，React只允许返回null。如果你显式的返回了 undefined，控制台则会在运行时抛出一个错误","zIndex":77},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"da80d2ea-f1d8-4dd9-9b1e-a5012b8c4045","children":[],"html":"在 React 18 中，不再检查因返回 undefined 而导致崩溃。既能返回 null，也能返回 undefined","zIndex":78}],"html":"React 组件返回值","collapsed":true,"zIndex":76},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"b1dfec7b-0930-4a82-b024-4c6c6e5f4db8","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"034a5c37-16c6-4b39-b6a8-a4543f1e7298","children":[],"html":"当你使用严格模式时，React 会对每个组件进行两次渲染，以便你观察一些意想不到的结果。在 React 17 中，取消了其中一次渲染的控制台日志，以便让日志更容易阅读。","zIndex":80},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"ccc273aa-72f8-41a5-8545-6ecfefe84031","children":[],"html":"为了解决社区对这个问题的困惑，在 React 18 中，官方取消了这个限制。","zIndex":81}],"html":"Strict Mode","collapsed":true,"zIndex":79},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"29094b9b-1f85-4058-9284-0a4e472a28d3","children":[],"html":"Suspense 不再需要 fallback 来捕获","zIndex":82},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"1b46a5fc-05eb-490d-b8e6-67c9583977e1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"180b9604-59ce-48a2-878a-8c3b1f01696c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e9e87bc6-ae10-404c-82ee-d66fdbabd5bf","children":[],"html":"支持同一个组件在客户端和服务端生成相同的唯一的 ID，避免 hydration 的不兼容","zIndex":85}],"html":"useId","zIndex":84},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"af103fe0-4444-4b2b-a5bf-7b2e9c9deeda","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"2a52bad5-73d4-4219-9691-1e1c49be09b6","children":[],"html":"主要用来解决外部数据撕裂问题","zIndex":87},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"fc1c9564-191e-4ae3-892b-458650d9c60b","children":[],"html":"useSyncExternalStore 能够通过强制同步更新数据让 React 组件在 CM 下安全地有效地读取外接数据源。 在 Concurrent Mode 下，React 一次渲染会分片执行（以 fiber 为单位），中间可能穿插优先级更高的更新。假如在高优先级的更新中改变了公共数据（比如 redux 中的数据），那之前低优先的渲染必须要重新开始执行，否则就会出现前后状态不一致的情况。","height":135.00000185546878,"width":617.9999810546874,"zIndex":88}],"html":"useSyncExternalStore","zIndex":86},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"e1201e2b-4b91-4f38-9002-35311e39ea4b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7e35d747-6ba2-4ea7-bdc4-f39c88947c07","children":[],"zIndex":90,"html":"这个 Hooks 只建议&nbsp;css-in-js 库来使用。 这个 Hooks 执行时机在 DOM 生成之后，useLayoutEffect 之前，它的工作原理大致和&nbsp;useLayoutEffect&nbsp;相同，只是此时无法访问&nbsp;DOM&nbsp;节点的引用，一般用于提前注入&nbsp;&lt;style&gt;&nbsp;脚本"}],"html":"useInsertionEffect","zIndex":89}],"html":"新的API","collapsed":true,"zIndex":83}],"html":"<a href=\"https://juejin.cn/post/7094037148088664078\" target=\"_blank\" style>React 18 新特性</a>","treeEdge":{"stroke":"#69B1E4","stroke-width":2},"collapsed":true,"zIndex":3},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#EFE8FA","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"id":"7ee3724d-164c-4c28-845d-a8bcc6405248","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"id":"c9f1900d-95cc-4536-b524-0c422e8da955","children":[],"html":"React Fiber 的执行流程包括初始化阶段、任务调度阶段、协调阶段（Reconciliation 和 Commit）、完成阶段等，通过优先级调度器、协调算法、diff 算法等来提高 React 应用的性能和响应速度。","layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"height":74.50000185546878,"width":683.9999810546874,"zIndex":91},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"id":"9f905c29-f615-4b52-ac10-7d9c46db7468","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7a5e69d3-bdf5-4fdd-af86-9a40fc929824","children":[],"html":"React Fiber 通过调用 render() 方法来生成虚拟 DOM 树，并将其存储在 Fiber 节点中。在这个阶段，React Fiber 还会创建一些全局变量，如 workInProgressRoot、nextUnitOfWork 等，用于记录当前的工作进度和任务单元。","zIndex":93}],"html":"初始化阶段","layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"zIndex":92},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"803e3122-0f9d-453a-92e6-91846d1c77ff","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"62de6545-f25a-44f3-90bc-0a6aec14c575","children":[],"html":"React Fiber 通过优先级调度器（Priority Scheduler）来决定当前要执行的任务单元。每个任务单元都是一个 Fiber 节点，记录了该任务的类型、状态、子节点等信息。React Fiber 将任务单元按照优先级分为多个批次（Batch），每个批次包含一组任务单元。React Fiber 首先会执行高优先级的批次，然后执行低优先级的批次。","zIndex":95}],"html":"任务调度阶段","zIndex":94},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"98c97ecd-fb6d-47e1-8bae-ac8f0ce90151","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"7d76d88a-24a3-4372-9d0f-078426cfb2fe","children":[],"html":"在每个任务单元执行前，React Fiber 会检查该任务单元是否需要更新。如果需要更新，则会进入协调阶段，根据当前节点和子节点的状态来决定该任务单元的执行方式。协调阶段分为两个步骤：Reconciliation 和 Commit。","zIndex":97}],"html":"协调阶段","zIndex":96},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"a4a86249-ce3b-4551-b11a-431c3d1bc481","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"defaultContentStyle":{"color":"#262626"},"id":"35ae62cc-2fc5-48c4-9a6d-de0fab4f252e","children":[],"html":"React Fiber 通过遍历 Fiber 树来比较新旧虚拟 DOM 的差异，找出需要更新的节点，并标记这些节点为“脏节点”。React Fiber 通过 diff 算法来比较新旧虚拟 DOM 的差异，尽可能地重用已有的节点，从而减少 DOM 操作的次数","zIndex":99}],"html":"Reconciliation 阶段","zIndex":98},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"46801b31-400e-49a4-95a7-d46d01fabf83","children":[],"html":"Commit 阶段","zIndex":100},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":1},"layout":{"quadrant":1,"type":"indent","direction":[1,1],"quadrantConstraint":[1]},"defaultContentStyle":{"color":"#262626"},"id":"869c15fb-8274-4444-a26d-2d718b0b3b5b","children":[],"html":"完成阶段","zIndex":101}],"html":"Fiber的执行流程","collapsed":true,"zIndex":5},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#ece7f9"},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"65316895-ab11-4e07-8a4d-c0ab4010a9ef","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c671dcf2-c2f7-4ec2-b65b-598a6d003402","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7735b84d-ebad-45a3-865b-93b8aa7ae1bc","children":[],"html":"props传递","zIndex":103}],"html":"父组件向子组件通信","zIndex":102},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"51591bd0-8e5b-423c-a074-8d5b806faae0","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f73c0277-ec6c-4a65-aa82-617cb9fd46cb","children":[],"html":"回调函数","zIndex":105},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9f45be2f-4b25-468f-8b26-54c171d7197e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e33530d4-c6bb-43a2-9fc2-cbf76294f4c7","children":[],"html":"点击子组件的button按钮，事件会冒泡到父组件上","zIndex":107},{"border":{"shape":"rect","stroke":"#a287e1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dd170ab3-76d5-4e5b-adcd-db06c42bc795","children":[],"html":"const Child = () =&gt; {<div>&nbsp; &nbsp; return &lt;button&gt;点击&lt;/button&gt;;</div><div>};</div><div>const Parent = () =&gt; {</div><div>&nbsp; &nbsp; const sayName = name =&gt; {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; console.log(name);</div><div>&nbsp; &nbsp; };</div><div>&nbsp; &nbsp; return (</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &lt;div onClick={() =&gt; sayName('aaa')}&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &lt;Child /&gt;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &lt;/div&gt;</div><div>&nbsp; &nbsp; );</div><div>};</div><div>export default Parent;</div>","zIndex":108}],"html":"事件冒泡","collapsed":true,"zIndex":106},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1ff96cf9-19db-407a-beee-25c150178e93","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4f900b74-a245-4693-b2da-ac11b889cd48","children":[{"border":{"shape":"rect","stroke":"#a287e1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ff642614-ee4f-4969-9758-81c1c3854902","children":[],"html":"import { useRef } from 'react';<div>import { useEffect } from 'react';</div><div>import React from 'react';</div><div><br></div><div>const Guang: React.<span style=\"font-weight:bold;\">ForwardRefRenderFunction</span>&lt;HTMLInputElement&gt; = (<span style=\"font-weight:bold;\">props, ref</span>) =&gt; {</div><div>&nbsp; return &lt;div&gt;</div><div>&nbsp; &nbsp; &lt;input ref={ref}&gt;&lt;/input&gt;</div><div>&nbsp; &lt;/div&gt;</div><div>}</div><div><span style=\"font-weight:bold;\">const WrapedGuang = React.forwardRef(Guang);</span></div><div>function App() {</div><div>&nbsp; const ref = useRef&lt;HTMLInputElement&gt;(null);</div><div>&nbsp; useEffect(()=&gt; {</div><div>&nbsp; &nbsp; console.log('ref', ref.current)</div><div>&nbsp; &nbsp; ref.current?.focus()</div><div>&nbsp; }, []);</div><div>&nbsp; return (</div><div>&nbsp; &nbsp; &lt;div className=\"App\"&gt;</div><div>&nbsp; &nbsp; &nbsp; <span style=\"font-weight:bold;\">&lt;WrapedGuang ref={ref}/&gt;</span></div><div>&nbsp; &nbsp; &lt;/div&gt;</div><div>&nbsp; );</div><div>}</div><div><br></div><div>export default App;</div>","zIndex":111}],"html":"forwardRef：用来把ref从子组件传递到父组件。","collapsed":true,"zIndex":110},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1b9ffd8a-9043-46a9-930b-1dbeafbbb0b3","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f99246ea-3c40-4dbc-8fe6-120089fad9db","children":[],"html":"它有 3 个参数，第一个是传入的 ref，第二个是返回新的 ref 值的函数，第三个是依赖数组","layout":{"quadrant":1},"zIndex":113},{"border":{"shape":"rect","stroke":"#a287e1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"68d65f55-daf4-4d68-99d3-a139682caf0e","children":[],"html":"const Guang: React.ForwardRefRenderFunction&lt;RefProps&gt; = (props, ref) =&gt; {<div>&nbsp; const inputRef = useRef&lt;HTMLInputElement&gt;(null);</div><div><br></div><div>&nbsp; useImperativeHandle(ref, () =&gt; {</div><div>&nbsp; &nbsp; return {</div><div>&nbsp; &nbsp; &nbsp; aaa() {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; inputRef.current?.focus();</div><div>&nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; }</div><div>&nbsp; }, [inputRef]);</div><div><br></div><div>&nbsp; return &lt;div&gt;</div><div>&nbsp; &nbsp; &lt;input ref={inputRef}&gt;&lt;/input&gt;</div><div>&nbsp; &lt;/div&gt;</div><div>}</div><div>const WrapedGuang = React.forwardRef(Guang);</div><div><br></div><div>function App() {</div><div>&nbsp; const ref = useRef&lt;RefProps&gt;(null);</div><div>&nbsp; useEffect(()=&gt; {</div><div>&nbsp; &nbsp; console.log('ref', ref.current)</div><div>&nbsp; &nbsp; <span style=\"font-weight:bold;\">ref.current?.aaa();</span></div><div>&nbsp; }, []);</div><div>&nbsp; return (</div><div>&nbsp; &nbsp; &lt;div className=\"App\"&gt;</div><div>&nbsp; &nbsp; &nbsp; &lt;WrapedGuang ref={ref}/&gt;</div><div>&nbsp; &nbsp; &lt;/div&gt;</div><div>&nbsp; );</div><div>}</div><div><br></div><div>export default App;</div>","width":543.9999810546879,"zIndex":114}],"html":"useImperativeHandle：不暴露原生标签，而是暴露一些自定义内容","collapsed":true,"zIndex":112}],"html":"forwardRef + useImperativeHandle","collapsed":true,"zIndex":109}],"html":"子组件向父组件通信","zIndex":104},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"37acb26b-215c-4293-b56d-51e1de548ce5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"02ce646f-bdf3-488c-9295-6c511916d91e","children":[],"html":"通过父组件做数据中转，进行状态提升","zIndex":116}],"html":"兄弟组件通信","zIndex":115},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"eb731053-04f9-4f68-8187-a99a1f8f014f","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c9282c9a-a33d-49ff-bd88-d46f4b08da97","children":[],"html":"useContext","zIndex":118}],"html":"父组件向后代组件通信","zIndex":117},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"23cfe4f5-16dc-4835-ac62-8de1e3bd416e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7a0529c2-6516-4d21-b6f8-9ef6816c1280","children":[],"html":"Redux","zIndex":120},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"52daa3ac-aba2-41b2-9ba8-fd9502e06750","children":[],"html":"Jotai：轻量级，基于原子的状态管理库","zIndex":121},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"44cb808b-0502-4a47-845e-12a80570ec49","children":[],"html":"Recoil：Facebook开发的基于原子的状态管理库","zIndex":122}],"html":"无关组件通信","zIndex":119}],"html":"组件通信","collapsed":true,"layout":{"quadrant":1},"zIndex":7},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E9F7E9","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#77C386"},"id":"5b4acb11-3a46-4d24-9bc2-931dc8134cad","children":[{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"54468b04-e913-4a21-81ca-864a44b713cc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ea7b2586-65f7-4271-8217-7c0e1873c3c8","children":[],"html":"constructor 初始化阶段，可以进行state和props的初始化","zIndex":124},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2c8d469f-6211-4b3d-8824-62d76c230898","children":[],"html":"static getDerivedStateFromProps 静态方法，不能获取this","zIndex":125},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"70936044-879a-4db1-a3a7-d630272873cc","children":[],"html":"render 创建虚拟DOM的阶段","zIndex":126},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d553e5ba-53a7-4a52-992a-298da6433914","children":[],"html":"componentDidMount 第一次渲染后调用，挂载到页面生成真实DOM，可以访问DOM，进行异步请求和定时器、消息订阅","zIndex":127}],"html":"挂载","zIndex":123},{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"2d95ddc7-7251-4c53-87cc-b150d3dedb6f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1fefa43c-5d8f-42ef-b7b7-8cc91f4f9ba0","children":[],"html":"static getDerivedStateFromProps","zIndex":129},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c3ff67d7-bba2-4ba8-a78c-4797b81fa631","children":[],"html":"shouldComponentUpdate 返回一个布尔值，默认返回true，可以通过这个生命周期钩子进行性能优化，确认不需要更新组件时调用","zIndex":130},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"61395b4f-d71c-4d7a-89d1-844c91a44081","children":[],"html":"render 更新虚拟DOM","zIndex":131},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d5c1feaa-fd2d-4820-ac56-15c9b8d1d30a","children":[],"html":"getSnapShotBeforeUpdate 获取更新前的状态","zIndex":132},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cd4b44b6-748f-428a-ba10-cdf4bf17f5de","children":[],"html":"componentDidUpdate 在组件完成更新后调用，更新挂载后生成真实DOM","zIndex":133}],"html":"更新","zIndex":128},{"border":{"shape":"rect","stroke-width":2,"stroke":"transparent","fill":"#FFFFFF"},"id":"4f5f1c12-b854-4b70-b99a-46cec9af2667","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"20423e31-ed4d-41f6-8b7c-77a55af7f903","children":[],"html":"componentWillUnmount 组件从DOM中被移除的时候调用，通常在这个阶段清除副作用，比如定时器、事件监听等","zIndex":135}],"html":"卸载","zIndex":134},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6ebc4ee8-34ac-40dd-8151-e72f4ea65b63","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7df09d51-1700-4ad9-834c-35212629d2f8","children":[],"html":"static getDerivedStateFromError 在errorBoundary中使用","zIndex":137},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e35d672d-91e9-4361-98c8-d006758c950a","children":[],"html":"componentDidCatch","zIndex":138}],"html":"错误捕获","zIndex":136},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5ec944f8-3c7e-4239-8d09-8cb94336bbe5","children":[],"html":"render是class组件中唯一必须实现的方法","zIndex":139}],"html":"生命周期","collapsed":true,"zIndex":8},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#E8EEFC","stroke":"transparent"},"id":"d5503e5a-3c84-46ee-bbe8-2b70e0e489cb","children":[{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"29af9308-e3b5-467a-89a3-c9b469ef54ee","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3b4e4716-59a9-4bf0-bd13-e2189d497d5b","children":[],"html":"React 16.8推出的React Hooks，解决函数组件不能保存状态和执行副作用的问题，基本上可以替代之前类组件的开发方式。","zIndex":141},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"94c13e20-5d23-43aa-b8ab-f172c1325224","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3270db06-e4e1-47fe-9ccb-995f05636af0","children":[],"html":"声明constructor","zIndex":143},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0fd28a9e-1fb2-4380-acdd-972fcc650991","children":[],"html":"手动绑定this","zIndex":144},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"54908a9c-fd6c-41a9-aacc-db8a471a8bce","children":[],"html":"生命周期钩子","zIndex":145},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"728d1bfd-24a6-4f0d-aa6d-bd4e5281cc7a","children":[],"html":"继承class","zIndex":146},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"22b52f7e-d326-4325-94ee-6cfc20a77396","children":[],"html":"面向对象(封装和继承) vs 函数式编程思想","zIndex":147}],"html":"函数组件和类组件的区别","zIndex":142},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d7d69879-f140-402a-a569-8fea9583bcce","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1a67949b-e354-4b5f-bb93-0641d93b044e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"16299bca-b9e0-4fd1-b1ec-7ee3f62a9c81","children":[],"html":"告别难以理解的class组件","zIndex":150},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"914d9870-2d39-4d42-b080-c3804e66c313","children":[],"html":"解决业务逻辑难以拆分的问题","zIndex":151},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"91594901-348e-4525-92ea-b1b4afbd5e3b","children":[],"html":"状态逻辑复用变得简单","zIndex":152},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d3bb5f2c-8717-46b9-876b-3866dd5d5aaf","children":[],"html":"函数式编程的设计理念更适合react","zIndex":153}],"html":"优点","zIndex":149},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c4835386-445c-483a-8454-9fc1ad3f29c1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f29f758e-2354-47fe-9e7a-6d128c625187","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f8395d05-7334-44f8-bb60-3e2da07d2273","children":[],"html":"错误边界 ErrorBoundary组件还是需要用到类组件和componentDidCatch和getDerivedStateFromError来实现","zIndex":156}],"html":"不能完全提供类组件能力","zIndex":155},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"43fb9d0a-8446-43ac-89ee-c457f6f81b1d","children":[],"html":"hooks 在使用层面有严格的规则约束","zIndex":157}],"html":"局限","zIndex":154}],"html":"优缺点","zIndex":148}],"html":"基础","collapsed":true,"zIndex":140},{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"c453b478-8a2f-41bd-8463-180962e5fbb9","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e13b55a3-a165-42df-9822-092ef73539dd","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8a54a9a3-6620-47ec-803c-7ce5f6a4ce45","children":[],"html":"两个hook在使用上类似，都是接受一个回调函数和依赖数组，用来执行副作用","zIndex":160},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f16a3337-e056-4967-b9d7-f4c9518fcbba","children":[],"html":"区别是&nbsp;useLayoutEffect 的渲染是同步的，会造成阻塞，useEffect 的渲染是异步的，一般推荐使用useEffect。如果使用useEffect 出现严重的闪屏问题，可以采用useLayoutEffect替代","zIndex":161},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6bdfdb27-f9fc-42e7-8513-aeaf41b7c3eb","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"42319c99-0297-4858-8e5e-b0f52d22ec91","children":[],"html":"js执行和渲染是阻塞的，useEffect 的 effect 函数会在操作 dom 之后异步执行","zIndex":163},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5ce15dca-e377-4ef7-ac9f-cc32026e5959","children":[],"html":"异步执行就是用 setTimeout、Promise.then 等 api 包裹执行的逻辑","zIndex":164},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f4afc653-11ec-4c85-ba14-5ac123991835","children":[],"html":"这些逻辑会以单独的宏任务或者微任务的形式存在，然后进入 Event Loop 调度执行","zIndex":165},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ecaea2ee-3ce7-41ed-82f8-86c62041dcd7","children":[],"html":"打开 Permormance 工具，可以看到 Event Loop 的详情，渲染的间隔是固定的，而 js 的任务在这些渲染的间隔中执行","zIndex":166},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"86c823e1-1b64-412c-bb54-51d4b347baf7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"44a2ea6f-5af2-42ae-843a-a07d1a50917b","children":[],"html":"有可能在下次渲染之前，就能执行完这个 effect","zIndex":168},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"84df4a13-384f-448a-bd56-824991bbf3b2","children":[],"html":"也有可能下次渲染前，没时间执行这个 effect，所以就在渲染之后执行了","zIndex":169}],"html":"所以异步执行的 effect 逻辑就有两种可能","zIndex":167},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"46b445d0-f73b-4ae7-afb3-000ee7914ffe","children":[],"html":"这样就导致有的时候页面会出现闪动，因为第一次渲染的时候的 state 是之前的值，渲染完之后执行 effect 改了 state，再次渲染就是新的值了","zIndex":170},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"25041cd8-df3e-4c13-ba23-aed9f9669480","children":[],"html":"一般这样也没啥问题，但如果你遇到这种情况，不想闪动那一下，就用 useLayoutEffect。","zIndex":171},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"99a3cf1a-2933-47a4-bb1c-8b039d8fc7d7","children":[],"html":"它和 useEffect 的区别是它的 effect 执行是同步的，会等effect逻辑执行完再渲染","zIndex":172}],"html":"为什么会出现闪屏问题","zIndex":162}],"html":"useEffect 和 useLayoutEffect 的区别","collapsed":true,"zIndex":159},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"eb8d3928-e038-4d6c-98a5-0beda06bf112","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"074f320e-1be1-45c7-b3b1-e1b562807d07","children":[],"html":"一般用来保存dom的引用，也可以存储其他数据，但是不会触发渲染","zIndex":174},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"56fd082e-6c67-4ad0-a19e-5419d440856c","children":[],"html":"useRef一般用来存一些不用于渲染的内容","zIndex":175}],"html":"useRef","zIndex":173}],"html":"Hooks 有哪些","zIndex":158},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"68893809-c0bd-44e5-ad38-efa39f78e0f2","children":[],"html":"自定义Hook","zIndex":176},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b34bce3d-360e-437f-9c58-dd5e66222e3e","children":[],"html":"hooks 原理","zIndex":177}],"html":"React Hooks","treeEdge":{"stroke":"#6F81DB","stroke-width":2},"collapsed":true,"zIndex":9},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#fae6f6"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"ba3b6cb9-d3e8-47a3-9e9c-3cef55bb15da","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"efaec46e-9fed-44e1-9c8c-8abc759c63d5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"baf58596-3cd1-4b6d-8fe2-39ff961cf7f5","children":[],"html":"React.memo、useMemo、useCallback 搭配使用，减少重复渲染","layout":{"quadrant":1},"zIndex":179}],"html":"减少重复渲染","zIndex":178},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"411409df-c179-496e-8876-634f7a4481e4","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a8b67cd1-f65d-4c30-a53f-2b8d4dc9eac2","children":[],"html":"React.lazy + Suspense","zIndex":181}],"html":"组件懒加载","zIndex":180},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1cb0f25c-e162-437f-9899-91623c8bf605","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"24dd27bd-bef8-4418-9fd4-6d6dfb234005","children":[],"html":"页面节点多时，使用 useDeferredValue 或者 useTransition 开启并发模式，实现分片渲染&nbsp;","zIndex":183}],"html":"开启并发模式","zIndex":182},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b633aed1-78b1-4541-9e0c-0837043daf33","children":[],"html":"使用Fragment","zIndex":184},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c9d982ed-d9d8-44a8-83ea-26aafa488b74","children":[],"html":"遍历时使用key","layout":{"quadrant":1},"zIndex":185},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"92cb1cac-e6cd-4f2d-aec3-5cb2364f595c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4328ffd6-2e75-4032-a05c-6a85f3db40f8","children":[],"html":"虚拟长列表","zIndex":187},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"41b9e9a3-c03b-4ed6-b1b4-dbf9a9b83163","children":[],"html":"频繁操作并调用接口的地方采用防抖","zIndex":188},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6ace990f-e766-46b7-95c7-0c4d1d69d808","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"937e276d-a61e-4556-8f22-5510aa222e80","children":[],"html":"拆分context","zIndex":190},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5005a7b7-a45a-4b64-8a8e-f636addca915","children":[],"html":"使用其他状态管理库","zIndex":191}],"html":"使用 useContext 避免不需要的重复渲染","zIndex":189}],"html":"业务优化","zIndex":186}],"html":"React 性能优化","collapsed":true,"zIndex":10},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#e1effa"},"treeEdge":{"stroke-width":2,"stroke":"#69B1E4"},"defaultContentStyle":{"color":"#262626"},"id":"4bcf7156-1edf-4ea7-865f-a53a432f201d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f87c7d6e-dbde-48e7-98ef-3d4122324ad6","children":[],"html":"React 的语法糖，可以在html写js代码，在react17以前会被babel编译成React.createElement方法，react17以后会通过编译器babel/typescript转换为_jsx方法","zIndex":192},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0f3a4679-aaea-4ef8-80f3-c56b73017df5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a72b5da7-24c9-4233-b842-69e6142fe792","children":[],"html":"babel编译jsx时，小写字母会被当成字符串，大写字母开头会被当成变量传递给React.createElement","zIndex":194}],"html":"为什么React自定义组件首字母要大写","zIndex":193},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"81a33717-194e-447a-afa0-f69a20b809e5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5072a846-c7df-484c-821e-3cdbc251f5d0","children":[],"html":"React组件最后会编译为render函数，函数的返回值只能是1个，如果不用单独的根节点包裹，就会并列返回多个值，这在js中是不允许的","zIndex":196},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fd41d180-d236-4e50-ab6f-b02ad0b93550","children":[],"html":"react的虚拟DOM是一个树状结构，树的根节点只能是1个，如果有多个根节点，无法确认是在哪棵树上进行更新","zIndex":197},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9d249671-e5a6-4afa-9967-916862e346bf","children":[],"html":"React组件怎样可以返回多个组件：React.Fragment","zIndex":198}],"html":"React组件为什么不能返回多个元素","zIndex":195},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e3550ec3-3683-48a3-bfd6-e498b9b667cf","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"984e62e9-d4b5-404e-98fd-349675318b95","children":[],"html":"react组件有类组件、函数组件","zIndex":200},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7aaeaed8-6a1e-4581-8739-1c4caa264389","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7f206e2d-58ff-4cd0-80cd-218f51cddd4e","children":[],"html":"const element = &lt;div className=\"element\"&gt;我是元素&lt;/div&gt;&nbsp;","zIndex":202}],"html":"react元素是通过jsx创建的","zIndex":201}],"html":"React中元素和组件的区别","zIndex":199}],"html":"JSX","collapsed":true,"zIndex":11},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[2]},"border":{"shape":"rect","stroke-width":2,"fill":"#FCF6E1","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"id":"9db6791f-80e1-4bb7-a052-c01d5ba96ac3","children":[{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"ca8de7d3-1fba-420e-911b-4b63aab2fd2d","children":[],"html":"组件化","zIndex":203},{"border":{"shape":"rect","fill":"#FFFFFF","stroke-width":2,"stroke":"transparent"},"id":"0c0bd793-6885-4ec6-ba2a-a2b27a0403e4","children":[],"html":"数据驱动视图","zIndex":204},{"border":{"shape":"rect","stroke":"transparent","fill":"#FFFFFF","stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f72e94ad-ede7-4d9d-920c-2125b0016f2e","children":[],"html":"虚拟DOM","zIndex":205}],"html":"React 设计思想","collapsed":true,"zIndex":12},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"#e2e6f8"},"treeEdge":{"stroke-width":2,"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"561a340e-46df-4849-a8d0-e47b43770d2c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"484d3177-799a-463c-9059-acc29dee118d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e07b1f45-ec49-41fd-8eef-63bb41345d60","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"243d28f2-9eec-4409-9fe0-97299f4a96a0","children":[],"html":"可中断","zIndex":208},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f05d78e0-ee66-4c21-8eb1-557fd1b6eaee","children":[],"html":"可恢复","zIndex":209},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a5b5a2ed-87cd-4f09-a399-9d231cac1c23","children":[],"html":"任务优先级调度","zIndex":210},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ab025188-7f43-4a01-b6d0-c486ca1f8ca3","children":[],"html":"分片渲染","zIndex":211}],"html":"特点","zIndex":207}],"html":"Fiber 实现了一个基于<span style=\"font-weight:bold;\">优先级和 requestIdleCallback</span> (执行的前提条件是当前浏览器处于空闲状态) 的一个<span style=\"font-weight:bold;\">循环 任务调度 算法</span>, 它在渲染虚拟 DOM、 diff 阶段将任务拆分为多个小任务、这样的话就可以随时进行<span style=\"font-weight:bold;\">中止和恢复、同时又根据每个任务的优先级来执行任务</span>","layout":{"quadrant":1},"width":604.8749810546879,"zIndex":206},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7180c260-cf38-4051-b17f-3a81bf3d260a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b07e44fd-89d4-4bb6-b0e4-510e3d20cf9b","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"26d8aa0d-f8dc-4678-b8cf-4b9d8b3c4dc2","children":[],"html":"虚拟dom树结构，树结构只能找到子节点，中断后无法找到中断位置","zIndex":214},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f6f584f2-66f6-426e-8080-04d22133c300","children":[],"html":"采用边diff边渲染机制，中断了已经渲染完成的部分无法回退","zIndex":215}],"html":"React16 以前递归渲染不能中断，页面层级深会存在渲染速度慢的问题","zIndex":213},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e15402dd-93b8-4433-a1fd-7122833a5001","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0b67e634-b82b-453f-9a26-9bf131426e05","children":[],"html":"把递归渲染改造成 render（reconcile + schdule） + commit 两个阶段的渲染","height":56.88523210088874,"width":504.96185653390967,"zIndex":217}],"html":"fiber实现了渲染可中断，可恢复，并且根据优先级进行任务调度渲染，优化了渲染性能问题","zIndex":216}],"html":"fiber解决了什么问题","zIndex":212},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"848d3374-85c7-4e49-8e22-4f0a85b29168","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f8f82b22-45ff-4ede-a42f-33a38e01cdbc","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4ca2f01c-3f08-4091-a8c7-0ce1e65b7d35","children":[],"html":"当react更新时间超过1帧时，会产生视觉卡顿的效果，因此我们可以通过fiber把浏览器渲染过程分段执行，每执行一会就让出主线程控制权，执行优先级更高的任务","zIndex":220},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bd245fda-bf98-4906-8ae2-b9577f44debb","children":[],"html":"通过requestIdleCallback方法来实现","zIndex":221}],"html":"何时中断","layout":{"quadrant":1},"zIndex":219},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6f7b4994-961b-4353-a73b-6b1ed7658118","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"733270ed-c87f-4a66-a568-6f86426bd17e","children":[],"html":"将递归变为循环","zIndex":223}],"html":"reconcile 如何实现中断","layout":{"quadrant":1},"zIndex":222},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"516c9b7a-59c4-4b43-83e0-b72b5e0198a1","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9a9af8d0-f91d-4178-b675-401846b13c53","children":[],"html":"引入了fiber数据结构，它是一个链表结构，返回了return、children、siblings，分别代表父fiber，子fiber和兄弟fiber，实现了可中断、可恢复","layout":{"quadrant":1},"zIndex":225}],"html":"如何恢复","zIndex":224}],"html":"可中断、可恢复如何实现","zIndex":218},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4854849c-6e20-4d69-ae0e-52d56e011e88","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a082bcdb-b4cb-4b49-9cb3-d937659d30bb","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8d8c0837-f2a1-4d32-866c-887e8fc764f6","children":[],"html":"1. 创建fiberRoot（React根元素）和rootFiber(通过ReactDOM.render或者ReactDOM.createRoot创建出来的)","zIndex":228},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"abc931b8-93ff-41a2-8d02-c4dd702ff964","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6b5c1626-b8a3-45b1-be99-2603e5f42c73","children":[],"html":"workInProgress:正在内存中构建的fiber树叫workInProgress fiber，在第一次更新时，所有的更新都发生在workInProgress树，在第一次更新后，workInProgress树上的状态是最新状态，它会替换current树","zIndex":230},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7fc72b73-a2d4-410c-831b-78ce96939e1c","children":[],"html":"current:正在视图层渲染的树叫current fiber树","zIndex":231},{"start":0,"end":1,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"currentFiber.alternate = workInProgressFiber<div>workInProgressFiber.alternate = currentFiber</div>","defaultContentStyle":{"color":"#262626"},"id":"8ecce641-f659-42d1-849b-4ef5295fa24a","children":[],"zIndex":232}],"html":"2. 进入beginWork","zIndex":229},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8bdf4397-bf89-4e9b-8dc9-4f891cdec7d1","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"96442276-d63b-4f3e-ad1d-21c1b9aedd1d","children":[],"html":"在新建的alternate树上，完成整个子节点的遍历，包括fiber的创建，最后会以workInProgress树最为最新的渲染树，fiberRoot的current指针指向workInProgress使其变成current fiber，完成初始化流程","zIndex":234}],"html":"3. 深度调和子节点，渲染视图","zIndex":233}],"html":"初始化","zIndex":227},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e7deffbc-e2ef-4bd0-bda9-831079045071","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7b3d6031-9a64-4fe0-aadd-21e785d8fdb9","children":[],"html":"重新创建workInProgress树，复用当前current树上的alternate，作为新的workInProgress","zIndex":236},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a7be8a43-9b88-4a93-a3d7-fafb1b0a0412","children":[],"html":"渲染完成后，workInProgress树又变成current树","zIndex":237}],"html":"更新","zIndex":235},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f1a63317-5175-43fe-b48b-8e16fe46ed62","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"72aa703a-bb79-4105-b065-37718c88d4b6","children":[],"html":"话剧演出中，演员需要切换不同的场景，以一个一小时话剧来说，在舞台中切换场景，时间来不及。一般是准备两个舞台，切换场景从左边舞台到右边舞台演出","zIndex":239},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d757ed2d-c256-4487-9446-9eba7d267482","children":[],"html":"在计算机图形领域，通过让图形硬件交替读取两套缓冲数据，可以实现画面的无缝切换，减少视觉的抖动甚至卡顿。","zIndex":240},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3688078c-9565-472b-8afa-27112acc9f65","children":[],"html":"react的current树和workInProgress树使用双缓冲模式，可以减少fiber节点的开销，减少性能损耗","zIndex":241}],"html":"双缓冲模式","zIndex":238},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"649c99b6-a975-45d9-ab01-7f888036c8ef","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"59a34e02-3a68-48e1-835c-b6fff0b81cc7","children":[],"html":"React用<span style=\"font-weight:bold;\">JSX</span>描述页面，JSX经过<span style=\"font-weight:bold;\">babel编译</span>为<span style=\"font-weight:bold;\">render function</span>，执行后产生<span style=\"font-weight:bold;\">VDOM</span>，VDOM不是直接渲染的，会先转换为fiber，再进行渲染。<span style=\"font-weight:bold;\">vdom转换为fiber的过程叫reconcile</span>，转换过程会创建DOM，全部转换完成后会一次性commit到DOM。这个reconcile过程不是一次性的，而是可打断的，这就是fiber架构的渲染流程。","zIndex":243}],"html":"React渲染流程","icons":{"flag":0},"zIndex":242}],"html":"Fiber 更新机制","zIndex":226}],"html":"Fiber 架构","collapsed":true,"zIndex":13},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2,"fill":"rgba(0, 0, 0, 0)"},"treeEdge":{"stroke-width":2,"stroke":"#6EC4C4"},"defaultContentStyle":{"color":"#262626"},"id":"3acd34ff-1d5f-48b0-b0bf-0aec3b51f77e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"547c7505-bdf5-40d4-bca0-45e6f92fc22a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2b4e5368-a53f-4794-ab2f-2ca9f0875376","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b8274838-a36d-4dcb-97dc-61659e8f7262","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3936d68e-384a-4e15-bff2-24d651a59059","children":[],"html":"创建dom的性能成本很高，为了保证react作为前端框架的性能","zIndex":19}],"html":"为什么需要节点复用","zIndex":20}],"html":"Diff 算法是在 rerender 时，对比新旧VDOM，以实现<span style=\"font-weight:bold;\">节点复用为目的</span>的一种深度优先遍历(DFS)算法。在react 16以后，diff算法作用在vdom转为fiber的reconcile(调和)阶段，通过两轮遍历的方式，完成新的fiber结构的创建。","zIndex":21},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a08b03a1-278c-4230-9c07-cb5d406d9f28","children":[],"html":"第一次渲染不需要 diff，直接 vdom 转 fiber。再次渲染的时候，会产生新的 vdom，这时候要和之前的 fiber 做下对比，决定怎么产生新的 fiber，对可复用的节点打上修改的标记，剩余的旧节点打上删除标记，新节点打上新增标记。","zIndex":18}],"html":"概念","zIndex":22},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"70060999-9085-4f97-b93d-7a5c325dd2c5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1f14d248-4d6a-4b84-bdd5-4a217bf540ea","children":[],"html":"React 的diff算法是分成两次遍历的","zIndex":24},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3e62fdba-f4cc-4cb4-b279-d29393066830","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c4c9e07a-65ce-4f25-b475-7bc19d1634e1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"facc96b4-2497-4e51-8b6e-b0376a392827","children":[],"html":"可以通过 父 Fiber 的 child 属性拿到，这样第一个节点的老 Fiber 就拿到了，那么第二节点的老 Fiber，很明显可以通过第一个节点的老 Fiber 节点的 sibling 属性拿到，后面的以此类推。","zIndex":30}],"html":"第一个节点的老fiber如何拿到？","zIndex":31},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"937ec42c-2663-4643-a257-0e7d14ebf3df","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a9234111-a219-4ca1-813a-94803deef8cf","children":[],"html":"在循环的新节点虚拟DOM数据的时候，拿到新节点虚拟DOM信息，然后就去和老 Fiber 节点进行比对，如果两个节点相同则创建一个新的 Fiber 节点并复用一些老 Fiber 节点的信息，比如真实 DOM，并给这个新的 Fiber 节点打上一个 Update 的标记，代表这个节点需要更新即可。","zIndex":28}],"html":"如何复用节点，复用了什么？","zIndex":29}],"html":"第一轮遍历：常见情况的比对。一一对比vdom和老的fiber，如果可以复用就打上更新标记，处理下个节点，否则结束遍历。如果所有的新的vdom都处理完了，就把剩下的老的fiber节点删掉。","zIndex":32},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"51192c74-566e-42e4-a831-4903e5223e99","children":[],"html":"如果还有vdom没有处理，就进行第二轮遍历","zIndex":35},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4d6de186-a4a3-4c9d-b871-8f5a6d53ea87","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"88f8f9ff-87d6-4c0d-b24e-ad9c0e7cd79b","children":[],"html":"map结构：一个 老 Fiber 的 key 或老 Fiber 的 index 为 key，Fiber 节点为 value 的 Map，这样查找就是O(1)的复杂度","zIndex":33}],"html":"第二轮遍历：不常见情况的比对。把剩下的老的fiber放到map里，遍历剩下的vdom，从map里查找，如果找到了，就移动过来打上更新标记","zIndex":34},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6c5842c8-4597-462c-93ff-6abd6e99d8e5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a2b92175-6d31-42d9-8b74-c18c165e873f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"80299288-787b-484a-b700-a19bb9ba3952","children":[],"html":"如果是头节点，则把新 Fiber 设置为父 Fiber 的 child 属性的值；<div>如果不是头节点，则把新 Fiber 设置为上一轮循环的创建的 Fiber 节点的 sibing 属性的值；</div><div>更新上一轮 Fiber 变量的值，就是把这一轮的 Fiber 设置成下一轮的 Fiber;</div><div>更新比对的老 Fiber 的值。</div>","zIndex":25}],"html":"每轮循环最后Fiber链表的处理","zIndex":26}],"html":"第二轮遍历完成后，把剩余的老的fiber删掉，剩余的vdom新增","zIndex":27},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5a9b9847-2f61-465f-b141-6d193804883f","children":[],"html":"这样就完成了新的fiber结构的创建，也就是reconcile的过程","zIndex":23}],"html":"如何实现 Diff","zIndex":36},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f646d5e5-20c9-47c6-9825-921c2935d985","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9bc79cbe-3218-409b-b01c-5c78fc3b34ab","children":[],"html":"react diff 是深度优先，有子节点，就遍历子节点，没有子节点，就找兄弟节点，没有兄弟节点，就找叔叔节点，叔叔节点也没有的话，就继续往上找，它爷爷的兄弟，如果一直没找到，就代表所有的更新任务都更新完毕了。","zIndex":16},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bf3ef4b8-6ab3-4715-bd52-0e5953da3f9c","children":[],"html":"这种算法的实现方式是一种混合型的搜索算法","zIndex":15},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c6b6af64-11d4-492a-92d6-0a2ed86cc927","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"89b80441-04af-47db-ab27-3df031def67d","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"be076488-f467-4ecf-a4ff-4c6dea5428ef","children":[{"border":{"shape":"rect","stroke":"#6ec4c4","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"891da0f0-2559-4a62-aecf-7995340b4e12","children":[],"html":"function BFS(入口坐标) {<div>&nbsp; &nbsp; const queue = [] // 初始化队列queue</div><div>&nbsp; &nbsp; // 入口坐标首先入队</div><div>&nbsp; &nbsp; queue.push(入口坐标)</div><div>&nbsp; &nbsp; // 队列不为空，说明没有遍历完全</div><div>&nbsp; &nbsp; while(queue.length) {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; const top = queue[0] // 取出队头元素&nbsp;&nbsp;</div><div>&nbsp; &nbsp; &nbsp; &nbsp; 访问 top // 此处是一些和 top 相关的逻辑，比如记录它对应的信息、检查它的属性等等</div><div>&nbsp; &nbsp; &nbsp; &nbsp; // 注意这里也可以不用 for 循环，视题意而定</div><div>&nbsp; &nbsp; &nbsp; &nbsp; for(检查 top 元素出发能够遍历到的所有元素)  {</div><div>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; queue.push(top能够直接抵达的元素)</div><div>&nbsp; &nbsp; &nbsp; &nbsp; }</div><div>&nbsp; &nbsp; &nbsp; &nbsp; queue.shift() // 访问完毕。将队头元素出队</div><div>&nbsp; &nbsp; }</div><div>}</div>","width":605.0027062566378,"zIndex":246}],"html":"BFS：从起始节点开始，首先遍历当前节点的所有邻居节点，然后再依次遍历邻居节点的邻居节点，以此类推，直到遍历完所有节点。","zIndex":245},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"18c92746-872f-4a5b-9d6e-ab59e2cdf44e","children":[],"html":"DFS：从起始节点开始，首先遍历一个路径上的所有节点，直到到达叶子节点，然后再回溯到上一个分支点，继续遍历下一个分支，以此类推，直到遍历完所有节点。","zIndex":247}],"html":"遍历顺序","zIndex":244},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a567738b-434e-459b-8147-a4a2361b4e98","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"019c2e2d-d251-4c4e-8434-4ba972d60e93","children":[],"html":"BFS：通常使用<span style=\"font-weight:bold;\">队列</span>来存储待遍历的节点，因为它需要按照先进先出的顺序遍历节点。","zIndex":249},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"39622ede-daeb-403f-a572-62fe5adef278","children":[],"html":"DFS：通常使用<span style=\"font-weight:bold;\">栈</span>或递归调用来存储待遍历的节点，因为它需要按照后进先出的顺序遍历节点。","zIndex":250}],"html":"数据结构","zIndex":248},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a84ee0ae-de1f-478d-8dd8-c393e318579c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bf8e0338-b6dc-4453-8cd6-9cd0161af751","children":[],"html":"BFS：在最坏情况下，需要存储图中所有的节点和边，因此空间复杂度较高。","zIndex":252},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"51760510-b8d3-4e2f-bc4a-bb2354724773","children":[],"html":"DFS：在最坏情况下，需要存储整条路径上的所有节点，因此空间复杂度较低。","zIndex":253}],"html":"空间复杂度","zIndex":251},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"099942b9-ac17-4d5c-81c7-c6f89478a5ca","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"162b0f0e-6593-4a44-b75b-f4d4a26c8f48","children":[],"html":"BFS 和 DFS 都需要访问图中的每个节点和每条边，因此它们的时间复杂度都是 O(V + E)，其中 V 是节点数，E 是边数。","zIndex":255}],"html":"时间复杂度","zIndex":254},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7bfba265-2ad3-48d0-ac19-4ee373534b4a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ea85a9ff-1ab1-47b7-b241-6b8dbf4584a8","children":[],"html":"BFS 通常用于寻找最短路径、无权图的最短路径、层序遍历等问题。","zIndex":257},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b62e90fd-0d27-469d-8a14-4e05488d8550","children":[],"html":"DFS 通常用于寻找图中的连通分量、拓扑排序、解决迷宫问题等。","zIndex":258}],"html":"应用场景","zIndex":256}],"html":"BFS和DFS的区别","collapsed":true,"zIndex":14}],"html":"算法及复杂度","zIndex":17}],"html":"Diff 算法","zIndex":37},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"defaultContentStyle":{"color":"#262626"},"id":"f751431d-79c2-48fb-98b3-76ce0fedaf59","children":[],"html":"渲染流程","zIndex":6},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#77C386"},"defaultContentStyle":{"color":"#262626"},"id":"fbf8e89c-2f8e-4af8-9b19-171537ba8fe8","children":[],"html":"React Router","zIndex":4},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E48484"},"defaultContentStyle":{"color":"#262626"},"id":"8275d081-59c9-46d0-ae99-3181a690fe72","children":[],"html":"Redux 工作原理","zIndex":2},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"defaultContentStyle":{"color":"#262626"},"id":"295b0655-7ae4-4d99-b210-5ecdbf0b5bc1","children":[],"html":"生态","zIndex":0}],"layout":{"type":"standard","direction":[1,0]},"zIndex":38}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[580.8662109375,1219.5,1],"width":1601,"height":949},"viewportOption":"adapt","text":"React合成事件React需要合成事件（SyntheticEvent）是为了解决浏览器兼容性问题，提供了一种跨浏览器的事件处理机制。在React中，合成事件是在浏览器原生事件（native event）的基础上构建的，提供了与原生事件相似的API和属性。合成事件特点跨浏览器兼容React合成事件能够屏蔽不同浏览器之间的事件差异，使得开发者可以编写统一的事件处理代码，而不需要考虑浏览器兼容性问题。性能优化使用了事件池技术，通过复用事件对象来减少内存分配和垃圾回收的开销合成嵌套React合成事件支持事件冒泡和捕获，可以在一个组件中注册多个事件处理函数，避免了事件处理函数之间的相互影响。支持事件委托React合成事件支持事件委托，可以在父组件中注册事件处理函数，处理子组件的事件。总结收敛总之，React合成事件是为了提供一种跨浏览器的事件处理机制，同时也为了提高性能和扩展事件处理的功能。React 18 新特性Concurrent Mode（并发模式）CM 本身并不是一个功能，而是一个底层设计，在 React 17 中就可以通过一些试验性的api开启 CMReact 17 和 React 18 的区别就是：从同步不可中断更新变成了异步可中断更新。并发模式可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整，该模式通过使渲染可中断来修复阻塞渲染限制。在 Concurrent 模式中，React 可以同时更新多个状态。开启并发模式并不是开启并发更新只有使用并发特性，才能开始并发更新并发特性startTransition主要为了能在大量的任务下也能保持 UI 响应。这个新的 API 可以通过将特定更新标记为“过渡”来显著改善用户交互，简单来说，就是被 startTransition 回调包裹的 setState 触发的渲染被标记为不紧急渲染，这些渲染可能被其他紧急渲染所抢占。useDeferredValue返回一个延迟响应的值，可以让一个state 延迟生效，只有当前没有紧急更新时，该值才会变为最新值。useDeferredValue 和 startTransition 一样，都是标记了一次非紧急更新。import React, { useState, useEffect, useDeferredValue } from 'react';const App: React.FC = () => {  const [list, setList] = useState<any[]>([]);  useEffect(() => {    setList(new Array(10000).fill(null));  }, []);  // 使用了并发特性，开启并发更新  const deferredList = useDeferredValue(list);  return (    <>      {deferredList.map((_, i) => (        <div key={i}>{i}</div>      ))}    </>  );};export default App;与 startTransition 对比相同：useDeferredValue 本质上和内部实现与 useTransition 一样，都是标记成了延迟更新任务。不同：useTransition 是把更新任务变成了延迟更新任务，而 useDeferredValue 是产生一个新的值，这个值作为延时状态。（一个用来包装方法，一个用来包装值）使用场景一次性渲染10000个标签的时候，页面会阻塞大约0.5秒，造成卡顿，但是如果开启了并发更新，就不会存在这样的问题我们的任务被拆分到每一帧不同的 task 中，JS脚本执行时间大体在5ms左右，这样浏览器就有剩余时间执行样式布局和样式绘制，减少掉帧的可能性Render API为了更好的管理root节点，React 18 引入了一个新的 root API，新的 root API 还支持 new concurrent renderer（并发模式的渲染），它允许你进入concurrent mode（并发模式）。// React 17import React from 'react';import ReactDOM from 'react-dom';import App from './App';const root = document.getElementById('root')!;ReactDOM.render(<App />, root);// React 18import React from 'react';import ReactDOM from 'react-dom/client';import App from './App';const root = document.getElementById('root');ReactDOM.createRoot(root).render(<App />);setState 自动批处理批处理是指为了获得更好的性能，在数据层，将多个状态更新批量处理，合并成一次更新flushSync批处理是一个破坏性改动，如果你想退出批量更新，你可以使用 flushSyncReact 组件返回值在 React 17 中，如果你需要返回一个空组件，React只允许返回null。如果你显式的返回了 undefined，控制台则会在运行时抛出一个错误在 React 18 中，不再检查因返回 undefined 而导致崩溃。既能返回 null，也能返回 undefinedStrict Mode当你使用严格模式时，React 会对每个组件进行两次渲染，以便你观察一些意想不到的结果。在 React 17 中，取消了其中一次渲染的控制台日志，以便让日志更容易阅读。为了解决社区对这个问题的困惑，在 React 18 中，官方取消了这个限制。Suspense 不再需要 fallback 来捕获新的APIuseId支持同一个组件在客户端和服务端生成相同的唯一的 ID，避免 hydration 的不兼容useSyncExternalStore主要用来解决外部数据撕裂问题useSyncExternalStore 能够通过强制同步更新数据让 React 组件在 CM 下安全地有效地读取外接数据源。 在 Concurrent Mode 下，React 一次渲染会分片执行（以 fiber 为单位），中间可能穿插优先级更高的更新。假如在高优先级的更新中改变了公共数据（比如 redux 中的数据），那之前低优先的渲染必须要重新开始执行，否则就会出现前后状态不一致的情况。useInsertionEffect这个 Hooks 只建议 css-in-js 库来使用。 这个 Hooks 执行时机在 DOM 生成之后，useLayoutEffect 之前，它的工作原理大致和 useLayoutEffect 相同，只是此时无法访问 DOM 节点的引用，一般用于提前注入 <style> 脚本Fiber的执行流程React Fiber 的执行流程包括初始化阶段、任务调度阶段、协调阶段（Reconciliation 和 Commit）、完成阶段等，通过优先级调度器、协调算法、diff 算法等来提高 React 应用的性能和响应速度。初始化阶段React Fiber 通过调用 render() 方法来生成虚拟 DOM 树，并将其存储在 Fiber 节点中。在这个阶段，React Fiber 还会创建一些全局变量，如 workInProgressRoot、nextUnitOfWork 等，用于记录当前的工作进度和任务单元。任务调度阶段React Fiber 通过优先级调度器（Priority Scheduler）来决定当前要执行的任务单元。每个任务单元都是一个 Fiber 节点，记录了该任务的类型、状态、子节点等信息。React Fiber 将任务单元按照优先级分为多个批次（Batch），每个批次包含一组任务单元。React Fiber 首先会执行高优先级的批次，然后执行低优先级的批次。协调阶段在每个任务单元执行前，React Fiber 会检查该任务单元是否需要更新。如果需要更新，则会进入协调阶段，根据当前节点和子节点的状态来决定该任务单元的执行方式。协调阶段分为两个步骤：Reconciliation 和 Commit。Reconciliation 阶段React Fiber 通过遍历 Fiber 树来比较新旧虚拟 DOM 的差异，找出需要更新的节点，并标记这些节点为“脏节点”。React Fiber 通过 diff 算法来比较新旧虚拟 DOM 的差异，尽可能地重用已有的节点，从而减少 DOM 操作的次数Commit 阶段完成阶段组件通信父组件向子组件通信props传递子组件向父组件通信回调函数事件冒泡点击子组件的button按钮，事件会冒泡到父组件上const Child = () => {    return <button>点击</button>;};const Parent = () => {    const sayName = name => {        console.log(name);    };    return (        <div onClick={() => sayName('aaa')}>            <Child />        </div>    );};export default Parent;forwardRef + useImperativeHandleforwardRef：用来把ref从子组件传递到父组件。import { useRef } from 'react';import { useEffect } from 'react';import React from 'react';const Guang: React.ForwardRefRenderFunction<HTMLInputElement> = (props, ref) => {  return <div>    <input ref={ref}></input>  </div>}const WrapedGuang = React.forwardRef(Guang);function App() {  const ref = useRef<HTMLInputElement>(null);  useEffect(()=> {    console.log('ref', ref.current)    ref.current?.focus()  }, []);  return (    <div className=\"App\">      <WrapedGuang ref={ref}/>    </div>  );}export default App;useImperativeHandle：不暴露原生标签，而是暴露一些自定义内容它有 3 个参数，第一个是传入的 ref，第二个是返回新的 ref 值的函数，第三个是依赖数组const Guang: React.ForwardRefRenderFunction<RefProps> = (props, ref) => {  const inputRef = useRef<HTMLInputElement>(null);  useImperativeHandle(ref, () => {    return {      aaa() {        inputRef.current?.focus();      }    }  }, [inputRef]);  return <div>    <input ref={inputRef}></input>  </div>}const WrapedGuang = React.forwardRef(Guang);function App() {  const ref = useRef<RefProps>(null);  useEffect(()=> {    console.log('ref', ref.current)    ref.current?.aaa();  }, []);  return (    <div className=\"App\">      <WrapedGuang ref={ref}/>    </div>  );}export default App;兄弟组件通信通过父组件做数据中转，进行状态提升父组件向后代组件通信useContext无关组件通信ReduxJotai：轻量级，基于原子的状态管理库Recoil：Facebook开发的基于原子的状态管理库生命周期挂载constructor 初始化阶段，可以进行state和props的初始化static getDerivedStateFromProps 静态方法，不能获取thisrender 创建虚拟DOM的阶段componentDidMount 第一次渲染后调用，挂载到页面生成真实DOM，可以访问DOM，进行异步请求和定时器、消息订阅更新static getDerivedStateFromPropsshouldComponentUpdate 返回一个布尔值，默认返回true，可以通过这个生命周期钩子进行性能优化，确认不需要更新组件时调用render 更新虚拟DOMgetSnapShotBeforeUpdate 获取更新前的状态componentDidUpdate 在组件完成更新后调用，更新挂载后生成真实DOM卸载componentWillUnmount 组件从DOM中被移除的时候调用，通常在这个阶段清除副作用，比如定时器、事件监听等错误捕获static getDerivedStateFromError 在errorBoundary中使用componentDidCatchrender是class组件中唯一必须实现的方法React Hooks基础React 16.8推出的React Hooks，解决函数组件不能保存状态和执行副作用的问题，基本上可以替代之前类组件的开发方式。函数组件和类组件的区别声明constructor手动绑定this生命周期钩子继承class面向对象(封装和继承) vs 函数式编程思想优缺点优点告别难以理解的class组件解决业务逻辑难以拆分的问题状态逻辑复用变得简单函数式编程的设计理念更适合react局限不能完全提供类组件能力错误边界 ErrorBoundary组件还是需要用到类组件和componentDidCatch和getDerivedStateFromError来实现hooks 在使用层面有严格的规则约束Hooks 有哪些useEffect 和 useLayoutEffect 的区别两个hook在使用上类似，都是接受一个回调函数和依赖数组，用来执行副作用区别是 useLayoutEffect 的渲染是同步的，会造成阻塞，useEffect 的渲染是异步的，一般推荐使用useEffect。如果使用useEffect 出现严重的闪屏问题，可以采用useLayoutEffect替代为什么会出现闪屏问题js执行和渲染是阻塞的，useEffect 的 effect 函数会在操作 dom 之后异步执行异步执行就是用 setTimeout、Promise.then 等 api 包裹执行的逻辑这些逻辑会以单独的宏任务或者微任务的形式存在，然后进入 Event Loop 调度执行打开 Permormance 工具，可以看到 Event Loop 的详情，渲染的间隔是固定的，而 js 的任务在这些渲染的间隔中执行所以异步执行的 effect 逻辑就有两种可能有可能在下次渲染之前，就能执行完这个 effect也有可能下次渲染前，没时间执行这个 effect，所以就在渲染之后执行了这样就导致有的时候页面会出现闪动，因为第一次渲染的时候的 state 是之前的值，渲染完之后执行 effect 改了 state，再次渲染就是新的值了一般这样也没啥问题，但如果你遇到这种情况，不想闪动那一下，就用 useLayoutEffect。它和 useEffect 的区别是它的 effect 执行是同步的，会等effect逻辑执行完再渲染useRef一般用来保存dom的引用，也可以存储其他数据，但是不会触发渲染useRef一般用来存一些不用于渲染的内容自定义Hookhooks 原理React 性能优化减少重复渲染React.memo、useMemo、useCallback 搭配使用，减少重复渲染组件懒加载React.lazy + Suspense开启并发模式页面节点多时，使用 useDeferredValue 或者 useTransition 开启并发模式，实现分片渲染 使用Fragment遍历时使用key业务优化虚拟长列表频繁操作并调用接口的地方采用防抖使用 useContext 避免不需要的重复渲染拆分context使用其他状态管理库JSXReact 的语法糖，可以在html写js代码，在react17以前会被babel编译成React.createElement方法，react17以后会通过编译器babel/typescript转换为_jsx方法为什么React自定义组件首字母要大写babel编译jsx时，小写字母会被当成字符串，大写字母开头会被当成变量传递给React.createElementReact组件为什么不能返回多个元素React组件最后会编译为render函数，函数的返回值只能是1个，如果不用单独的根节点包裹，就会并列返回多个值，这在js中是不允许的react的虚拟DOM是一个树状结构，树的根节点只能是1个，如果有多个根节点，无法确认是在哪棵树上进行更新React组件怎样可以返回多个组件：React.FragmentReact中元素和组件的区别react组件有类组件、函数组件react元素是通过jsx创建的const element = <div className=\"element\">我是元素</div> React 设计思想组件化数据驱动视图虚拟DOMFiber 架构Fiber 实现了一个基于优先级和 requestIdleCallback (执行的前提条件是当前浏览器处于空闲状态) 的一个循环 任务调度 算法, 它在渲染虚拟 DOM、 diff 阶段将任务拆分为多个小任务、这样的话就可以随时进行中止和恢复、同时又根据每个任务的优先级来执行任务特点可中断可恢复任务优先级调度分片渲染fiber解决了什么问题React16 以前递归渲染不能中断，页面层级深会存在渲染速度慢的问题虚拟dom树结构，树结构只能找到子节点，中断后无法找到中断位置采用边diff边渲染机制，中断了已经渲染完成的部分无法回退fiber实现了渲染可中断，可恢复，并且根据优先级进行任务调度渲染，优化了渲染性能问题把递归渲染改造成 render（reconcile + schdule） + commit 两个阶段的渲染可中断、可恢复如何实现何时中断当react更新时间超过1帧时，会产生视觉卡顿的效果，因此我们可以通过fiber把浏览器渲染过程分段执行，每执行一会就让出主线程控制权，执行优先级更高的任务通过requestIdleCallback方法来实现reconcile 如何实现中断将递归变为循环如何恢复引入了fiber数据结构，它是一个链表结构，返回了return、children、siblings，分别代表父fiber，子fiber和兄弟fiber，实现了可中断、可恢复Fiber 更新机制初始化1. 创建fiberRoot（React根元素）和rootFiber(通过ReactDOM.render或者ReactDOM.createRoot创建出来的)2. 进入beginWorkworkInProgress:正在内存中构建的fiber树叫workInProgress fiber，在第一次更新时，所有的更新都发生在workInProgress树，在第一次更新后，workInProgress树上的状态是最新状态，它会替换current树current:正在视图层渲染的树叫current fiber树currentFiber.alternate = workInProgressFiberworkInProgressFiber.alternate = currentFiber3. 深度调和子节点，渲染视图在新建的alternate树上，完成整个子节点的遍历，包括fiber的创建，最后会以workInProgress树最为最新的渲染树，fiberRoot的current指针指向workInProgress使其变成current fiber，完成初始化流程更新重新创建workInProgress树，复用当前current树上的alternate，作为新的workInProgress渲染完成后，workInProgress树又变成current树双缓冲模式话剧演出中，演员需要切换不同的场景，以一个一小时话剧来说，在舞台中切换场景，时间来不及。一般是准备两个舞台，切换场景从左边舞台到右边舞台演出在计算机图形领域，通过让图形硬件交替读取两套缓冲数据，可以实现画面的无缝切换，减少视觉的抖动甚至卡顿。react的current树和workInProgress树使用双缓冲模式，可以减少fiber节点的开销，减少性能损耗React渲染流程React用JSX描述页面，JSX经过babel编译为render function，执行后产生VDOM，VDOM不是直接渲染的，会先转换为fiber，再进行渲染。vdom转换为fiber的过程叫reconcile，转换过程会创建DOM，全部转换完成后会一次性commit到DOM。这个reconcile过程不是一次性的，而是可打断的，这就是fiber架构的渲染流程。Diff 算法概念Diff 算法是在 rerender 时，对比新旧VDOM，以实现节点复用为目的的一种深度优先遍历(DFS)算法。在react 16以后，diff算法作用在vdom转为fiber的reconcile(调和)阶段，通过两轮遍历的方式，完成新的fiber结构的创建。为什么需要节点复用创建dom的性能成本很高，为了保证react作为前端框架的性能第一次渲染不需要 diff，直接 vdom 转 fiber。再次渲染的时候，会产生新的 vdom，这时候要和之前的 fiber 做下对比，决定怎么产生新的 fiber，对可复用的节点打上修改的标记，剩余的旧节点打上删除标记，新节点打上新增标记。如何实现 DiffReact 的diff算法是分成两次遍历的第一轮遍历：常见情况的比对。一一对比vdom和老的fiber，如果可以复用就打上更新标记，处理下个节点，否则结束遍历。如果所有的新的vdom都处理完了，就把剩下的老的fiber节点删掉。第一个节点的老fiber如何拿到？可以通过 父 Fiber 的 child 属性拿到，这样第一个节点的老 Fiber 就拿到了，那么第二节点的老 Fiber，很明显可以通过第一个节点的老 Fiber 节点的 sibling 属性拿到，后面的以此类推。如何复用节点，复用了什么？在循环的新节点虚拟DOM数据的时候，拿到新节点虚拟DOM信息，然后就去和老 Fiber 节点进行比对，如果两个节点相同则创建一个新的 Fiber 节点并复用一些老 Fiber 节点的信息，比如真实 DOM，并给这个新的 Fiber 节点打上一个 Update 的标记，代表这个节点需要更新即可。如果还有vdom没有处理，就进行第二轮遍历第二轮遍历：不常见情况的比对。把剩下的老的fiber放到map里，遍历剩下的vdom，从map里查找，如果找到了，就移动过来打上更新标记map结构：一个 老 Fiber 的 key 或老 Fiber 的 index 为 key，Fiber 节点为 value 的 Map，这样查找就是O(1)的复杂度第二轮遍历完成后，把剩余的老的fiber删掉，剩余的vdom新增每轮循环最后Fiber链表的处理如果是头节点，则把新 Fiber 设置为父 Fiber 的 child 属性的值；如果不是头节点，则把新 Fiber 设置为上一轮循环的创建的 Fiber 节点的 sibing 属性的值；更新上一轮 Fiber 变量的值，就是把这一轮的 Fiber 设置成下一轮的 Fiber;更新比对的老 Fiber 的值。这样就完成了新的fiber结构的创建，也就是reconcile的过程算法及复杂度react diff 是深度优先，有子节点，就遍历子节点，没有子节点，就找兄弟节点，没有兄弟节点，就找叔叔节点，叔叔节点也没有的话，就继续往上找，它爷爷的兄弟，如果一直没找到，就代表所有的更新任务都更新完毕了。这种算法的实现方式是一种混合型的搜索算法BFS和DFS的区别遍历顺序BFS：从起始节点开始，首先遍历当前节点的所有邻居节点，然后再依次遍历邻居节点的邻居节点，以此类推，直到遍历完所有节点。function BFS(入口坐标) {    const queue = [] // 初始化队列queue    // 入口坐标首先入队    queue.push(入口坐标)    // 队列不为空，说明没有遍历完全    while(queue.length) {        const top = queue[0] // 取出队头元素          访问 top // 此处是一些和 top 相关的逻辑，比如记录它对应的信息、检查它的属性等等        // 注意这里也可以不用 for 循环，视题意而定        for(检查 top 元素出发能够遍历到的所有元素)  {            queue.push(top能够直接抵达的元素)        }        queue.shift() // 访问完毕。将队头元素出队    }}DFS：从起始节点开始，首先遍历一个路径上的所有节点，直到到达叶子节点，然后再回溯到上一个分支点，继续遍历下一个分支，以此类推，直到遍历完所有节点。数据结构BFS：通常使用队列来存储待遍历的节点，因为它需要按照先进先出的顺序遍历节点。DFS：通常使用栈或递归调用来存储待遍历的节点，因为它需要按照后进先出的顺序遍历节点。空间复杂度BFS：在最坏情况下，需要存储图中所有的节点和边，因此空间复杂度较高。DFS：在最坏情况下，需要存储整条路径上的所有节点，因此空间复杂度较低。时间复杂度BFS 和 DFS 都需要访问图中的每个节点和每条边，因此它们的时间复杂度都是 O(V + E)，其中 V 是节点数，E 是边数。应用场景BFS 通常用于寻找最短路径、无权图的最短路径、层序遍历等问题。DFS 通常用于寻找图中的连通分量、拓扑排序、解决迷宫问题等。渲染流程React RouterRedux 工作原理生态","graphicsBBox":{"x":998.3662109375,"y":676,"width":1728,"height":1896}}