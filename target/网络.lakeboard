{"format":"lakeboard","type":"Board","version":"1.0","diagramData":{"head":{"version":"2.0.0","theme":{"name":"default"},"rough":{"name":"default"}},"body":[{"id":"0042dae0-e678-46dc-a77c-60caf01cd152","x":471.3662298828126,"y":2701.1899169979697,"html":"网络","type":"mindmap","defaultContentStyle":{"color":"rgb(38, 38, 38)"},"border":{"fill":"#F5F5F5","shape":"capsule","stroke":"transparent","stroke-width":2},"children":[{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#FAEDF6","stroke":"transparent"},"treeEdge":{"stroke-width":2,"stroke":"#E482D4"},"id":"b6f605a8-68a7-4df1-a8c9-0574087400ba","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7cb5d89e-7c1f-4190-bdbc-37e8b2dda7f5","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fe8059d9-96a0-44f5-89cd-751d184db0da","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bc177032-fbc3-4e3d-8b84-2ceae49c927c","children":[],"html":"输入URL中协议或主机名不合法，将输入内容传递给搜索引擎","zIndex":86},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"26655415-519c-41f1-b95c-ba14e0c8affb","children":[],"html":"解析没有问题，浏览器检查url中是否有非法字符，如果有，进行转义","zIndex":87}],"html":"解析URL","layout":{"quadrant":1},"zIndex":85},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9c2bc4a9-7bd2-448e-9807-a2683453ae70","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4fa2c422-e2fd-4dcd-af2a-c6c8be0c87b4","children":[],"html":"浏览器判断请求资源在缓存中，并且没有失效，如果是就直接使用，否则向服务器发起新的请求","zIndex":89}],"html":"缓存判断","layout":{"quadrant":1},"zIndex":88},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"417b228a-4b8f-48e6-9d26-88b67f1a8c19","children":[],"html":"DNS解析","layout":{"quadrant":1},"zIndex":90},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"726fceea-f76e-4289-a721-043df646bc3c","children":[],"html":"获取MAC地址","layout":{"quadrant":1},"zIndex":91},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"40d44e5a-5b87-4ddd-b924-8731f918c6df","children":[],"html":"TCP三次握手","layout":{"quadrant":1},"zIndex":92},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"355b838f-4047-41b2-b139-713e26dc05b7","children":[],"html":"HTTPS握手","layout":{"quadrant":1},"zIndex":93},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b9d840d6-2ca6-4055-9a19-8fb5fbeb9f7f","children":[],"html":"返回数据","layout":{"quadrant":1},"zIndex":94},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"de19a1f6-71f6-453f-a92b-24da45711cef","children":[],"html":"页面渲染","layout":{"quadrant":1},"zIndex":95},{"border":{"shape":"rect","stroke":"transparent","fill":"#FAEDF6","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3114d6d6-7578-448b-8eee-f5fe95173fe6","children":[],"html":"TCP四次挥手","layout":{"quadrant":1},"zIndex":96}],"html":"详细版本","collapsed":true,"zIndex":27},{"border":{"shape":"rect","stroke":"transparent","fill":"#fde6d3","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6ee4074b-4298-4f1f-b9f2-2e4c28ba6390","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#fde6d3","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fbc075fd-58a6-420e-9aa2-4bf81248326c","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"92388750-fcf6-48c8-8c86-eea7e6304d2b","children":[],"html":"当用户在浏览器中输入网址后，浏览器首先会解析网址中的域名部分。","zIndex":6},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d35fa41d-abf5-44d1-9796-0b3c4235a0e7","children":[],"html":"浏览器会向本地 DNS 缓存或者 DNS 服务器发送请求，获取与域名对应的 IP 地址。","zIndex":5}],"html":"1. DNS解析","zIndex":7},{"border":{"shape":"rect","stroke":"transparent","fill":"#fde6d3","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2d67253a-20c1-416e-a770-6d38fb80f8c2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"84b54e7d-3761-4db5-8a80-d17957c9c8aa","children":[],"html":"通过 DNS 解析得到正确的 IP 地址后，浏览器会与服务器建立 TCP 连接。","zIndex":9},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dbe6e3f8-8954-4a6c-a265-fac6aa02be45","children":[],"html":"浏览器会通过三次握手与服务器进行通信，确保双方都能够正常发送和接收数据。","zIndex":8}],"html":"2. 建立TCP连接","zIndex":10},{"border":{"shape":"rect","stroke":"transparent","fill":"#fde6d3","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"08a944ab-4049-4a0e-a7ba-fd66a26e6a77","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"399ffa02-eae6-4369-8f85-41d9d8ec273f","children":[],"html":"一旦建立了 TCP 连接，浏览器就会向服务器发送 HTTP 请求。","zIndex":15},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"912f74e9-f74c-4f02-a67c-a360ab17d6e6","children":[],"html":"请求中包含了请求方式（GET、POST 等）、请求头（User-Agent、Cookies 等）和请求体（POST 请求才有）等信息。","zIndex":14}],"html":"3. 发送HTTP请求","zIndex":16},{"border":{"shape":"rect","stroke":"transparent","fill":"#fde6d3","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"165ccfee-eb35-42d0-b698-f5f3221802d6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f31591c0-87ca-4d0c-8754-17852d089333","children":[],"html":"服务器接收到浏览器的请求后，会根据请求的内容进行处理，并生成相应的响应。","zIndex":24},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6c776aef-737b-462b-ac6d-30872b25cf3c","children":[],"html":"响应包括状态码（200 表示成功、404 表示未找到等）、响应头（Content-Type、Cache-Control 等）和响应体（HTML、CSS、JavaScript 等）。","zIndex":23}],"html":"4. 服务器响应","zIndex":25},{"border":{"shape":"rect","stroke":"transparent","fill":"#fde6d3","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"09c9fcd0-3294-4f5b-a73c-172790d2c27b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1c31ecf5-394f-429b-9600-43e24c8db670","children":[],"html":"<div>浏览器收到服务器的响应后，开始解析响应内容并进行页面渲染。</div>","zIndex":18},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"41170011-12db-433c-8ce1-3e8f0703dd99","children":[],"html":"首先，浏览器会解析 HTML，构建 DOM 树（文档对象模型）。","zIndex":20},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e26f0eb6-84ab-456a-918f-97d6ab214df8","children":[],"html":"然后，浏览器会解析 CSS，构建 CSSOM 树（CSS 对象模型）。","zIndex":21},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"759fb412-9d0a-4d1f-9a2b-16b73d54c8c1","children":[],"html":"接下来，浏览器将 DOM 树和 CSSOM 树结合，生成渲染树（Render Tree）。","zIndex":19},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"05b1d100-73c3-4337-a0c0-9b95b6c1081a","children":[],"html":"最后，浏览器根据渲染树进行布局（Layout）和绘制（Painting），将页面内容显示在用户的屏幕上。","zIndex":17}],"html":"5. 页面渲染","zIndex":22},{"border":{"shape":"rect","stroke":"transparent","fill":"#fde6d3","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"297dae95-6339-43e6-89bf-8e4c4ff8563e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"57b3d000-a2f9-43c0-a0c2-ba24fa714775","children":[],"html":"在页面渲染的过程中，如果遇到外部资源（例如图片、样式表、脚本等），浏览器会根据需要发送额外的请求去加载这些资源。","zIndex":12},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fb833024-804e-4712-8e4c-1f56ab6e498a","children":[],"html":"这些资源的加载过程类似于前面提到的发送 HTTP 请求和服务器响应的过程。","zIndex":11}],"html":"6. 加载资源","zIndex":13},{"border":{"shape":"rect","stroke":"transparent","fill":"#fde6d3","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ab7801e5-bc12-4e20-931b-d1c37d450520","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b04df131-4846-49c2-a29a-219209d22246","children":[],"html":"当页面渲染完成后，用户可以与页面进行交互。","zIndex":2},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b8e6985d-a11b-4e92-987d-144c8179f1ee","children":[],"html":"浏览器会监听用户的操作（例如点击、滚动、键盘输入等），并相应地处理这些操作。","zIndex":3},{"border":{"shape":"rect","stroke":"transparent","fill":"#f9f1df","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"24b11182-6d05-46e4-9fd4-b35814efec41","children":[],"html":"如果有 JavaScript 脚本，浏览器会执行这些脚本以实现页面的动态效果和交互功能。","zIndex":1}],"html":"7. 页面交互","zIndex":4}],"html":"精简版本","zIndex":26}],"html":"从输入网址到页面加载的整个过程","zIndex":28},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#A287E1"},"defaultContentStyle":{"color":"#262626"},"id":"eab672d7-05a9-426e-876e-2b71b81a1052","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a886dceb-6245-425f-9241-bd386cbd7511","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"849a307a-276f-49d5-ac4f-046376bcc5bc","children":[],"html":"刚开始客户端处于 init 的状态，服务端处于 listen 状态","layout":{"quadrant":1},"zIndex":97},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c685975d-cfd6-4eca-a351-8ad0efec4e35","children":[],"html":"第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。","layout":{"quadrant":1},"zIndex":98},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6816b9d8-5c8e-498e-9e73-e3a9efe7668d","children":[],"html":"第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。","zIndex":99},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e52c64db-58da-431c-8ca0-b29a35cf0fb6","children":[],"html":"第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。","zIndex":100},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7d02494c-cb0e-48b9-ab27-d8878b0dfd03","children":[],"html":"服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接","zIndex":101},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"61b0c951-b42c-46ea-ae25-857c42f94270","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fb67f115-20e3-488a-a10d-aa93726364b4","children":[],"html":"为了防止已失效的请求报文突然又恢复引起的请求错误，三次握手本质上是为了解决网络信道不可靠的问题","zIndex":103},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5b982c3b-b447-4e27-9fc0-35571f76fa6d","children":[],"html":"例如：客户端发送SYN包请求建立连接，但是由于网络阻塞没有到达服务端，客户端重发SYN包，服务端接收到SYN包，向客户端发送SYN+ACK包，双方建立连接，但是客户端第一个发送的SYN包突然恢复，送达服务端，服务端会认为这是客户端发起的一个新的连接，从而进入等待数据状态。服务端认为是两个连接，而客户端认为是一个连接，造成状态不一致。<div>如果是三次握手，服务端收不到最后的ACK包，就不会认为建立连接成功</div>","zIndex":104}],"html":"为什么两次握手不可以","zIndex":102},{"start":0,"end":4,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\">&#8203;<br></div>","defaultContentStyle":{"color":"#262626"},"id":"3db9b00e-f05b-42b3-a3ac-dca0d9233156","children":[],"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1712572103590-ab49baf8-561b-4f7b-b2ac-8ea370231f47.png","naturalWidth":852,"naturalHeight":807,"uploadInfo":{"hash":"c01748753a7f7675b772ed325f75d00b646a76f46cdc9a980c215fc34d8c4fa4","fileName":"yuque_diagram.png","fileType":"image/png","fileSize":311152,"localTempSrc":"blob:https://www.yuque.com/71a4d2d8-3260-47dc-8746-cb7601082436","state":-2},"width":480,"height":454.6478873239436},"zIndex":105}],"html":"三次握手","collapsed":true,"zIndex":34},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f1f2b3f6-9b99-450c-943d-ed5be7194367","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"aa4bd252-292e-4a89-bb0c-5ac26c7da9b1","children":[],"html":"处于连接的客户端和服务端都可以发起关闭连接请求，假如客户端发起连接关闭请求","zIndex":106},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"02243ceb-871c-4606-a04d-126ec214238a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e57b569e-4f16-4baa-913a-71a6ec7ea150","children":[],"html":"第一次挥手","zIndex":108}],"html":"客户端向服务端发送一个FIN包，表示要关闭连接，自己进入终止等待1状态","layout":{"quadrant":1},"zIndex":107},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"da004d17-bec9-42b5-b9b6-51537f02baa5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9d050b22-e855-44c3-81f6-f1f7fef13da0","children":[],"html":"第二次挥手","zIndex":110}],"html":"服务端收到FIN包，发送一个ACK包，表示自己进入关闭等待状态，客户端进入终止等待2状态","zIndex":109},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"18e31b9e-d899-48a1-a6c9-dbcfb47beea4","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ee0e2cc9-48fa-49f6-8c2b-dff2ffe7601d","children":[],"html":"第三次挥手","zIndex":112}],"html":"服务端此时还可以发送未发送的数据，客户端还可以接收数据。服务端发送完数据后，发送一个FIN包，进入最后确认状态。","zIndex":111},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"940b05e7-5ace-48d9-bae2-705de1064190","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9607eccc-ed89-489b-a480-5dfffe8fb3f9","children":[],"html":"第四次挥手","zIndex":114}],"html":"客户端收到后，回复ACK包，进入超时等待状态，经过超时时间后关闭连接；服务端收到ACK后立即关闭连接。","zIndex":113},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"82167587-de5a-49d2-ab77-9d5124445f8e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0d4674e6-2290-440f-a51e-3e7eb89234d3","children":[],"html":"确保对方已收到ACK包。假设客户端发送完最后一包ACK包后就释放了连接，一旦ACK在网络中丢失，服务端将一直停留在最后确认状态。如果客户端进行超时等待过程中，服务端没有收到ACK包，会重发FIN包，客户端会响应FIN包重发ACK包，并刷新超时等待时间","zIndex":116},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"64550a8b-890a-4b77-9b5f-6878df179576","children":[],"html":"为了保证在不可靠的网络中，进行可靠的断开确认","zIndex":117}],"html":"为什么要设置超时等待时间","zIndex":115},{"start":0,"end":4,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\"><span style></span></div>","defaultContentStyle":{"color":"#262626"},"id":"8f075704-69f0-4f39-8fd9-0c7992e60a3c","children":[],"height":361.5510031012489,"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1712572156142-eea4276f-ab43-4b16-a566-50fd57a896d2.png","naturalWidth":1375,"naturalHeight":720,"uploadInfo":{"hash":"57b27a0c23dcf4c56921024385d42d59c8fcbb60f7ffc720d444e6c213fa7f26","fileName":"yuque_diagram (2).png","fileType":"image/png","fileSize":493457,"localTempSrc":"blob:https://www.yuque.com/e82b5608-fa9b-4cdf-a2b9-f490ccb4d961","state":-2},"width":651.2074917945324,"height":340.9959229760461},"width":667.2074917945324,"zIndex":118}],"html":"四次挥手","collapsed":true,"zIndex":36},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ce02d684-d7f0-41a4-b7a7-b2bb3d63757d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c768ece2-9cca-40e2-a248-ff2e567f08cb","children":[],"html":"两者都是传输层协议，最大的区别：一个基于连接，一个基于非连接","zIndex":119},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e1645cbb-d1f4-4f64-8a59-047f27d3a2ee","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a4cedf13-871d-45bd-aa52-a10dbfc6140d","children":[],"html":"传输稳定可靠，适合对网络通讯质量要求较高的场景，如传输文件，浏览网页","zIndex":121},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d1653375-b088-4fb6-8ce8-cfa0f934af6c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"24f55e34-808d-4099-aac3-ce88eb8d78d4","children":[],"html":"面向连接：双方传输数据前，通过三次握手建立通道，四次挥手结束销毁通道","zIndex":123},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"50d9b5c9-b66e-48b8-ab77-7b8f00bbb162","children":[],"html":"每一个TCP连接只能有两个端点，只能点对点","zIndex":124},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"59cc2a95-34c8-45d6-8376-b00b4e632218","children":[],"html":"提供可靠的传输服务，传送数据无差错，不丢失，不重复，按顺序到达","zIndex":125},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"03819d65-997b-45e7-8211-194b2bcbc049","children":[],"html":"TCP提供全双工通信","zIndex":126},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2a94e58e-2f2c-42e9-a661-c364966cf213","children":[],"html":"面向字节流","zIndex":127}],"html":"特点","zIndex":122}],"html":"TCP","zIndex":120},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c718861c-f15e-46b5-be08-3520c482ad94","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"63a6e4ee-7f7b-49b9-9ca1-8ca2214f1e33","children":[],"html":"发送数据就是简单封装数据包，然后从网卡发出去，数据包之间并没有状态上的联系","zIndex":129},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1dfbf720-38b5-420e-87d2-bc41790dbe31","children":[],"html":"优点：传输速度快，性能损耗少、CPU和内存资源占用少","zIndex":130},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cc7b5306-0c12-4859-bca6-3bafb3269fda","children":[],"html":"缺点：丢包问题、传输稳定性差","zIndex":131},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4d70cb03-ac97-460f-8515-b3e3e5986950","children":[],"html":"适用于对实时性要求较高，但是对少量丢包没有太大要求的场景，如域名查询、语音通话、视频直播、隧道网络","zIndex":132}],"html":"UDP","layout":{"quadrant":1},"zIndex":128},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c95d51f1-4876-4f60-8ffb-87d2aee197b8","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"94f2f360-f040-4545-8d03-8d7c2fa25d72","children":[],"html":"TCP是可靠传输,UDP是不可靠传输","zIndex":134},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"415b5adf-08f8-464b-be3b-9a6d6384fa11","children":[],"html":"TCP面向连接,UDP无连接","zIndex":135},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"883fa434-559e-4f13-89ef-9d4bd11b0bc7","children":[],"html":"TCP传输数据有序,UDP不保证数据的有序性","zIndex":136},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"39678c8d-3185-438d-b926-b24bfb39befc","children":[],"html":"TCP不保存数据边界,UDP保留数据边界","zIndex":137},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"56141fbc-ced4-4148-9bde-057bdd4e494c","children":[],"html":"TCP传输速度相对UDP较慢","zIndex":138},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6934e82a-0dcf-4b0c-a213-c2ca8a191be4","children":[],"html":"TCP有流量控制和拥塞控制,UDP没有","zIndex":139},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2d4188f1-6154-41e1-925b-f0a7f612d554","children":[],"html":"TCP是重量级协议,UDP是轻量级协议","zIndex":140},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6765fc97-0ab3-4e63-9125-e603d35ac127","children":[],"html":"TCP首部较长２０字节,UDP首部较短８字节","zIndex":141}],"html":"区别","zIndex":133},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4e8f5383-d1e3-4f44-8371-feee51a5acf5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c4aeec6b-0ce5-48d7-9c5b-3947f920e1b6","children":[],"html":"HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议","zIndex":143}],"html":"基于TCP和UDP的协议","zIndex":142}],"html":"TCP 和 UPD 的区别","collapsed":true,"zIndex":37},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c2b50125-2926-47ac-be78-0981803da160","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"34ccf0bf-72fe-48ce-bc33-94cfaf5417fc","children":[],"html":"TCP为每一个连接建立一个发送缓冲区，建立连接的第一个序列号为0，后面每个字节的序列号增加1","zIndex":144},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3a3e212a-1567-4b13-accf-e1003147e933","children":[],"html":"发送数据时，从发送缓冲区取一部分数据组成发送报文，在其TCP协议中会附带序列号和长度","zIndex":145},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c1cbb9cd-0b32-4253-b43a-f1470b92e227","children":[],"html":"接收端在收到数据后，需要回复确认报文，确认报文中的ACK=序列号+长度，也就是下一包数据的起始序列号","zIndex":146},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e6b55fbe-098c-41b4-b039-66a92c11cf78","children":[],"html":"这样一问一答的发送方式，能够使发送端确认发送的数据，已经被对方收到，发送端也可以一次发送连续的多包数据，接收端只需要回复一次ACK就可以了","zIndex":147},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2165300f-ceda-40ac-a415-ef396fe9c16b","children":[],"html":"这样发送端可以把待发送的数据分割成一系列的碎片发送到对端；对端根据序列号和长度，在接收后重构出来完整的数据","zIndex":148},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c3fcc5e6-f0b0-4fab-b595-d583e5a54711","children":[],"html":"假设其中丢失了某些数据包，接收端可以要求发送端重传，例如丢失了100-199这100个字节，接收端可以向发送端发送ACK=100的报文，发送端收到后重传这一包数据，接收端进行补齐","zIndex":149},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"171d6011-9a79-4171-a129-be66d22a68aa","children":[],"html":"以上不区分客户端和服务端，TCP连接是全双工的，两端都采用上述机制","zIndex":150},{"start":0,"end":6,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\"><span style></span></div>","defaultContentStyle":{"color":"#262626"},"id":"77f2134d-8ef0-4d65-9cc4-3448656e486e","children":[],"height":534.1569582149202,"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1712572197819-0519eae4-7e2c-4940-994d-8d105b35fa1b.png","naturalWidth":852,"naturalHeight":565,"uploadInfo":{"hash":"40558c38bff3cb8c94e206f6150106c66f819bc4ba482842d308cd638cdbb1b7","fileName":"yuque_diagram (1).png","fileType":"image/png","fileSize":321929,"localTempSrc":"blob:https://www.yuque.com/b9420968-7795-4ebc-872d-c849b7d0232c","state":-2},"width":781.3623511488709,"height":518.1569582149202},"width":810.9175340601573,"zIndex":151}],"html":"TCP 如何处理丢包和乱序问题","collapsed":true,"zIndex":35},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"11d1d903-65f4-4847-9f01-14e141d81555","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"150f4347-6263-46c1-b3c0-623a6ceb1afa","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"51f55502-7702-4f72-b8a1-b8794a612930","children":[],"html":"TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。","zIndex":153}],"html":"TCP 重传机制","layout":{"quadrant":1},"zIndex":152},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d282f564-4cb8-424f-871c-79ac510c8240","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ca4a4a5d-65fe-45b9-99fc-68babf0b56ca","children":[],"html":"一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。","zIndex":155}],"html":"TCP 流量控制机制","layout":{"quadrant":1},"zIndex":154},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"24ecbcbf-e2ae-4116-a7bd-79a50d8553b4","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"05879249-227e-4996-9412-50b1a05936fb","children":[],"html":"TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。","zIndex":157}],"html":"TCP 可靠传输机制","layout":{"quadrant":1},"zIndex":156}],"html":"其他","collapsed":true,"zIndex":33}],"html":"TCP 和 UDP","layout":{"quadrant":1},"zIndex":38},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"472a235b-9f80-4b69-b26a-9f3599f3684a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"40b28742-2ce5-4597-ab54-9410a096baa0","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"33466482-7ebc-48ff-9b57-c7efbb223ce5","children":[],"html":"<span style=\"font-weight:bold;\">连接方面</span>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。","zIndex":42},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ad97b1b0-e6ff-4e8f-a193-1bf3dfad3389","children":[],"html":"<span style=\"font-weight:bold;\">资源请求方面</span>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。","zIndex":44},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7a58f85b-b424-4931-9ae5-9ce814d2c384","children":[],"html":"<span style=\"font-weight:bold;\">缓存方面</span>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。","zIndex":43},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6cb90c8c-f8fe-42f2-9ea4-fdb7ad649d93","children":[],"html":"http1.1 中新增了<span style=\"font-weight:bold;\"> host 字段</span>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。","zIndex":41},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"15ed452d-1530-4857-a00d-d867fbc7a888","children":[],"html":"http1.1 相对于 http1.0 还新增了很多<span style=\"font-weight:bold;\">请求方法</span>，如 PUT、HEAD、OPTIONS 等。","zIndex":40}],"html":"HTTP1.0 和 HTTP 1.1的区别","zIndex":45},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5ac09a9f-b3dd-4fcf-aeba-88161b7f8f84","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"abe9d070-40e0-478b-994a-a117969bf227","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c6472a36-5004-4faa-89d5-6f2b8fdbe648","children":[],"html":"HTTP/2 允许在一个 TCP 连接上同时发送多个请求和响应，消除了 HTTP/1.1 中的串行请求(队头堵塞)问题，提高了网络利用率","zIndex":159}],"html":"多路复用","layout":{"quadrant":1},"zIndex":158},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fbe95386-a650-4ce1-9c8a-b33f86e4a599","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3180f513-d2df-4473-b5fe-6cea019db395","children":[],"html":"HTTP/2 使用二进制格式而不是文本格式传输数据，减少了传输的开销，并且更容易进行解析和处理。","zIndex":161},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c8633d28-e2bb-40ae-8972-0c97613df445","children":[],"html":"在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。","zIndex":162}],"html":"二进制协议","zIndex":160},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"086a454d-2113-43da-b2bc-3945a2140d3d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4a705303-51cd-4d4e-a599-9306fc918026","children":[],"html":"HTTP/2 使用 HPACK 算法对首部进行压缩，减少了首部的大小，降低了网络延迟和带宽消耗；","zIndex":164},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"83297e0e-3e93-4b1f-9d6b-b8f9590a4c81","children":[],"html":"另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了","zIndex":165},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"743b260f-0099-4c49-9a9d-7df67196d74b","children":[],"html":"HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度","zIndex":166}],"html":"头信息压缩","zIndex":163},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4b39c42a-3354-4654-8f2e-fda0b3744de7","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d5b4600c-81ee-4e9d-a0e2-8bf978228f9f","children":[],"html":"HTTP/2 允许服务器在客户端请求之前主动推送资源，提高了页面加载速度和性能。注意：这里推送的主要是静态资源，和Websocket推送即使数据是不一样的。","zIndex":168}],"html":"服务器推送","zIndex":167},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"84cb3f5e-f564-48c8-af11-b1ba2569e118","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"87a531a1-64a7-47c5-850e-78536b708be9","children":[],"html":"HTTP/2 支持定义请求的优先级，使服务器可以优先处理重要的请求，提高了用户体验。","zIndex":170},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a9c95d20-d579-4a0b-9bc2-44a090dfef5a","children":[],"html":"HTTP/1.1：没有明确的流量优先级定义，所有请求都平等对待。","zIndex":171}],"html":"流量优先级","zIndex":169},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7d48bcab-42fa-42b8-b386-b656d3daf2b2","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8519b071-43ad-427c-ba8d-6a4893dda7c2","children":[],"html":"HTTP/2 的协议设计允许在不破坏现有部署的情况下进行平滑升级。","zIndex":173},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dd7ac622-c389-4dd9-94e7-eedeea573e9a","children":[],"html":"HTTP/1.1：升级到其他协议需要使用 Upgrade 头部，不够灵活。","zIndex":174}],"html":"升级机制","zIndex":172},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"be421bb3-70c5-49b3-bee1-214d81164e85","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9ac16248-5933-44f2-85c1-81b357f3a872","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cb856157-b99b-445c-877b-f0dd119987b7","children":[],"html":"HTTP/2 通常通过 TLS（Transport Layer Security）加密传输数据，保证数据的机密性和完整性","layout":{"quadrant":1},"zIndex":177},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fa47b13f-bc12-426e-ae24-ac75fadba115","children":[],"html":"大多数现代浏览器和服务器都要求使用 HTTPS 协议来支持 HTTP/2，这意味着在使用 HTTP/2 时，网站必须使用 SSL/TLS 证书来对网站进行加密，从而保证数据的安全性","zIndex":178}],"html":"加密传输","zIndex":176},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b0ed23dc-0d92-46f5-beab-1c9c7b97a7b7","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"71423aa8-98fd-4fc9-b4dd-2fea4212f354","children":[],"html":"HTTP/2 采用了二进制传输和头部压缩等技术，减少了一些可能导致安全漏洞的攻击面。例如，头部压缩可以减少头部注入攻击的风险。","zIndex":180}],"html":"减少安全漏洞","zIndex":179}],"html":"安全性如何体现","layout":{"quadrant":1},"zIndex":175},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c34c2101-62a7-488a-a2f5-ac99576afbfd","children":[],"html":"总的来说，HTTP/2 的改进主要集中在提高性能、减少延迟、增加安全性等方面，旨在更好地满足现代网络应用的需求。","zIndex":181}],"html":"HTTP 2.0 的改进","collapsed":true,"zIndex":48},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a2ffc4bf-49ca-492f-a608-3043c0f52485","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"97643bee-cb90-402a-8b33-44f3fc378143","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"af521f8e-3e54-47c1-aaa2-0c167b1cb63f","children":[],"html":"HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议","zIndex":68}],"html":"安全性","zIndex":69},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d69e44b1-6bdf-4518-a168-88df23f8c8fa","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"61d2d5bb-2d2a-4a59-b9f0-0ca26aa64ba2","children":[],"html":"HTTPS默认使用443端口进行通信，而HTTP默认使用80端口。","zIndex":72}],"html":"端口号","zIndex":73},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3f331bc5-9fe3-4f0e-94e1-8e34806875e0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c37bb582-4096-4fcf-a2d1-faf15234c120","children":[],"html":"HTTPS的URL前缀为\"https://\"，而HTTP的URL前缀为\"http://\"","zIndex":76}],"html":"URL前缀","zIndex":77},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"afdcc224-bd22-4d0e-ba5e-1acfc1002603","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0746d7c3-475a-42be-ab98-2510031dfdfc","children":[],"html":"HTTPS协议需要CA证书，费用较高；而HTTP协议不需要","zIndex":74}],"html":"证书","zIndex":75},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5260b78c-9f5f-4f2c-8e4a-049be36cb198","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"15d22b75-9d68-4bd8-b68e-fcf34283202f","children":[],"html":"HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源","zIndex":70}],"html":"资源消耗","zIndex":71},{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"21165c28-a150-4af0-8f21-f3db00ff355b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"rgba(0, 0, 0, 0)","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9394ece2-47e1-49ba-a3f4-1a20d3265607","children":[],"html":"搜索引擎（如Google）更倾向于显示HTTPS网站的搜索结果，因为HTTPS提供了更高的安全性和用户隐私保护。相比之下，HTTP网站在搜索排名上可能会受到一定的影响。","zIndex":66}],"html":"搜索引擎优化","zIndex":67}],"html":"HTTP 和 HTTPS 的区别","layout":{"quadrant":1},"zIndex":78},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1dbac123-99e2-4040-a778-99fc570ed47b","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"43faf49a-365e-4ee0-b99e-764b74a4bf0d","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"706d8288-dadb-4a6d-bb90-2e409bd2aff4","children":[],"html":"GET 请求是幂等请求，一般用于对服务器资源没有影响的场景；POST用于对服务器资源产生影响的场景","zIndex":183}],"html":"应用场景","zIndex":182},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7af907e3-57d3-4f1f-9ddd-4f04f1c72746","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e72a565f-a696-4b24-a4d4-c34d4b71fadf","children":[],"html":"浏览器对GET请求缓存，对POST一般不缓存","zIndex":185}],"html":"是否缓存","zIndex":184},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"026ebb56-f437-44c5-88d0-dbf37a8370d3","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"411d2033-3434-45d9-904a-4cfcd31fd0a1","children":[],"html":"GET请求报文中实体部分为空，POST请求的报文中实体部分一般是向服务器发送的数据","zIndex":187}],"html":"报文格式","zIndex":186},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"85cce037-1937-46d9-aea4-462fcda479a3","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"eaa99360-575a-4714-b26f-91c279fc164a","children":[],"html":"GET请求参数放在URL中，并且请求的URL会被保存在历史记录中，相对POST不安全","zIndex":189}],"html":"安全性","zIndex":188},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"828fc11a-a925-4780-b88d-ddcb6259dbe2","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1ada66f6-28e2-422f-8f37-1f8838d2071b","children":[],"html":"浏览器对URL长度有限制，一般在2000到8000字符之间，chrome是在2000左右，会影响 GET 请求发送数据的长度。POST请求长度没有限制。","zIndex":191}],"html":"请求长度","zIndex":190},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"915e6939-7e9e-47c0-9df4-12734e99bb0e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4007ec2a-82c2-4a9f-9eb7-dc2ceda036e7","children":[],"html":"因为URL只支持ASCII码，GET参数中如果存在中文等字符就需要先进行转码；POST 的参数传递支持更多数据类型：表单数据、JSON、XML、纯文本、二进制数据、混合类型","zIndex":193}],"html":"参数类型","zIndex":192}],"html":"GET 和 POST的区别","collapsed":true,"zIndex":79},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"05a76487-58c7-4757-8ca5-a9d0c43250ab","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"42530c5d-86e7-487c-a961-8f7e822211a7","children":[],"html":"PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）","zIndex":81},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"84b09adc-85c6-484f-b7fc-036acc6ad593","children":[],"html":"POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）","zIndex":80}],"html":"POST 和 PUT 的区别","zIndex":82},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"812d9f7a-b3ac-4e57-8a53-71e87d166af0","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4abb3811-17c7-4ed8-91df-37b95a4c50f8","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ca569185-9236-41d4-a936-17f9edd38e97","children":[],"html":"Accept：浏览器能够处理的内容类型","zIndex":56},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f77ee765-b51b-47f1-9f58-02c50dc5924c","children":[],"html":"Accept-Charset：浏览器能够显示的字符集","zIndex":58},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"717b0d8e-91c2-49f4-aad1-68c14cd366b8","children":[],"html":"Accept-Encoding：浏览器能够处理的压缩编码","zIndex":60},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"97430ec4-31b5-4ad4-af95-fa3d70d0e63c","children":[],"html":"Accept-Language：浏览器当前设置的语言","zIndex":62},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"769cef26-4d95-495a-9928-21d641164074","children":[],"html":"Connection：浏览器与服务器之间连接的类型","zIndex":63},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b5a28d1f-4b23-4592-9cc3-80b629c16f77","children":[],"html":"Cookie：当前页面设置的任何Cookie","zIndex":61},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"936f91c9-f66b-40cc-b34b-b203c5f57d1c","children":[],"html":"Host：发出请求的页面所在的域","zIndex":59},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"58c41a76-3a78-4e2a-9583-27ed9a53b84b","children":[],"html":"Referer：发出请求的页面的URL","zIndex":57},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5d7e48f8-7c52-4cbb-813c-acfd3481678e","children":[],"html":"User-Agent：浏览器的用户代理字符串","zIndex":55}],"html":"请求头","zIndex":64},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3097f12c-3eaa-4cf3-a484-867dd5cb8934","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"915902b3-d609-43ea-a348-5e9155a6c05d","children":[],"html":"Date：表示消息发送的时间，时间的描述格式由rfc822定义","zIndex":50},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ead86892-d217-4017-ba1b-41002a09f1e8","children":[],"html":"server：服务器名称","zIndex":52},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"566d2b3b-8591-4050-86d9-7dfb2a65b4dd","children":[],"html":"Connection：浏览器与服务器之间连接的类型","zIndex":53},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8ffc7a22-99de-41cc-883d-069042fae123","children":[],"html":"Cache-Control：控制HTTP缓存","zIndex":51},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ba876467-1844-4bd6-8e35-2bd4909830fa","children":[],"html":"content-type：表示后面的文档属于什么MIME类型","zIndex":49}],"html":"响应头","zIndex":54}],"html":"常见HTTP请求头和响应头","zIndex":65},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d30b7457-4ea4-445a-9058-4579a376e831","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2008a148-5b72-469d-bc0b-c4cd3d73fab5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"dda73031-8cf6-47e3-ae50-396d22ad022b","children":[],"html":"1XX的状态码是在HTTP/1.1 中引入的，它们是信息性的状态码，是临时的，表示请求已被接受，需要继续处理。","zIndex":195}],"html":"1xx","zIndex":194},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"215cdf53-b0b1-4acc-a38b-40fb8d080669","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"30d30be3-e65b-41cd-a398-8df0d4c3a43a","children":[],"html":"2xx 状态码表示客户端的请求被成功接收、理解和接受。","zIndex":197},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b45957eb-e213-4288-8eb4-7c5e99a9b03d","children":[],"html":"200 OK：表示客户端的请求被服务器正常处理了。从SEO的角度来看，200 表示搜索引擎爬虫可以成功爬取该页面并将其放入其搜索引擎中","zIndex":198},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7ede00eb-628c-4bd7-839d-67f3ace89547","children":[],"html":"204 No Content：该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。","zIndex":199}],"html":"2xx","zIndex":196},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6a477d69-d5ab-4ac6-9086-9db2834f98c5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"88808046-70a2-47ea-a56a-e258bc328e83","children":[],"html":"3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。","zIndex":201},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2854eaff-5cee-46f8-a872-dc0c39590ab2","children":[],"html":"301：永久重定向","zIndex":202},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"721879fd-5a5e-4170-b34c-dde45ae536f5","children":[],"html":"302：临时重定向","zIndex":203},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"be94e915-184f-4a8f-a7a5-7a685c8a12cb","children":[],"html":"304：浏览器缓存相关，表示资源未修改，可以使用缓存的版本","width":518.3333449055995,"zIndex":204}],"html":"3xx","zIndex":200},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d7581af7-c12f-4296-a098-d4b7a016d9a5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fa47afb8-c8a5-4774-95c3-c932d0ae0ea5","children":[],"html":"客户端错误","zIndex":206},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a5084b63-0079-413c-9829-9cb22ad24c0e","children":[],"html":"400 Bad Request：请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。","zIndex":207},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bfe47b5f-ffaa-4f85-9006-ae667ce009c8","children":[],"html":"401 Unauthorized：401状态码表示客户端请求的资源需要身份验证，但客户端没有提供有效的凭证。","zIndex":208},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f8f3783f-5e13-4169-b300-622a7772a274","children":[],"html":"403 Forbidden：客户端请求已被拒绝，因为客户端无权访问内容。与 401 不同，服务器知道客户端的身份，但由于他们无权查看内容，因此服务器拒绝提供正确的响应。","zIndex":209},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ecda374f-69fa-4e68-9e73-e94571313426","children":[],"html":"404 Not Found：服务器上无法找到请求的资源。","zIndex":210},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c818554d-fa0d-4c13-a9cf-c076fbee4694","children":[],"html":"405 Method Not Allowed：服务器识别到浏览器使用的 HTTP 请求方法，但需要使用不同的方法才能提供所需的资源。","zIndex":211}],"html":"4xx","zIndex":205},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f277bf89-821f-44dc-9007-e6a8262929c2","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"402d6f21-ec8c-4bd3-9d57-4084c6aa9244","children":[],"html":"服务器错误","zIndex":213},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3f5b6b86-d3f8-4283-8134-76c495cc6676","children":[],"html":"500 Internal Server Error：服务器端在执行请求时发生了错误","zIndex":214},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"71d271da-397d-41ac-b99a-d101fe40d0e7","children":[],"html":"501 Not Implemented：请求无法处理，因为服务器不支持","zIndex":215},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8d1ccbcd-771e-440e-86a6-4d0a7c391f1e","children":[],"html":"502 Bad Gateway：该扮演网关或代理角色的服务器从上游服务器中接收到的响应是无效的","zIndex":216},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8e135f66-8b71-410f-9c66-3a2ceac5b6ef","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1ed4e553-ca17-4f97-bdeb-78a3e27bcbff","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"15a1df7a-9d49-4243-89a0-7d162f789060","children":[],"html":"服务器停机维护时，主动用503响应请求","layout":{"quadrant":1},"zIndex":219},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"60403277-60c1-421d-a0a3-0a39b0583d9a","children":[],"html":"nginx 设置限速，超过限速，会返回503","layout":{"quadrant":1},"zIndex":220}],"html":"使用场景","zIndex":218}],"html":"503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求","zIndex":217},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b8863476-c95d-4925-a9bb-2503d9b02c50","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ba0560f6-c23e-48bd-9c2a-8c56df919d1c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"91caf4da-f5c1-4f8b-8cb2-2a717c11fc75","children":[],"html":"代码执行时间超时","layout":{"quadrant":1},"zIndex":223},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"659bb739-8e8e-4bff-93a8-8a0c226f9def","children":[],"html":"代码发生了死循环","layout":{"quadrant":1},"zIndex":224}],"html":"使用场景","zIndex":222}],"html":"504 Gateway Timeout：网关或者代理的服务器无法在规定的时间内获得想要的响应。它是HTTP 1.1中新加入的。","zIndex":221}],"html":"5xx","zIndex":212}],"html":"常见的HTTP状态码","collapsed":true,"zIndex":47},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"441f5ca1-8d58-42c5-a3dd-b037c86bdb48","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d321eb06-13e9-45af-8476-343be4be6117","children":[],"html":"Content-Type 是<span style=\"font-weight:bold;\"> HTTP 请求和响应头中的一个字段</span>，用于指示发送或接收的实体的媒体类型。","zIndex":225},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fb0f2493-cda3-4f83-9448-b397be87c114","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8a2a0ceb-1551-4bb6-bb18-9547e090811b","children":[],"html":"浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL转码","zIndex":227}],"html":"application/x-www-form-urlencoded&nbsp;","zIndex":226},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5608b836-869a-4e46-ad3f-c61c4802a9e5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"696599de-5637-48c3-b65b-3b8b93e31bb4","children":[],"html":"一种常见的 POST 数据提交的方式，用于文件上传的表单数据的编码格式。我们在使用表单上传文件时，必须让 form 的 enctyped 等于这个值。","zIndex":229}],"html":"multipart/form-data&nbsp;","zIndex":228},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a1a384ea-0bd9-41de-a3e8-337d9d09b3e1","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8a6ca6ef-b654-4397-a90f-c93b10f3205a","children":[],"html":"JSON 数据，用于传输结构化数据","zIndex":231}],"html":"application/json&nbsp;","zIndex":230},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6393023b-be27-4b56-b041-8dfa44ced778","children":[],"html":"text/xml，text/plain，text/html，text/css，text/javascript&nbsp;","zIndex":232},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d3a59758-a15d-459b-bbfe-08dc0c3bda54","children":[],"html":"application/pdf，image/jpeg，image/png，image/gif，audio/mpeg，video/mp4","height":59.28018324617062,"width":559.4605115722661,"zIndex":233}],"html":"Content-Type","collapsed":true,"zIndex":46},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"efdb8920-85f7-4e97-880f-4761efef8d2c","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d2a8ce78-376b-4937-8d2f-156f6c4e64fa","children":[],"html":"在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。","zIndex":234},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"45a859a4-f1b8-4f41-bbdf-34ae9016b19c","children":[],"html":"而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：Connection:keep-alive","zIndex":235},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2e0e64e7-1e4c-4cf8-a3ad-d4d842d3a7a0","children":[],"html":"在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。","zIndex":236},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"16b8a445-fff9-4e87-880f-694f7e2fd789","children":[],"html":"Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。","zIndex":237}],"html":"对HTTP长连接和短连接的理解","collapsed":true,"zIndex":39}],"layout":{"quadrant":1},"html":"HTTP协议","zIndex":83},{"layout":{"quadrant":1,"type":"standard","direction":[1,0],"quadrantConstraint":[1]},"border":{"shape":"rect","stroke-width":2,"fill":"#E6F4FC","stroke":"transparent"},"id":"43dc0806-f55c-4c7d-8759-54a645ad99f9","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0a7adba0-ddc9-4434-97d2-cc6debb745cf","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4d6c39b8-fa9a-4533-ae5a-1fc90e1b347e","children":[],"html":"HTTPS（Hypertext Transfer Protocol Secure）是一种用于安全传输数据的通信协议。HTTPS在HTTP的基础上添加了SSL/TLS协议来进行数据加密和身份验证，从而防止数据在传输过程中被窃取或篡改。","zIndex":239},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ed296076-05d2-473e-b3f5-4097f2681936","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4dadd212-4dfb-45d1-a793-50fa77f79ffb","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"10a6c15d-0d50-4c67-ab43-f1284441a904","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3b2bcfe9-a744-41d0-abce-6909b009dcbc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7f6b31d5-73af-4a6e-803d-c61b48ff9ce7","children":[],"html":"特点：在信息传输过程中，散列函数不能单独实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。","zIndex":244}],"html":"散列函数hash：验证信息的完整性","layout":{"quadrant":1},"zIndex":243},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a4f8b11c-cf7c-4d89-a4ee-ea554cc74fdc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e3b79105-2758-4928-b08b-8a1a6a79c02d","children":[],"html":"特点：对称加密的优势是信息传输使用一对一，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。","zIndex":246}],"html":"对称加密：采用协商的秘钥对数据加密","layout":{"quadrant":1},"zIndex":245},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d17aa64b-4932-45b0-b23c-23edab7f488e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"85b5f2c8-e858-43bf-a6ed-e16f14f6dac3","children":[],"html":"特点：非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，该算法的计算复杂，加密的速度慢。","zIndex":248}],"html":"非对称加密：身份认证和秘钥协商","layout":{"quadrant":1},"zIndex":247},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"555eb4fc-ca3b-4d58-9303-b92dff233275","children":[],"html":"综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。","height":114.88752626374867,"width":799.0487615722668,"zIndex":249}],"html":"功能实现依赖三类算法","zIndex":242}],"html":"HTTPS通常使用SSL/TLS协议进行<span style=\"font-weight:bold;\">数据加密和身份验证</span>。SSL（Secure Sockets Layer）和TLS（Transport Layer Security 安全传输层协议）是介于TCP和HTTP之间的一层安全协议，SSL是TLS的前身，现在大部分浏览器都不支持SSL，而是支持TLS。","zIndex":241}],"html":"TLS/SSL","zIndex":240}],"html":"概念","zIndex":238},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e2f47ccb-4c70-4fcf-88e5-1b922aa29a6e","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5a010cfb-d4b5-4468-b563-e0fada8e0cdc","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"db922db6-a8c3-4d04-90ba-21f6f6562f26","children":[],"html":"客户端发送一个连接请求到服务器，并且请求建立SSL/TLS连接。","zIndex":252},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b1e1817d-5fc2-4945-b873-4515271e3e45","children":[],"html":"服务器将自己的SSL/TLS证书（包含公钥）发送给客户端。","zIndex":253},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c3a38f99-e5d2-4434-8e45-811046e17b68","children":[],"html":"客户端验证服务器的证书是否合法，包括验证证书的签发机构是否可信、证书是否过期等。","height":60.56011696669657,"width":585.4648641799754,"zIndex":254},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4cd90ab9-c671-4bfa-bce9-bd74da0f932b","children":[],"html":"客户端生成一个用于对称加密的随机密钥（称为pre-master secret），并使用服务器的公钥加密这个随机密钥，然后发送给服务器。","zIndex":255}],"html":"1. 握手阶段","zIndex":251},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3177278e-1b2d-4aad-bbb2-2ccd4352bd1b","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"eab8ab70-30fc-4ad8-bc4e-ce5e580cb17b","children":[],"html":"服务器收到客户端发送的加密后的随机密钥，使用自己的私钥解密得到pre-master secret。","height":54.05218045875972,"width":593.9421884430144,"zIndex":257},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"88cd3575-7ce7-424f-9632-969b32532dfc","children":[],"html":"客户端和服务器都使用pre-master secret以及双方之前已经交换的信息，通过一系列的密钥协商算法生成会话密钥（session key），用于对称加密和解密通信内容。","height":81.71204440433803,"width":543.1474038625151,"zIndex":258}],"html":"2. 密钥协商阶段","zIndex":256},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ad5734c3-1a28-4388-a16e-579a908bd76f","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"604544f4-b3bf-46d9-bf9d-900603c93faf","children":[],"html":"客户端和服务器使用协商好的会话密钥进行对称加密和解密通信内容。","zIndex":260},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6db7c313-f039-4afa-8138-15860ac5a0a3","children":[],"html":"所有通过HTTPS连接传输的数据都会被加密，使得第三方无法窃听或篡改通信内容。","height":55.901386807966446,"width":543.1474038625151,"zIndex":261}],"html":"3. 加密通信阶段","zIndex":259}],"html":"实现加密步骤","zIndex":250},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d3ffb190-5f1d-49ff-9f26-a035755459e6","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0f1b2776-4859-4f62-9ec7-7c787c3fd3f4","children":[],"html":"1、 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了","width":508.0087615722664,"zIndex":263},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1d15f7b8-fcf9-4080-8fd5-39eb12d37a58","children":[],"html":"2、 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构","width":543.2887615722661,"zIndex":264},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4f1a058b-028c-4270-b707-1ef374984b9a","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"51dcd042-f92b-463e-9e95-584449198f9b","children":[],"html":"验证证书的合法性","zIndex":266},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"324d30db-5854-47cf-92da-34b9c81f3013","children":[],"html":"如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密","zIndex":267},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4f340d2c-2ab3-4e2e-b45f-7b34794bc77a","children":[],"html":"用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器","zIndex":268}],"html":"3、客户端收到网站的证书之后要做下面的事情：","zIndex":265},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"9e29dd6d-5c2b-4c65-b4c9-3f0c9d2c0166","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b71c6841-1bc4-471a-87ab-10f1c35f4266","children":[],"html":"4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致","zIndex":270},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"33781805-c0ff-43fb-a80e-d77d75fed525","children":[],"html":"4.2 使用密钥加密消息","zIndex":271}],"html":"4、服务器接收到客户端传送来的信息，要做下面的事情","zIndex":269},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"14169be9-3084-4a0a-ad8a-654d71d62bfb","children":[],"html":"5、如果计算法 hash 值一致，握手成功。","zIndex":272}],"html":"HTTPS的工作过程","layout":{"quadrant":1},"zIndex":262},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"04b2b7f7-15fb-4a86-a0c6-fbeebb7694e2","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5f24b8c8-174b-412e-a6a6-eeee28db12a7","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7ef59748-e6df-4261-ac24-43e67e45c3f0","children":[],"html":"使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器","zIndex":275},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"baf8d0f1-f7a5-4cda-a868-38a156935659","children":[],"html":"HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性","zIndex":276},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c5c485d0-c59d-485d-b16e-5f665baebb19","children":[],"html":"HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。","zIndex":277}],"html":"优点","zIndex":274},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"169fa745-03cd-495f-bffe-0ea50651f9d1","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"28376447-5f8f-46a0-9a74-aff4aafaf795","children":[],"html":"HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电","zIndex":279},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"35d79414-a894-4500-accb-122f22482843","children":[],"html":"HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响","zIndex":280},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"232a864e-8d3c-4500-a3ad-cb3f6e186cfa","children":[],"html":"SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用","zIndex":281},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"705e3106-c0fe-4162-9502-21ec11f4c4fe","children":[],"html":"SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗","zIndex":282},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"47a33aa3-c64c-4fd6-96b0-1d6001639474","children":[],"html":"HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。","zIndex":283}],"html":"缺点","zIndex":278}],"html":"优缺点","zIndex":273},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0801dc97-2fdb-4add-ac14-9af1771f6818","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"028c7a39-61f9-402a-801a-5458d57306c6","children":[],"html":"为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。","zIndex":285}],"html":"什么是数字签名","zIndex":284},{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"75f2df50-f022-4b70-aa6b-37d03695cfd0","children":[{"border":{"shape":"rect","stroke":"transparent","fill":"#E6F4FC","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"23240ab1-ea4c-48fa-b5f4-2c9a2d36f2da","children":[],"html":"对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。","zIndex":287}],"html":"什么是数字证书","zIndex":286},{"start":1,"end":1,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\">&#8203;<br></div>","defaultContentStyle":{"color":"#262626"},"id":"5a74ee41-eba2-4c6c-8d3c-46667a6ebe67","children":[],"height":495.4773387637488,"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1712572252032-981d1dcc-a82d-415e-bf1f-e1fab2814492.png","naturalWidth":2805,"naturalHeight":1570,"uploadInfo":{"hash":"f09d48d3b02c8395cca2d40b6e17a5d173a1c2e32bb9066ff365ba2c631dda32","fileName":"yuque_diagram (3).png","fileType":"image/png","fileSize":2091946,"localTempSrc":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1712572252032-981d1dcc-a82d-415e-bf1f-e1fab2814492.png","state":-2},"width":776.5310740722671,"height":434.63593094240974},"width":792.5310740722671,"zIndex":288}],"html":"<a href=\"https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&amp;vd_source=5ba4dd6fd917c0255b4e766006e53137\" target=\"_blank\" style>HTTPS</a>","treeEdge":{"stroke":"#69B1E4","stroke-width":2},"collapsed":true,"zIndex":32},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"408b197b-1a47-4577-b1c7-c9678efd4ff5","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"40736342-6441-4911-b456-369161bd49b3","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2927626f-23c8-428f-be8f-26ca69a3681a","children":[],"html":"WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。","zIndex":290}],"html":"概念","zIndex":289},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a25ee894-2c88-4b2f-974a-fa5f75380e26","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0e91a75b-294f-4e74-b580-d84810180210","children":[],"html":"最大特点：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。","zIndex":292},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8f81df5e-ed2b-44a5-890d-1e5c713de9ed","children":[],"html":"支持双向通信，实时性更强","zIndex":293},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3782d677-8a75-45af-aff6-48fe762c9221","children":[],"html":"可以发送文本，也可以发送二进制数据","zIndex":294},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c8261c78-7b2d-4ef7-905c-610bbff5631a","children":[],"html":"建立在TCP协议之上，服务端的实现比较容易","zIndex":295},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8e322d85-1b02-4813-b446-5c91739d88fc","children":[],"html":"数据格式比较轻量，性能开销小，通信高效","zIndex":296},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1aa28d0b-97d2-4532-9841-8b968f3c8416","children":[],"html":"没有同源限制，客户端可以与任意服务器通信","zIndex":297},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e966f1c0-6c12-4fd3-abcf-8bed6d8e0d69","children":[],"html":"协议标识符是ws（如果加密，则为wss），服务器网址就是 URL","zIndex":298},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4224892b-78ca-45c7-a830-87e007a154b5","children":[],"html":"与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器","zIndex":299}],"html":"特点","zIndex":291},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"39d06b74-b54a-475c-9108-1c8904aa84e2","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"48ce2d6d-c74a-47a7-8536-f40ffa431413","children":[],"html":"客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。","zIndex":301}],"html":"原理","zIndex":300},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e2e55962-4dd9-4c7c-93e6-1d11ea530b8e","children":[{"border":{"shape":"rect","stroke":"#a287e1","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"971389d4-5d1f-4995-b991-e0f49939403d","children":[],"html":"// 在index.html中直接写WebSocket，设置服务端的端口号为 9999<div>let ws = new WebSocket('ws://localhost:9999');</div><div>// 在客户端与服务端建立连接后触发</div><div>ws.onopen = function() {</div><div>&nbsp; &nbsp; console.log(\"Connection open.\");&nbsp;</div><div>&nbsp; &nbsp; ws.send('hello');</div><div>};</div><div>// 在服务端给客户端发来消息的时候触发</div><div>ws.onmessage = function(res) {</div><div>&nbsp; &nbsp; console.log(res);       // 打印的是MessageEvent对象</div><div>&nbsp; &nbsp; console.log(res.data);  // 打印的是收到的消息</div><div>};</div><div>// 在客户端与服务端建立关闭后触发</div><div>ws.onclose = function(evt) {</div><div>&nbsp; console.log(\"Connection closed.\");</div><div>};</div>","zIndex":303}],"html":"使用","zIndex":302},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"21a1706f-b9f2-4da9-a4c6-8b928a2417df","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f42325f7-0979-444e-a68b-5b948dc0a8e6","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2867d629-b521-45c5-87cd-d88e2efde93f","children":[],"html":"浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。","zIndex":306},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b30cd4a6-326b-4001-b8bc-b3956fcfa431","children":[],"html":"优点：实现简单；缺点：由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源","zIndex":307}],"html":"短轮询","zIndex":305},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e8a04ddb-4dc8-44da-b313-b0a4bc1a4023","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"b3e6c4ee-1312-44b8-a848-853245d24d01","children":[],"html":"首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。","zIndex":309},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"3369ffd7-4554-472e-a9c3-77d1d4df8463","children":[],"html":"优点：明显减少了很多不必要的 http 请求次数，相比之下节约了资源。缺点：连接挂起也会导致资源的浪费。","zIndex":310}],"html":"长轮询","zIndex":308},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6386eeec-346d-4572-8e4a-45b12d87eb35","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"88dd7d94-001e-4ba2-9bad-901467a5136c","children":[],"html":"SSE（Server-Sent Events，服务器发送事件）是一种基于 HTTP 的协议，用于实现服务器向客户端单向持续发送数据的机制，从而实现长连接通信。","layout":{"quadrant":1},"zIndex":312},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"712b1833-9662-44d8-8e2e-9adb862b8391","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c048326e-2b0e-4211-9e88-c42061d95bb7","children":[],"html":"1. 客户端向服务器发送一个 HTTP 请求，请求一个 SSE 端点的 URL。","zIndex":314},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"590d4397-2916-4a5c-a1fb-bd99a933e9b8","children":[],"html":"2. 服务器收到请求后，返回一个包含特殊 MIME 类型（text/event-stream）的响应，并保持连接打开。","zIndex":315},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"cceb2647-6f19-428b-932c-93999b1d1745","children":[],"html":"3. 一旦连接建立，服务器可以随时向客户端发送数据。每条数据以一定格式发送，通常是以 \"data: \" 开头，以及可选的其他字段，如 \"event: \"、\"id: \" 等。","zIndex":316},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"983c4b0d-e52f-4152-9af4-5bce95b3f1d7","children":[],"html":"4. 客户端收到数据后，可以通过 JavaScript 的 EventSource 接口来处理这些事件，从而实现实时更新页面内容或执行其他操作。","zIndex":317}],"html":"服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。","zIndex":313},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"890667f6-a264-40d9-ae50-21c30cf3947f","children":[],"html":"SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。不适用于双向通信的场景。","zIndex":318},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"03a2c53f-ed3b-4f84-bde2-66ba590e207e","children":[],"html":"它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。","zIndex":319}],"html":"SSE","zIndex":311},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"25c4d93e-dc34-4ee9-b552-54f3d78f8377","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c0017db4-8aa4-4b92-8257-a21ba8134200","children":[],"html":"WebSocket 是 HTML5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。","zIndex":321}],"html":"Websocket","zIndex":320},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a38f9c38-ad95-467c-a800-d441820e3234","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c372b222-408f-4186-9e20-57682c8ffd49","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ff9d96af-266b-4add-b2ad-9a8d7ece07fb","children":[],"html":"WebSocket &gt; 长连接（SSE） &gt; 长轮询 &gt; 短轮询","zIndex":324}],"html":"性能角度","zIndex":323},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e6527a5b-0d10-462c-8c08-4c6aa58d18c1","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2f0249fb-a988-4f4b-b671-b8f3c18bc9e5","children":[],"html":"短轮询 &gt; 长轮询 &gt; 长连接（SSE） &gt; WebSocket","zIndex":326}],"html":"浏览器兼容性角度","zIndex":325}],"html":"对比","zIndex":322}],"html":"即时通讯的实现","zIndex":304}],"html":"Websocket","layout":{"quadrant":1},"collapsed":true,"zIndex":31},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#6F81DB"},"defaultContentStyle":{"color":"#262626"},"id":"fca914ba-a8f8-4ab5-9171-6e8adf4cd74a","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"840f56ed-b435-452c-8c04-84163f8a2ac3","children":[],"html":"Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。","zIndex":327},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"a8d5e60c-70ad-4a34-b5c9-0d75c8171aa9","children":[],"html":"Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。","zIndex":328},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"af9e0ebf-bdcb-47e5-9be9-e2cd16335974","children":[],"html":"实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。","zIndex":329},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ab845f39-2e6b-4c04-b82f-fd1a49988400","children":[],"html":"如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。","zIndex":330}],"html":"Cookie 和 Session 的区别","layout":{"quadrant":1},"collapsed":true,"zIndex":30},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#6EC4C4"},"defaultContentStyle":{"color":"#262626"},"id":"89a00491-571d-4df8-a0c3-3e14cfd1c938","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f70192cc-de3e-47e9-95e7-2e7e50f0ea8e","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"015cd02d-7a88-49b8-be1d-e8eab408222b","children":[],"html":"DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。","zIndex":332},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"41668ebf-50f9-4595-a06a-abfafa1a1ee2","children":[],"html":"作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。","zIndex":333},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"5375cb41-b678-4264-9c41-6ebebb28e51c","children":[],"html":"DNS占用53号端口，同时使用TCP和UDP协议。在区域传输时使用TCP协议，在域名解析时使用UDP协议。","zIndex":334}],"html":"DNS协议是什么","zIndex":331},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"6d6ad0c7-2d7f-44b5-9242-a33bdcd19405","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8248b3b5-8468-4e82-8630-0016df85ff30","children":[],"html":"首先会在<span style=\"font-weight:bold;\">浏览器的缓存</span>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步","zIndex":336},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"layout":{"quadrant":1},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"bc5a85ff-0d40-4563-919f-328e46980f94","children":[],"html":"将请求发送给<span style=\"font-weight:bold;\">本地DNS服务器</span>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步","zIndex":337},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"0ce2455d-a145-42d6-bc55-74fe0569996f","children":[],"html":"本地DNS服务器向<span style=\"font-weight:bold;\">根域名服务器</span>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址","zIndex":338},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"1e978a04-b17c-4481-8d18-b0ad5089e0dc","children":[],"html":"本地DNS服务器向<span style=\"font-weight:bold;\">顶级域名服务器</span>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址","zIndex":339},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"638c18bc-b844-454c-a2af-73d1e2be699e","children":[],"html":"本地DNS服务器向<span style=\"font-weight:bold;\">权威域名服务器</span>发送请求，域名服务器返回对应的结果","zIndex":340},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"03c8bbcc-a3fc-41df-8d7d-d0085d5e6a6c","children":[],"html":"本地DNS服务器将返回结果保存在缓存中，便于下次使用","zIndex":341},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"13ab70f5-1f44-48d2-a5a4-bbf57d017954","children":[],"html":"本地DNS服务器将返回结果返回给浏览器","zIndex":342}],"html":"DNS完整查询过程","zIndex":335},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e541ae32-a308-4c9b-b1f9-68cd34220354","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d50a8bbe-fcb5-4166-be40-66bd72b04c3c","children":[],"html":"递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。","zIndex":344},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c9096098-64d2-4c32-9c09-d4ce20d79055","children":[],"html":"迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。","zIndex":345},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"8afc377b-ec18-4eba-827e-1d703249156a","children":[],"html":"总的来说，递归查询是一种由 DNS 服务器负责完整查询过程的查询方式，而迭代查询是一种由 DNS 客户端主动发起并负责查询过程的查询方式。通常情况下，普通用户的计算机会使用递归查询，而 DNS 服务器之间通常会使用迭代查询。","zIndex":346}],"html":"迭代查询和递归查询","zIndex":343}],"html":"DNS","layout":{"quadrant":1},"collapsed":true,"zIndex":29},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2,"stroke":"#DFB85D"},"defaultContentStyle":{"color":"#262626"},"id":"7f007176-34ce-4dec-add2-4a87c9f02a6f","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"59ff9a3c-4efc-40cb-9b80-6ad75747c010","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4a2db698-d85d-4d90-a039-8de1d46dd4b0","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"93e99e99-6fc6-477b-8059-1761a284ea71","children":[],"html":"HTTP、FTP、SMTP","zIndex":349}],"html":"应用层","zIndex":348},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c27d39c1-b67e-487d-a27c-7af903c987ff","children":[],"html":"表示层","zIndex":350},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"ea14238b-8fc0-42b8-948b-eb384cd62537","children":[],"html":"会话层","zIndex":351},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"35a77f72-cb54-4bfe-bdf4-dc6e1a0175b8","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"73fdc631-a9ed-44db-94c1-9780077d48fe","children":[],"html":"TCP、UDP","zIndex":353}],"html":"传输层","zIndex":352},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"fa7cc23c-246f-4093-b87b-b67af3254377","children":[],"html":"网络层","zIndex":354},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"7316e287-8a2c-40f9-8d2e-fdaffbbbfcd2","children":[],"html":"数据链路层","zIndex":355},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"608dc9c4-172c-4d53-b71a-3d497ac2f5b0","children":[],"html":"物理层","zIndex":356},{"start":0,"end":6,"abstract":true,"layout":{"quadrant":1},"border":{"shape":"rect","stroke":"#BFBFBF","fill":"transparent","stroke-width":2},"treeEdge":{"stroke":"#BFBFBF","stroke-width":2},"html":"<div style=\"text-align:center;\"><span style></span></div>","defaultContentStyle":{"color":"#262626"},"id":"d1f84621-b8f5-4ae2-bd4c-bfe5adbc57f0","children":[],"height":348.29127626374793,"image":{"src":"https://cdn.nlark.com/yuque/0/2024/png/2798618/1712642286627-b64da487-84f0-43c1-974b-0a4f95088d8e.png","naturalWidth":1502,"naturalHeight":810,"uploadInfo":{"hash":"ef4357362aed6d8760d8a033a42de063c6f8293a6486fbd204568759aefb8c4c","fileName":"yuque_diagram (4).png","fileType":"image/png","fileSize":803514,"localTempSrc":"blob:https://www.yuque.com/477607ce-4fa2-4176-85ba-500984229d4f","state":-2},"width":616.1746875903079,"height":332.29127626374793},"width":650.5787615722661,"zIndex":357}],"html":"OSI七层模型","zIndex":347},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"4cb66bde-a90b-47f8-b06e-0e0e4f233496","children":[{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"e3f23686-a23d-49bc-86cf-20322300e69f","children":[],"html":"应用层","zIndex":359},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"d551ad75-0529-45c1-adb3-f869af7a08eb","children":[],"html":"传输层","zIndex":360},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"2660d3cb-34f2-45f4-bde7-23436d8cfa43","children":[],"html":"网络层","zIndex":361},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"c120e878-8179-439d-990f-b6af3b17e41e","children":[],"html":"数据链路层","zIndex":362},{"border":{"shape":"rect","stroke":"transparent","stroke-width":2},"treeEdge":{"stroke-width":2},"defaultContentStyle":{"color":"#262626"},"id":"f8902822-86a9-4d5e-9dcf-ced9f82cfa9d","children":[],"html":"物理层","zIndex":363}],"html":"TCP/IP五层协议","zIndex":358}],"html":"网络模型","layout":{"quadrant":1},"collapsed":true,"zIndex":0}],"layout":{"type":"standard","direction":[1,0]},"zIndex":84}]},"mode":"edit","viewportSetting":{"zoom":1,"tlCanvasPoint":[111.3662109375,2319.5,1],"width":1601,"height":949},"viewportOption":"adapt","text":"网络从输入网址到页面加载的整个过程详细版本解析URL输入URL中协议或主机名不合法，将输入内容传递给搜索引擎解析没有问题，浏览器检查url中是否有非法字符，如果有，进行转义缓存判断浏览器判断请求资源在缓存中，并且没有失效，如果是就直接使用，否则向服务器发起新的请求DNS解析获取MAC地址TCP三次握手HTTPS握手返回数据页面渲染TCP四次挥手精简版本1. DNS解析当用户在浏览器中输入网址后，浏览器首先会解析网址中的域名部分。浏览器会向本地 DNS 缓存或者 DNS 服务器发送请求，获取与域名对应的 IP 地址。2. 建立TCP连接通过 DNS 解析得到正确的 IP 地址后，浏览器会与服务器建立 TCP 连接。浏览器会通过三次握手与服务器进行通信，确保双方都能够正常发送和接收数据。3. 发送HTTP请求一旦建立了 TCP 连接，浏览器就会向服务器发送 HTTP 请求。请求中包含了请求方式（GET、POST 等）、请求头（User-Agent、Cookies 等）和请求体（POST 请求才有）等信息。4. 服务器响应服务器接收到浏览器的请求后，会根据请求的内容进行处理，并生成相应的响应。响应包括状态码（200 表示成功、404 表示未找到等）、响应头（Content-Type、Cache-Control 等）和响应体（HTML、CSS、JavaScript 等）。5. 页面渲染浏览器收到服务器的响应后，开始解析响应内容并进行页面渲染。首先，浏览器会解析 HTML，构建 DOM 树（文档对象模型）。然后，浏览器会解析 CSS，构建 CSSOM 树（CSS 对象模型）。接下来，浏览器将 DOM 树和 CSSOM 树结合，生成渲染树（Render Tree）。最后，浏览器根据渲染树进行布局（Layout）和绘制（Painting），将页面内容显示在用户的屏幕上。6. 加载资源在页面渲染的过程中，如果遇到外部资源（例如图片、样式表、脚本等），浏览器会根据需要发送额外的请求去加载这些资源。这些资源的加载过程类似于前面提到的发送 HTTP 请求和服务器响应的过程。7. 页面交互当页面渲染完成后，用户可以与页面进行交互。浏览器会监听用户的操作（例如点击、滚动、键盘输入等），并相应地处理这些操作。如果有 JavaScript 脚本，浏览器会执行这些脚本以实现页面的动态效果和交互功能。TCP 和 UDP三次握手刚开始客户端处于 init 的状态，服务端处于 listen 状态第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN(c)。此时客户端处于 SYN_Send 状态。第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)，同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 establised 状态。服务器收到 ACK 报文之后，也处于 establised 状态，此时，双方以建立起了链接为什么两次握手不可以为了防止已失效的请求报文突然又恢复引起的请求错误，三次握手本质上是为了解决网络信道不可靠的问题例如：客户端发送SYN包请求建立连接，但是由于网络阻塞没有到达服务端，客户端重发SYN包，服务端接收到SYN包，向客户端发送SYN+ACK包，双方建立连接，但是客户端第一个发送的SYN包突然恢复，送达服务端，服务端会认为这是客户端发起的一个新的连接，从而进入等待数据状态。服务端认为是两个连接，而客户端认为是一个连接，造成状态不一致。如果是三次握手，服务端收不到最后的ACK包，就不会认为建立连接成功​四次挥手处于连接的客户端和服务端都可以发起关闭连接请求，假如客户端发起连接关闭请求客户端向服务端发送一个FIN包，表示要关闭连接，自己进入终止等待1状态第一次挥手服务端收到FIN包，发送一个ACK包，表示自己进入关闭等待状态，客户端进入终止等待2状态第二次挥手服务端此时还可以发送未发送的数据，客户端还可以接收数据。服务端发送完数据后，发送一个FIN包，进入最后确认状态。第三次挥手客户端收到后，回复ACK包，进入超时等待状态，经过超时时间后关闭连接；服务端收到ACK后立即关闭连接。第四次挥手为什么要设置超时等待时间确保对方已收到ACK包。假设客户端发送完最后一包ACK包后就释放了连接，一旦ACK在网络中丢失，服务端将一直停留在最后确认状态。如果客户端进行超时等待过程中，服务端没有收到ACK包，会重发FIN包，客户端会响应FIN包重发ACK包，并刷新超时等待时间为了保证在不可靠的网络中，进行可靠的断开确认TCP 和 UPD 的区别两者都是传输层协议，最大的区别：一个基于连接，一个基于非连接TCP传输稳定可靠，适合对网络通讯质量要求较高的场景，如传输文件，浏览网页特点面向连接：双方传输数据前，通过三次握手建立通道，四次挥手结束销毁通道每一个TCP连接只能有两个端点，只能点对点提供可靠的传输服务，传送数据无差错，不丢失，不重复，按顺序到达TCP提供全双工通信面向字节流UDP发送数据就是简单封装数据包，然后从网卡发出去，数据包之间并没有状态上的联系优点：传输速度快，性能损耗少、CPU和内存资源占用少缺点：丢包问题、传输稳定性差适用于对实时性要求较高，但是对少量丢包没有太大要求的场景，如域名查询、语音通话、视频直播、隧道网络区别TCP是可靠传输,UDP是不可靠传输TCP面向连接,UDP无连接TCP传输数据有序,UDP不保证数据的有序性TCP不保存数据边界,UDP保留数据边界TCP传输速度相对UDP较慢TCP有流量控制和拥塞控制,UDP没有TCP是重量级协议,UDP是轻量级协议TCP首部较长２０字节,UDP首部较短８字节基于TCP和UDP的协议HTTP、HTTPS、FTP、TELNET、SMTP(简单邮件传输协议)协议基于可靠的TCP协议。TFTP、DNS、DHCP、TFTP、SNMP(简单网络管理协议)、RIP基于不可靠的UDP协议TCP 如何处理丢包和乱序问题TCP为每一个连接建立一个发送缓冲区，建立连接的第一个序列号为0，后面每个字节的序列号增加1发送数据时，从发送缓冲区取一部分数据组成发送报文，在其TCP协议中会附带序列号和长度接收端在收到数据后，需要回复确认报文，确认报文中的ACK=序列号+长度，也就是下一包数据的起始序列号这样一问一答的发送方式，能够使发送端确认发送的数据，已经被对方收到，发送端也可以一次发送连续的多包数据，接收端只需要回复一次ACK就可以了这样发送端可以把待发送的数据分割成一系列的碎片发送到对端；对端根据序列号和长度，在接收后重构出来完整的数据假设其中丢失了某些数据包，接收端可以要求发送端重传，例如丢失了100-199这100个字节，接收端可以向发送端发送ACK=100的报文，发送端收到后重传这一包数据，接收端进行补齐以上不区分客户端和服务端，TCP连接是全双工的，两端都采用上述机制其他TCP 重传机制TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。TCP 流量控制机制一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的滑动窗口进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。TCP 可靠传输机制TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。HTTP协议HTTP1.0 和 HTTP 1.1的区别连接方面，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。资源请求方面，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。缓存方面，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。http1.1 中新增了 host 字段，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。http1.1 相对于 http1.0 还新增了很多请求方法，如 PUT、HEAD、OPTIONS 等。HTTP 2.0 的改进多路复用HTTP/2 允许在一个 TCP 连接上同时发送多个请求和响应，消除了 HTTP/1.1 中的串行请求(队头堵塞)问题，提高了网络利用率二进制协议HTTP/2 使用二进制格式而不是文本格式传输数据，减少了传输的开销，并且更容易进行解析和处理。在 HTTP/1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。头信息压缩HTTP/2 使用 HPACK 算法对首部进行压缩，减少了首部的大小，降低了网络延迟和带宽消耗；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度服务器推送HTTP/2 允许服务器在客户端请求之前主动推送资源，提高了页面加载速度和性能。注意：这里推送的主要是静态资源，和Websocket推送即使数据是不一样的。流量优先级HTTP/2 支持定义请求的优先级，使服务器可以优先处理重要的请求，提高了用户体验。HTTP/1.1：没有明确的流量优先级定义，所有请求都平等对待。升级机制HTTP/2 的协议设计允许在不破坏现有部署的情况下进行平滑升级。HTTP/1.1：升级到其他协议需要使用 Upgrade 头部，不够灵活。安全性如何体现加密传输HTTP/2 通常通过 TLS（Transport Layer Security）加密传输数据，保证数据的机密性和完整性大多数现代浏览器和服务器都要求使用 HTTPS 协议来支持 HTTP/2，这意味着在使用 HTTP/2 时，网站必须使用 SSL/TLS 证书来对网站进行加密，从而保证数据的安全性减少安全漏洞HTTP/2 采用了二进制传输和头部压缩等技术，减少了一些可能导致安全漏洞的攻击面。例如，头部压缩可以减少头部注入攻击的风险。总的来说，HTTP/2 的改进主要集中在提高性能、减少延迟、增加安全性等方面，旨在更好地满足现代网络应用的需求。HTTP 和 HTTPS 的区别安全性HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议端口号HTTPS默认使用443端口进行通信，而HTTP默认使用80端口。URL前缀HTTPS的URL前缀为\"https://\"，而HTTP的URL前缀为\"http://\"证书HTTPS协议需要CA证书，费用较高；而HTTP协议不需要资源消耗HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源搜索引擎优化搜索引擎（如Google）更倾向于显示HTTPS网站的搜索结果，因为HTTPS提供了更高的安全性和用户隐私保护。相比之下，HTTP网站在搜索排名上可能会受到一定的影响。GET 和 POST的区别应用场景GET 请求是幂等请求，一般用于对服务器资源没有影响的场景；POST用于对服务器资源产生影响的场景是否缓存浏览器对GET请求缓存，对POST一般不缓存报文格式GET请求报文中实体部分为空，POST请求的报文中实体部分一般是向服务器发送的数据安全性GET请求参数放在URL中，并且请求的URL会被保存在历史记录中，相对POST不安全请求长度浏览器对URL长度有限制，一般在2000到8000字符之间，chrome是在2000左右，会影响 GET 请求发送数据的长度。POST请求长度没有限制。参数类型因为URL只支持ASCII码，GET参数中如果存在中文等字符就需要先进行转码；POST 的参数传递支持更多数据类型：表单数据、JSON、XML、纯文本、二进制数据、混合类型POST 和 PUT 的区别PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时更新数据）POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是创建数据）常见HTTP请求头和响应头请求头Accept：浏览器能够处理的内容类型Accept-Charset：浏览器能够显示的字符集Accept-Encoding：浏览器能够处理的压缩编码Accept-Language：浏览器当前设置的语言Connection：浏览器与服务器之间连接的类型Cookie：当前页面设置的任何CookieHost：发出请求的页面所在的域Referer：发出请求的页面的URLUser-Agent：浏览器的用户代理字符串响应头Date：表示消息发送的时间，时间的描述格式由rfc822定义server：服务器名称Connection：浏览器与服务器之间连接的类型Cache-Control：控制HTTP缓存content-type：表示后面的文档属于什么MIME类型常见的HTTP状态码1xx1XX的状态码是在HTTP/1.1 中引入的，它们是信息性的状态码，是临时的，表示请求已被接受，需要继续处理。2xx2xx 状态码表示客户端的请求被成功接收、理解和接受。200 OK：表示客户端的请求被服务器正常处理了。从SEO的角度来看，200 表示搜索引擎爬虫可以成功爬取该页面并将其放入其搜索引擎中204 No Content：该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。3xx3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。301：永久重定向302：临时重定向304：浏览器缓存相关，表示资源未修改，可以使用缓存的版本4xx客户端错误400 Bad Request：请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。401 Unauthorized：401状态码表示客户端请求的资源需要身份验证，但客户端没有提供有效的凭证。403 Forbidden：客户端请求已被拒绝，因为客户端无权访问内容。与 401 不同，服务器知道客户端的身份，但由于他们无权查看内容，因此服务器拒绝提供正确的响应。404 Not Found：服务器上无法找到请求的资源。405 Method Not Allowed：服务器识别到浏览器使用的 HTTP 请求方法，但需要使用不同的方法才能提供所需的资源。5xx服务器错误500 Internal Server Error：服务器端在执行请求时发生了错误501 Not Implemented：请求无法处理，因为服务器不支持502 Bad Gateway：该扮演网关或代理角色的服务器从上游服务器中接收到的响应是无效的503 Service Unavailable：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求使用场景服务器停机维护时，主动用503响应请求nginx 设置限速，超过限速，会返回503504 Gateway Timeout：网关或者代理的服务器无法在规定的时间内获得想要的响应。它是HTTP 1.1中新加入的。使用场景代码执行时间超时代码发生了死循环Content-TypeContent-Type 是 HTTP 请求和响应头中的一个字段，用于指示发送或接收的实体的媒体类型。application/x-www-form-urlencoded 浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1=val1&key2=val2 的方式进行编码，key 和 val 都进行了 URL转码multipart/form-data 一种常见的 POST 数据提交的方式，用于文件上传的表单数据的编码格式。我们在使用表单上传文件时，必须让 form 的 enctyped 等于这个值。application/json JSON 数据，用于传输结构化数据text/xml，text/plain，text/html，text/css，text/javascript application/pdf，image/jpeg，image/png，image/gif，audio/mpeg，video/mp4对HTTP长连接和短连接的理解在 HTTP/1.0 中默认使用短连接。也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如：JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 HTTP 会话。而从 HTTP/1.1 起，默认使用长连接，用以保持连接特性。使用长连接的 HTTP 协议，会在响应头加入这行代码：Connection:keep-alive在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive 不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如：Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。HTTPS概念HTTPS（Hypertext Transfer Protocol Secure）是一种用于安全传输数据的通信协议。HTTPS在HTTP的基础上添加了SSL/TLS协议来进行数据加密和身份验证，从而防止数据在传输过程中被窃取或篡改。TLS/SSLHTTPS通常使用SSL/TLS协议进行数据加密和身份验证。SSL（Secure Sockets Layer）和TLS（Transport Layer Security 安全传输层协议）是介于TCP和HTTP之间的一层安全协议，SSL是TLS的前身，现在大部分浏览器都不支持SSL，而是支持TLS。功能实现依赖三类算法散列函数hash：验证信息的完整性特点：在信息传输过程中，散列函数不能单独实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。对称加密：采用协商的秘钥对数据加密特点：对称加密的优势是信息传输使用一对一，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。非对称加密：身份认证和秘钥协商特点：非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，该算法的计算复杂，加密的速度慢。综合上述算法特点，TLS/SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。实现加密步骤1. 握手阶段客户端发送一个连接请求到服务器，并且请求建立SSL/TLS连接。服务器将自己的SSL/TLS证书（包含公钥）发送给客户端。客户端验证服务器的证书是否合法，包括验证证书的签发机构是否可信、证书是否过期等。客户端生成一个用于对称加密的随机密钥（称为pre-master secret），并使用服务器的公钥加密这个随机密钥，然后发送给服务器。2. 密钥协商阶段服务器收到客户端发送的加密后的随机密钥，使用自己的私钥解密得到pre-master secret。客户端和服务器都使用pre-master secret以及双方之前已经交换的信息，通过一系列的密钥协商算法生成会话密钥（session key），用于对称加密和解密通信内容。3. 加密通信阶段客户端和服务器使用协商好的会话密钥进行对称加密和解密通信内容。所有通过HTTPS连接传输的数据都会被加密，使得第三方无法窃听或篡改通信内容。HTTPS的工作过程1、 客户端发送自己支持的加密规则给服务器，代表告诉服务器要进行连接了2、 服务器从中选出一套加密算法和 hash 算法以及自己的身份信息（地址等）以证书的形式发送给浏览器，证书中包含服务器信息，加密公钥，证书的办法机构3、客户端收到网站的证书之后要做下面的事情：验证证书的合法性如果验证通过证书，浏览器会生成一串随机数，并用证书中的公钥进行加密用约定好的 hash 算法计算握手消息，然后用生成的密钥进行加密，然后一起发送给服务器4、服务器接收到客户端传送来的信息，要做下面的事情4.1 用私钥解析出密码，用密码解析握手消息，验证 hash 值是否和浏览器发来的一致4.2 使用密钥加密消息5、如果计算法 hash 值一致，握手成功。优缺点优点使用 HTTPS 协议可认证用户和服务器，确保数据发送到正确的客户机和服务器HTTPS 协议是由 SSL + HTTP 协议构建的可进行加密传输、身份认证的网络协议，要比 HTTP 协议安全，可防止数据在传输过程中不被窃取、改变，确保数据的完整性HTTPS 是现行架构下最安全的解决方案，虽然不是绝对安全，但它大幅增加了中间人攻击的成本。缺点HTTPS 协议握手阶段比较费时，会使页面的加载时间延长近 50%，增加 10% 到 20% 的耗电HTTPS 连接缓存不如 HTTP 高效，会增加数据开销和功耗，甚至已有的安全措施也会因此而受到影响SSL 证书需要钱，功能越强大的证书费用越高，个人网站、小网站没有必要一般不会用SSL 证书通常需要绑定 IP，不能在同一 IP 上绑定多个域名，IPv4 资源不可能支撑这个消耗HTTPS 协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用。最关键的，SSL 证书的信用链体系并不安全，特别是在某些国家可以控制 CA 根证书的情况下，中间人攻击一样可行。什么是数字签名为了避免数据在传输过程中被替换，比如黑客修改了你的报文内容，但是你并不知道，所以我们让发送端做一个数字签名，把数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。什么是数字证书对称加密中，双方使用公钥进行解密。虽然数字签名可以保证数据不被替换，但是数据是由公钥加密的，如果公钥也被替换，则仍然可以伪造数据，因为用户不知道对方提供的公钥其实是假的。所以为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的，用户请求服务器时，服务器将证书发给用户，这个证书是经由系统内置证书的备案的。​Websocket概念WebSocket是HTML5提供的一种浏览器与服务器进行全双工通讯的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。特点最大特点：服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。支持双向通信，实时性更强可以发送文本，也可以发送二进制数据建立在TCP协议之上，服务端的实现比较容易数据格式比较轻量，性能开销小，通信高效没有同源限制，客户端可以与任意服务器通信协议标识符是ws（如果加密，则为wss），服务器网址就是 URL与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器原理客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。使用// 在index.html中直接写WebSocket，设置服务端的端口号为 9999let ws = new WebSocket('ws://localhost:9999');// 在客户端与服务端建立连接后触发ws.onopen = function() {    console.log(\"Connection open.\");     ws.send('hello');};// 在服务端给客户端发来消息的时候触发ws.onmessage = function(res) {    console.log(res);       // 打印的是MessageEvent对象    console.log(res.data);  // 打印的是收到的消息};// 在客户端与服务端建立关闭后触发ws.onclose = function(evt) {  console.log(\"Connection closed.\");};即时通讯的实现短轮询浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。优点：实现简单；缺点：由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源长轮询首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。优点：明显减少了很多不必要的 http 请求次数，相比之下节约了资源。缺点：连接挂起也会导致资源的浪费。SSESSE（Server-Sent Events，服务器发送事件）是一种基于 HTTP 的协议，用于实现服务器向客户端单向持续发送数据的机制，从而实现长连接通信。服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE/Edge，其他浏览器都支持。1. 客户端向服务器发送一个 HTTP 请求，请求一个 SSE 端点的 URL。2. 服务器收到请求后，返回一个包含特殊 MIME 类型（text/event-stream）的响应，并保持连接打开。3. 一旦连接建立，服务器可以随时向客户端发送数据。每条数据以一定格式发送，通常是以 \"data: \" 开头，以及可选的其他字段，如 \"event: \"、\"id: \" 等。4. 客户端收到数据后，可以通过 JavaScript 的 EventSource 接口来处理这些事件，从而实现实时更新页面内容或执行其他操作。SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。不适用于双向通信的场景。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。WebsocketWebSocket 是 HTML5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。对比性能角度WebSocket > 长连接（SSE） > 长轮询 > 短轮询浏览器兼容性角度短轮询 > 长轮询 > 长连接（SSE） > WebSocketCookie 和 Session 的区别Session是在服务端保存的一个数据结构，用来跟踪用户的状态，这个数据可以保存在集群、数据库、文件中。Cookie是客户端保存用户信息的一种机制，用来记录用户的一些信息，也是实现Session的一种方式。实际上大多数的应用都是用 Cookie 来实现Session跟踪的，第一次创建Session的时候，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 sid=xxxxx 这样的参数，服务端据此来识别用户。DNSDNS协议是什么DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。作用： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。DNS占用53号端口，同时使用TCP和UDP协议。在区域传输时使用TCP协议，在域名解析时使用UDP协议。DNS完整查询过程首先会在浏览器的缓存中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步将请求发送给本地DNS服务器，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步本地DNS服务器向根域名服务器发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址本地DNS服务器向顶级域名服务器发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址本地DNS服务器向权威域名服务器发送请求，域名服务器返回对应的结果本地DNS服务器将返回结果保存在缓存中，便于下次使用本地DNS服务器将返回结果返回给浏览器迭代查询和递归查询递归查询指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。迭代查询指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。总的来说，递归查询是一种由 DNS 服务器负责完整查询过程的查询方式，而迭代查询是一种由 DNS 客户端主动发起并负责查询过程的查询方式。通常情况下，普通用户的计算机会使用递归查询，而 DNS 服务器之间通常会使用迭代查询。网络模型OSI七层模型应用层HTTP、FTP、SMTP表示层会话层传输层TCP、UDP网络层数据链路层物理层TCP/IP五层协议应用层传输层网络层数据链路层物理层","graphicsBBox":{"x":471.3662414550781,"y":519.2548217773438,"width":1209,"height":4099}}